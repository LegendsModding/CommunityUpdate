/* eslint-disable @typescript-eslint/camelcase */
/*
========== INFO ==========
This file is FULLY auto-generated. DO NOT edit this file or your changes will be lost! Please edit files in the "api" folder. 
==========================
*/


// FILE CONTENTS: bsharp_api_constants.gen.d.ts


/**
 * GAMEMODE: BASE
 * ALL_INVASION_ACTIONS
 */
declare const ALL_INVASION_ACTIONS: []

/**
 * GAMEMODE: campaign
 * AllCounters
 */
declare const AllCounters: []

/**
 * GAMEMODE: BASE
 * ALLIANCE_ENEMY
 */
declare const ALLIANCE_ENEMY: string

/**
 * GAMEMODE: BASE
 * ALLIANCE_FRIENDLY
 */
declare const ALLIANCE_FRIENDLY: string

/**
 * GAMEMODE: BASE
 * ALLOWED_INVASION_BASE_SIZES
 */
declare const ALLOWED_INVASION_BASE_SIZES: []

/**
 * GAMEMODE: Demo_MinecraftLive
 * ALLOWED_VILLAGE_VARIATION_FACTIONS
 */
declare const ALLOWED_VILLAGE_VARIATION_FACTIONS: []

/**
 * GAMEMODE: Demo_MinecraftLive
 * ALLOWED_VILLAGE_VARIATION_SIZES
 */
declare const ALLOWED_VILLAGE_VARIATION_SIZES: []

/**
 * GAMEMODE: campaign
 * ANY_CONCURRENT
 */
declare const ANY_CONCURRENT: number

/**
 * GAMEMODE: campaign
 * ANY_GAP
 */
declare const ANY_GAP: number

/**
 * GAMEMODE: BASE
 * ANY_MEET_THE_BOSS_CINEMATIC_PLAYED
 */
declare const ANY_MEET_THE_BOSS_CINEMATIC_PLAYED: string

/**
 * GAMEMODE: BASE
 * AREA_SOAK_TIME
 */
declare const AREA_SOAK_TIME: any

/**
 * GAMEMODE: challenge_pack_1_TimedBaseDestruction
 * AREA_TRIGGER_VOLUME_ID
 */
declare const AREA_TRIGGER_VOLUME_ID: string

/**
 * GAMEMODE: BASE
 * AREAS_OF_INTERESTS
 */
declare const AREAS_OF_INTERESTS: []

/**
 * GAMEMODE: campaign
 * AUTOMATIC_TARGET
 */
declare const AUTOMATIC_TARGET: number

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_ALLIES
 */
declare const BARRACKS_NAME_ALLIES: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_CREEPER
 */
declare const BARRACKS_NAME_CREEPER: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_DISRUPTOR
 */
declare const BARRACKS_NAME_DISRUPTOR: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_ENGINEER
 */
declare const BARRACKS_NAME_ENGINEER: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_FIGHTER
 */
declare const BARRACKS_NAME_FIGHTER: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_SIEGER
 */
declare const BARRACKS_NAME_SIEGER: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_SKELETON
 */
declare const BARRACKS_NAME_SKELETON: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_SPECIALIST
 */
declare const BARRACKS_NAME_SPECIALIST: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_VINDICATORS
 */
declare const BARRACKS_NAME_VINDICATORS: string

/**
 * GAMEMODE: BASE
 * BARRACKS_NAME_ZOMBIE
 */
declare const BARRACKS_NAME_ZOMBIE: string

/**
 * GAMEMODE: campaign
 * BASE_ANY_INVASION
 */
declare const BASE_ANY_INVASION: string

/**
 * GAMEMODE: campaign
 * BASE_NONPLANNING
 */
declare const BASE_NONPLANNING: string

/**
 * GAMEMODE: campaign
 * BASE_PLANNING
 */
declare const BASE_PLANNING: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ACT_1_A
 */
declare const BASE_SIZE_ACT_1_A: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ACT_1_B
 */
declare const BASE_SIZE_ACT_1_B: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ACT_1_C
 */
declare const BASE_SIZE_ACT_1_C: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ACT1_FIRST_SKIRMISH
 */
declare const BASE_SIZE_ACT1_FIRST_SKIRMISH: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ACT1_NON_PORTAL_ATTACK_BASE
 */
declare const BASE_SIZE_ACT1_NON_PORTAL_ATTACK_BASE: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ACT1_SECOND_SKIRMISH
 */
declare const BASE_SIZE_ACT1_SECOND_SKIRMISH: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ALL
 */
declare const BASE_SIZE_ALL: []

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ALL_FOBS
 */
declare const BASE_SIZE_ALL_FOBS: []

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ALL_PORTALS
 */
declare const BASE_SIZE_ALL_PORTALS: []

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ALL_PORTALS_AND_BOSS
 */
declare const BASE_SIZE_ALL_PORTALS_AND_BOSS: []

/**
 * GAMEMODE: BASE
 * BASE_SIZE_ALL_VILLAGES
 */
declare const BASE_SIZE_ALL_VILLAGES: []

/**
 * GAMEMODE: campaign
 * BASE_SIZE_ANY
 */
declare const BASE_SIZE_ANY: []

/**
 * GAMEMODE: BASE
 * BASE_SIZE_BOSS
 */
declare const BASE_SIZE_BOSS: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_DARK_BEACON
 */
declare const BASE_SIZE_DARK_BEACON: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_FOB_LARGE
 */
declare const BASE_SIZE_FOB_LARGE: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_FOB_MEDIUM
 */
declare const BASE_SIZE_FOB_MEDIUM: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_FOB_SMALL
 */
declare const BASE_SIZE_FOB_SMALL: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_LARGE
 */
declare const BASE_SIZE_LARGE: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_MEDIUM
 */
declare const BASE_SIZE_MEDIUM: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_OUTPOST
 */
declare const BASE_SIZE_OUTPOST: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_PIGLIN_CREEPER
 */
declare const BASE_SIZE_PIGLIN_CREEPER: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_PIGLIN_SKELETON
 */
declare const BASE_SIZE_PIGLIN_SKELETON: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_PIGLIN_WOF
 */
declare const BASE_SIZE_PIGLIN_WOF: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_PIGLIN_ZOMBIE
 */
declare const BASE_SIZE_PIGLIN_ZOMBIE: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_SMALL
 */
declare const BASE_SIZE_SMALL: string

/**
 * GAMEMODE: BASE
 * BASE_SIZE_VANGUARD
 */
declare const BASE_SIZE_VANGUARD: string

/**
 * GAMEMODE: BASE
 * BASE_STINGER_RANGE
 */
declare const BASE_STINGER_RANGE: number

/**
 * GAMEMODE: campaign
 * BASES_BREAKING_INACTIVITY
 */
declare const BASES_BREAKING_INACTIVITY: []

/**
 * GAMEMODE: BASE
 * BIOME_NAME_BEACH
 */
declare const BIOME_NAME_BEACH: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_DESERT
 */
declare const BIOME_NAME_DESERT: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_DESERT_HILLS
 */
declare const BIOME_NAME_DESERT_HILLS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_DRYLANDS
 */
declare const BIOME_NAME_DRYLANDS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_DRYLANDS_HOODOO_LARGE
 */
declare const BIOME_NAME_DRYLANDS_HOODOO_LARGE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_DRYLANDS_HOODOO_MEDIUM
 */
declare const BIOME_NAME_DRYLANDS_HOODOO_MEDIUM: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_DRYLANDS_HOODOO_SMALL
 */
declare const BIOME_NAME_DRYLANDS_HOODOO_SMALL: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_EXTREME_HILLS
 */
declare const BIOME_NAME_EXTREME_HILLS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_EXTREME_HILLS_EDGE
 */
declare const BIOME_NAME_EXTREME_HILLS_EDGE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_EXTREME_HILLS_MEGA
 */
declare const BIOME_NAME_EXTREME_HILLS_MEGA: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_EXTREME_HILLS_PLUS_TREES
 */
declare const BIOME_NAME_EXTREME_HILLS_PLUS_TREES: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_FATEFUL_LAND
 */
declare const BIOME_NAME_FATEFUL_LAND: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_FOREST
 */
declare const BIOME_NAME_FOREST: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_FOREST_HILLS
 */
declare const BIOME_NAME_FOREST_HILLS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_FROSTLANDS
 */
declare const BIOME_NAME_FROSTLANDS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_FROZEN_RIVER
 */
declare const BIOME_NAME_FROZEN_RIVER: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_GRASSLANDS
 */
declare const BIOME_NAME_GRASSLANDS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_GRASSLANDS_RIVER
 */
declare const BIOME_NAME_GRASSLANDS_RIVER: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_GRASSLANDS_SHORE
 */
declare const BIOME_NAME_GRASSLANDS_SHORE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_ICE_MOUNTAINS
 */
declare const BIOME_NAME_ICE_MOUNTAINS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_ICE_PLAINS
 */
declare const BIOME_NAME_ICE_PLAINS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_ICE_PLAINS_SPIKES
 */
declare const BIOME_NAME_ICE_PLAINS_SPIKES: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_JUNGLE
 */
declare const BIOME_NAME_JUNGLE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_JUNGLE_EDGE
 */
declare const BIOME_NAME_JUNGLE_EDGE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_JUNGLE_HILLS
 */
declare const BIOME_NAME_JUNGLE_HILLS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_MESA
 */
declare const BIOME_NAME_MESA: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_MESA_BRYCE
 */
declare const BIOME_NAME_MESA_BRYCE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_OUTBOUNDS_DESERT
 */
declare const BIOME_NAME_OUTBOUNDS_DESERT: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_OUTBOUNDS_ICE
 */
declare const BIOME_NAME_OUTBOUNDS_ICE: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_OUTBOUNDS_MOUNTAINS
 */
declare const BIOME_NAME_OUTBOUNDS_MOUNTAINS: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_OUTBOUNDS_OCEAN
 */
declare const BIOME_NAME_OUTBOUNDS_OCEAN: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_RIVER
 */
declare const BIOME_NAME_RIVER: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_SWAMPLAND
 */
declare const BIOME_NAME_SWAMPLAND: string

/**
 * GAMEMODE: BASE
 * BIOME_NAME_WETLANDS
 */
declare const BIOME_NAME_WETLANDS: string

/**
 * GAMEMODE: BASE
 * BOSS_BASE_PLACED
 */
declare const BOSS_BASE_PLACED: string

/**
 * GAMEMODE: BASE
 * BUILDING_APPEARANCE_OVERRIDE_ATTACK_HORDE
 */
declare const BUILDING_APPEARANCE_OVERRIDE_ATTACK_HORDE: string

/**
 * GAMEMODE: BASE
 * BUILDING_APPEARANCE_OVERRIDE_DBB_HORDE
 */
declare const BUILDING_APPEARANCE_OVERRIDE_DBB_HORDE: string

/**
 * GAMEMODE: BASE
 * BUILDING_APPEARANCE_OVERRIDE_DEFEND_HORDE
 */
declare const BUILDING_APPEARANCE_OVERRIDE_DEFEND_HORDE: string

/**
 * GAMEMODE: BASE
 * BUILDING_APPEARANCE_OVERRIDE_OBSTACLE_HORDE
 */
declare const BUILDING_APPEARANCE_OVERRIDE_OBSTACLE_HORDE: string

/**
 * GAMEMODE: BASE
 * BUILDING_APPEARANCE_OVERRIDE_WOF_HORDE
 */
declare const BUILDING_APPEARANCE_OVERRIDE_WOF_HORDE: string

/**
 * GAMEMODE: BASE
 * CALLBACK_NONE
 */
declare const CALLBACK_NONE: string

/**
 * GAMEMODE: BASE
 * CARD_LIBRARY_BIOMESET
 */
declare const CARD_LIBRARY_BIOMESET: string

/**
 * GAMEMODE: BASE
 * CARD_LIBRARY_BIOMESET_RINGS
 */
declare const CARD_LIBRARY_BIOMESET_RINGS: string

/**
 * GAMEMODE: BASE
 * CULTURE_NAME_VILLAGERS
 */
declare const CULTURE_NAME_VILLAGERS: string

/**
 * GAMEMODE: BASE
 * CULTURE_THRESHOLDS
 */
declare const CULTURE_THRESHOLDS: []

/**
 * GAMEMODE: BASE
 * CURRENT_BUILDINGS_COUNT_VAR
 */
declare const CURRENT_BUILDINGS_COUNT_VAR: string

/**
 * GAMEMODE: BASE
 * CURRENT_FAILED_BUILDINGS_COUNT_VAR
 */
declare const CURRENT_FAILED_BUILDINGS_COUNT_VAR: string

/**
 * GAMEMODE: BASE
 * CURRENT_TEST_VILLAGE_ID
 */
declare const CURRENT_TEST_VILLAGE_ID: string

/**
 * GAMEMODE: campaign
 * DaysSinceAnyHordeEstablished
 */
declare const DaysSinceAnyHordeEstablished: any

/**
 * GAMEMODE: campaign
 * DaysSinceCounter
 */
declare const DaysSinceCounter: any

/**
 * GAMEMODE: BASE
 * DECK_NAME_BIOMESET_INSIDE
 */
declare const DECK_NAME_BIOMESET_INSIDE: string

/**
 * GAMEMODE: BASE
 * DECK_NAME_BIOMESET_OUTSIDE
 */
declare const DECK_NAME_BIOMESET_OUTSIDE: string

/**
 * GAMEMODE: BASE
 * EAST
 */
declare const EAST: string

/**
 * GAMEMODE: BASE
 * ELEVATION_CLOUD
 */
declare const ELEVATION_CLOUD: number

/**
 * GAMEMODE: BASE
 * ELEVATION_MAX
 */
declare const ELEVATION_MAX: number

/**
 * GAMEMODE: BASE
 * ELEVATION_MIN
 */
declare const ELEVATION_MIN: number

/**
 * GAMEMODE: BASE
 * ELEVATION_SEA
 */
declare const ELEVATION_SEA: number

/**
 * GAMEMODE: BASE
 * EMPTY_ENTITY_GROUP
 */
declare const EMPTY_ENTITY_GROUP: []

/**
 * GAMEMODE: campaign
 * ENTRY_PHASE_FIRSTBASE
 */
declare const ENTRY_PHASE_FIRSTBASE: number

/**
 * GAMEMODE: campaign
 * ENTRY_PHASE_NONE
 */
declare const ENTRY_PHASE_NONE: number

/**
 * GAMEMODE: campaign
 * ENTRY_PHASE_PREGAME
 */
declare const ENTRY_PHASE_PREGAME: number

/**
 * GAMEMODE: BASE
 * EXIT_REASON_DESTROYED
 */
declare const EXIT_REASON_DESTROYED: number

/**
 * GAMEMODE: BASE
 * EXIT_REASON_LEAVE
 */
declare const EXIT_REASON_LEAVE: number

/**
 * GAMEMODE: BASE
 * EXPECTED_BUILDINGS_COUNT_VAR
 */
declare const EXPECTED_BUILDINGS_COUNT_VAR: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_ATTACK_VILLAGE_V2
 */
declare const FACTION_ACTION_ATTACK_VILLAGE_V2: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_ATTACK_VILLAGE_V2_ATTACK_BOSS
 */
declare const FACTION_ACTION_ATTACK_VILLAGE_V2_ATTACK_BOSS: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_ATTACK_VILLAGE_V2_DOUBLE
 */
declare const FACTION_ACTION_ATTACK_VILLAGE_V2_DOUBLE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BOSS_OCCUPATION
 */
declare const FACTION_ACTION_BOSS_OCCUPATION: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_DEFENSIVE_OUTPOST
 */
declare const FACTION_ACTION_BUILD_DEFENSIVE_OUTPOST: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_DEFENSIVE_OUTPOST_TRIPLE
 */
declare const FACTION_ACTION_BUILD_DEFENSIVE_OUTPOST_TRIPLE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_FAR_BASE
 */
declare const FACTION_ACTION_BUILD_FAR_BASE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_NEAR_BASE
 */
declare const FACTION_ACTION_BUILD_NEAR_BASE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_NEAR_BASE_DOUBLE
 */
declare const FACTION_ACTION_BUILD_NEAR_BASE_DOUBLE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_NEW_OUTPOST
 */
declare const FACTION_ACTION_BUILD_NEW_OUTPOST: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_OFFENSIVE_OUTPOST
 */
declare const FACTION_ACTION_BUILD_OFFENSIVE_OUTPOST: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_BUILD_OFFENSIVE_OUTPOST_DOUBLE
 */
declare const FACTION_ACTION_BUILD_OFFENSIVE_OUTPOST_DOUBLE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_CLAIM_AREA
 */
declare const FACTION_ACTION_CLAIM_AREA: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_ESTABLISH
 */
declare const FACTION_ACTION_ESTABLISH: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_OOPS
 */
declare const FACTION_ACTION_OOPS: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_OOPS_DOUBLE
 */
declare const FACTION_ACTION_OOPS_DOUBLE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_UPGRADE_BASE
 */
declare const FACTION_ACTION_UPGRADE_BASE: string

/**
 * GAMEMODE: BASE
 * FACTION_ACTION_UPGRADE_BASE_DOUBLE
 */
declare const FACTION_ACTION_UPGRADE_BASE_DOUBLE: string

/**
 * GAMEMODE: BASE
 * FACTION_MOB_ALLIANCES
 */
declare const FACTION_MOB_ALLIANCES: []

/**
 * GAMEMODE: BASE
 * FACTION_NAME_ATTACK
 */
declare const FACTION_NAME_ATTACK: string

/**
 * GAMEMODE: BASE
 * FACTION_NAME_DBB
 */
declare const FACTION_NAME_DBB: string

/**
 * GAMEMODE: BASE
 * FACTION_NAME_DEFEND
 */
declare const FACTION_NAME_DEFEND: string

/**
 * GAMEMODE: BASE
 * FACTION_NAME_OBSTACLE
 */
declare const FACTION_NAME_OBSTACLE: string

/**
 * GAMEMODE: pvp
 * Faction_NAME_PVP
 */
declare const Faction_NAME_PVP: string

/**
 * GAMEMODE: BASE
 * FACTION_NAME_ROAMING
 */
declare const FACTION_NAME_ROAMING: string

/**
 * GAMEMODE: BASE
 * FACTION_NAME_WOF
 */
declare const FACTION_NAME_WOF: string

/**
 * GAMEMODE: BASE
 * FACTION_PIGLINS
 */
declare const FACTION_PIGLINS: []

/**
 * GAMEMODE: BASE
 * FACTION_PIGLINS_ALL
 */
declare const FACTION_PIGLINS_ALL: []

/**
 * GAMEMODE: BASE
 * FACTION_POI_ALL
 */
declare const FACTION_POI_ALL: []

/**
 * GAMEMODE: BASE
 * FACTION_POI_ALLIES
 */
declare const FACTION_POI_ALLIES: []

/**
 * GAMEMODE: BASE
 * FACTION_POI_MOUNTS
 */
declare const FACTION_POI_MOUNTS: []

/**
 * GAMEMODE: BASE
 * FACTION_POI_TOWERS
 */
declare const FACTION_POI_TOWERS: []

/**
 * GAMEMODE: BASE
 * GAME_ACT_WAIT_TIME
 */
declare const GAME_ACT_WAIT_TIME: any

/**
 * GAMEMODE: BASE
 * GAME_DIFFICULTY_PROGRESSION
 */
declare const GAME_DIFFICULTY_PROGRESSION: []

/**
 * GAMEMODE: BASE
 * GAMEMODE_CAMPAIGN
 */
declare const GAMEMODE_CAMPAIGN: string

/**
 * GAMEMODE: BASE
 * GAMEMODE_CREATIVE
 */
declare const GAMEMODE_CREATIVE: string

/**
 * GAMEMODE: BASE
 * GAMEMODE_EDITOR
 */
declare const GAMEMODE_EDITOR: string

/**
 * GAMEMODE: BASE
 * GAMEMODE_PVP
 */
declare const GAMEMODE_PVP: string

/**
 * GAMEMODE: BASE
 * GAP_BETWEEN_BASES
 */
declare const GAP_BETWEEN_BASES: number

/**
 * GAMEMODE: pvp
 * GENERIC_PVP_CAPTURABLE_TV_ID
 */
declare const GENERIC_PVP_CAPTURABLE_TV_ID: string

/**
 * GAMEMODE: campaign
 * GLOBAL_RESTRICTION
 */
declare const GLOBAL_RESTRICTION: string

/**
 * GAMEMODE: campaign
 * GLOBAL_TRACKER
 */
declare const GLOBAL_TRACKER: string

/**
 * GAMEMODE: BASE
 * GV_ACT_1_BASES_DESTROYED
 */
declare const GV_ACT_1_BASES_DESTROYED: string

/**
 * GAMEMODE: BASE
 * GV_AMOUNT_OF_LOOT_OPENED_FOR_SNIPER_ALLY_MISSING_PIECE
 */
declare const GV_AMOUNT_OF_LOOT_OPENED_FOR_SNIPER_ALLY_MISSING_PIECE: string

/**
 * GAMEMODE: BASE
 * GV_ATTACK_HORDE_BOSS_ATTACK_ACTIVE_ID
 */
declare const GV_ATTACK_HORDE_BOSS_ATTACK_ACTIVE_ID: string

/**
 * GAMEMODE: BASE
 * GV_ATTACK_HORDE_BOSS_ATTACK_PLANNED
 */
declare const GV_ATTACK_HORDE_BOSS_ATTACK_PLANNED: string

/**
 * GAMEMODE: BASE
 * GV_ATTACK_HORDE_BOSS_HEALTH
 */
declare const GV_ATTACK_HORDE_BOSS_HEALTH: string

/**
 * GAMEMODE: challenge_pack_1_TimedBaseDestruction
 * GV_CM1_TIMER
 */
declare const GV_CM1_TIMER: string

/**
 * GAMEMODE: challenge_pack_1_TimedBaseDestruction
 * GV_CM1_VILLAGES_DESTROYED
 */
declare const GV_CM1_VILLAGES_DESTROYED: string

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 * GV_CM2_CENTRAL_VILLAGE_ID
 */
declare const GV_CM2_CENTRAL_VILLAGE_ID: string

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 * GV_CM2_CURRENT_PIGLIN_COUNT
 */
declare const GV_CM2_CURRENT_PIGLIN_COUNT: string

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 * GV_CM2_CURRENT_WAVE
 */
declare const GV_CM2_CURRENT_WAVE: string

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 * GV_CM2_TIMER
 */
declare const GV_CM2_TIMER: string

/**
 * GAMEMODE: BASE
 * GV_DB_REINFORCEMENTS_STARTED
 */
declare const GV_DB_REINFORCEMENTS_STARTED: string

/**
 * GAMEMODE: BASE
 * GV_DBB_VARIANT
 */
declare const GV_DBB_VARIANT: string

/**
 * GAMEMODE: BASE
 * GV_DISABLE_HOSTS
 */
declare const GV_DISABLE_HOSTS: string

/**
 * GAMEMODE: BASE
 * GV_FIRST_LOAD_GAME_DIFFICULTY
 */
declare const GV_FIRST_LOAD_GAME_DIFFICULTY: string

/**
 * GAMEMODE: BASE
 * GV_INVASION_OPENING_NIGHT
 */
declare const GV_INVASION_OPENING_NIGHT: string

/**
 * GAMEMODE: BASE
 * GV_PIGLIN_BASE_FIRST_NON_SMALL_ENCOUNTER
 */
declare const GV_PIGLIN_BASE_FIRST_NON_SMALL_ENCOUNTER: string

/**
 * GAMEMODE: BASE
 * GV_PIGLIN_PORTAL_DAMAGED_VO_DEBOUNCE
 */
declare const GV_PIGLIN_PORTAL_DAMAGED_VO_DEBOUNCE: string

/**
 * GAMEMODE: BASE
 * GV_REESCALATION_RESET_TIME
 */
declare const GV_REESCALATION_RESET_TIME: string

/**
 * GAMEMODE: BASE
 * GV_ROAMING_PIGLIN_ATTACK_FACTION_SPAWNERS
 */
declare const GV_ROAMING_PIGLIN_ATTACK_FACTION_SPAWNERS: []

/**
 * GAMEMODE: BASE
 * GV_ROAMING_PIGLIN_DEFEND_FACTION_SPAWNERS
 */
declare const GV_ROAMING_PIGLIN_DEFEND_FACTION_SPAWNERS: []

/**
 * GAMEMODE: BASE
 * GV_ROAMING_PIGLIN_OBSTACLE_FACTION_SPAWNERS
 */
declare const GV_ROAMING_PIGLIN_OBSTACLE_FACTION_SPAWNERS: []

/**
 * GAMEMODE: BASE
 * GV_SNIPER_ALLY_MISSING_PIECE_FOUND
 */
declare const GV_SNIPER_ALLY_MISSING_PIECE_FOUND: string

/**
 * GAMEMODE: BASE
 * GV_STARTED_ACT_1_B
 */
declare const GV_STARTED_ACT_1_B: string

/**
 * GAMEMODE: BASE
 * GV_STARTED_ACT_2
 */
declare const GV_STARTED_ACT_2: string

/**
 * GAMEMODE: BASE
 * GV_STARTED_ACT_3_A
 */
declare const GV_STARTED_ACT_3_A: string

/**
 * GAMEMODE: BASE
 * GV_STARTED_ACT_3_B
 */
declare const GV_STARTED_ACT_3_B: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * GV_STARTED_DEMO
 */
declare const GV_STARTED_DEMO: string

/**
 * GAMEMODE: BASE
 * GV_STARTED_EPILOGUE
 */
declare const GV_STARTED_EPILOGUE: string

/**
 * GAMEMODE: BASE
 * GV_SUPER_NETHER_SPREADERS_KILLED
 */
declare const GV_SUPER_NETHER_SPREADERS_KILLED: string

/**
 * GAMEMODE: BASE
 * GV_TELEMETRY_GAMEACT
 */
declare const GV_TELEMETRY_GAMEACT: string

/**
 * GAMEMODE: BASE
 * GV_TELEMETRY_LOCAL_TIMER_VALUE
 */
declare const GV_TELEMETRY_LOCAL_TIMER_VALUE: string

/**
 * GAMEMODE: BASE
 * GV_VILLAGE_DAMAGED
 */
declare const GV_VILLAGE_DAMAGED: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_CREEPER
 */
declare const GV_WORLD_SPAWNER_CREEPER: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_CREEPER_CONFLICT
 */
declare const GV_WORLD_SPAWNER_CREEPER_CONFLICT: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_CREEPER_HOMESTEAD
 */
declare const GV_WORLD_SPAWNER_CREEPER_HOMESTEAD: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_SKELETON
 */
declare const GV_WORLD_SPAWNER_SKELETON: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_SKELETON_CONFLICT
 */
declare const GV_WORLD_SPAWNER_SKELETON_CONFLICT: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_SKELETON_HOMESTEAD
 */
declare const GV_WORLD_SPAWNER_SKELETON_HOMESTEAD: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_ZOMBIE
 */
declare const GV_WORLD_SPAWNER_ZOMBIE: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_ZOMBIE_CONFLICT
 */
declare const GV_WORLD_SPAWNER_ZOMBIE_CONFLICT: string

/**
 * GAMEMODE: BASE
 * GV_WORLD_SPAWNER_ZOMBIE_HOMESTEAD
 */
declare const GV_WORLD_SPAWNER_ZOMBIE_HOMESTEAD: string

/**
 * GAMEMODE: campaign
 * HORDE_ANY
 */
declare const HORDE_ANY: []

/**
 * GAMEMODE: BASE
 * HORDE_ARRIVED_FIFTH
 */
declare const HORDE_ARRIVED_FIFTH: any

/**
 * GAMEMODE: BASE
 * HORDE_ARRIVED_FIRST
 */
declare const HORDE_ARRIVED_FIRST: any

/**
 * GAMEMODE: BASE
 * HORDE_ARRIVED_FOURTH
 */
declare const HORDE_ARRIVED_FOURTH: any

/**
 * GAMEMODE: BASE
 * HORDE_ARRIVED_SECOND
 */
declare const HORDE_ARRIVED_SECOND: any

/**
 * GAMEMODE: BASE
 * HORDE_ARRIVED_SIXTH
 */
declare const HORDE_ARRIVED_SIXTH: any

/**
 * GAMEMODE: BASE
 * HORDE_ARRIVED_THIRD
 */
declare const HORDE_ARRIVED_THIRD: any

/**
 * GAMEMODE: BASE
 * HORDE_PIGLINS_ALL
 */
declare const HORDE_PIGLINS_ALL: []

/**
 * GAMEMODE: campaign
 * HordeBasesConstructedAndUpgradedCounter
 */
declare const HordeBasesConstructedAndUpgradedCounter: any

/**
 * GAMEMODE: campaign
 * HordeBasesConstructedCounter
 */
declare const HordeBasesConstructedCounter: any

/**
 * GAMEMODE: campaign
 * HordeBasesDestroyedCounter
 */
declare const HordeBasesDestroyedCounter: any

/**
 * GAMEMODE: campaign
 * HordeBasesUpgradedCounter
 */
declare const HordeBasesUpgradedCounter: any

/**
 * GAMEMODE: campaign
 * HordeEntry
 */
declare const HordeEntry: any

/**
 * GAMEMODE: campaign
 * HordeOutpostsDestroyedCounter
 */
declare const HordeOutpostsDestroyedCounter: any

/**
 * GAMEMODE: BASE
 * ICON_QUESTION_MARK
 */
declare const ICON_QUESTION_MARK: string

/**
 * GAMEMODE: campaign
 * INACTIVE_DAYS_VARIABLE
 */
declare const INACTIVE_DAYS_VARIABLE: string

/**
 * GAMEMODE: BASE
 * INSTANCE_BOSS_PORTAL_SPAWN_LOCATION
 */
declare const INSTANCE_BOSS_PORTAL_SPAWN_LOCATION: string

/**
 * GAMEMODE: BASE
 * INSTANCE_LARGE_PORTAL_SPAWN_LOCATION
 */
declare const INSTANCE_LARGE_PORTAL_SPAWN_LOCATION: string

/**
 * GAMEMODE: BASE
 * INSTANCE_SPREADER_SPAWN_LOCATION
 */
declare const INSTANCE_SPREADER_SPAWN_LOCATION: string

/**
 * GAMEMODE: BASE
 * INSTANT_BUILD_DECK_NAME
 */
declare const INSTANT_BUILD_DECK_NAME: string

/**
 * GAMEMODE: BASE
 * INVALID_ENTITY
 */
declare const INVALID_ENTITY: number

/**
 * GAMEMODE: BASE
 * INVASION_ACTIVE
 */
declare const INVASION_ACTIVE: string

/**
 * GAMEMODE: BASE
 * INVASION_ATTACK_RESULT_VILLAGE_VARIABLE
 */
declare const INVASION_ATTACK_RESULT_VILLAGE_VARIABLE: string

/**
 * GAMEMODE: BASE
 * INVASION_DECK_NAME
 */
declare const INVASION_DECK_NAME: string

/**
 * GAMEMODE: BASE
 * INVASION_OB_BUILT_VARIABLE
 */
declare const INVASION_OB_BUILT_VARIABLE: string

/**
 * GAMEMODE: campaign
 * INVASION_PHASE
 */
declare const INVASION_PHASE: string

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_0
 */
declare const INVASION_PHASE_0: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_1
 */
declare const INVASION_PHASE_1: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_2
 */
declare const INVASION_PHASE_2: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_3
 */
declare const INVASION_PHASE_3: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_4
 */
declare const INVASION_PHASE_4: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_5
 */
declare const INVASION_PHASE_5: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_6
 */
declare const INVASION_PHASE_6: number

/**
 * GAMEMODE: BASE
 * INVASION_PHASE_TOTAL_COUNT
 */
declare const INVASION_PHASE_TOTAL_COUNT: number

/**
 * GAMEMODE: BASE
 * INVASION_SUNRISE_COUNT
 */
declare const INVASION_SUNRISE_COUNT: string

/**
 * GAMEMODE: BASE
 * INVASION_SUNSET_COUNT
 */
declare const INVASION_SUNSET_COUNT: string

/**
 * GAMEMODE: campaign
 * InvasionActionsDayPassedCounter
 */
declare const InvasionActionsDayPassedCounter: any

/**
 * GAMEMODE: campaign
 * InvasionDaysCineCounter
 */
declare const InvasionDaysCineCounter: any

/**
 * GAMEMODE: campaign
 * InvasionDuskHUDCounter
 */
declare const InvasionDuskHUDCounter: any

/**
 * GAMEMODE: campaign
 * InvasionFlushRecapsCounter
 */
declare const InvasionFlushRecapsCounter: any

/**
 * GAMEMODE: campaign
 * InvasionHordeFirstAttackDelayDays
 */
declare const InvasionHordeFirstAttackDelayDays: any

/**
 * GAMEMODE: campaign
 * InvasionHordeFirstAttackStarted
 */
declare const InvasionHordeFirstAttackStarted: any

/**
 * GAMEMODE: campaign
 * InvasionPhaseCounter
 */
declare const InvasionPhaseCounter: any

/**
 * GAMEMODE: BASE
 * LOG_LEVEL_ERROR
 */
declare const LOG_LEVEL_ERROR: number

/**
 * GAMEMODE: BASE
 * LOG_LEVEL_INFO
 */
declare const LOG_LEVEL_INFO: number

/**
 * GAMEMODE: BASE
 * LOG_LEVEL_VERBOSE
 */
declare const LOG_LEVEL_VERBOSE: number

/**
 * GAMEMODE: BASE
 * LOG_LEVEL_WARNING
 */
declare const LOG_LEVEL_WARNING: number

/**
 * GAMEMODE: BASE
 * LOOT_DATA_BY_TYPE
 */
declare const LOOT_DATA_BY_TYPE: []

/**
 * GAMEMODE: BASE
 * MA_OCCUPATION_STARTED_FIFTH
 */
declare const MA_OCCUPATION_STARTED_FIFTH: any

/**
 * GAMEMODE: BASE
 * MA_OCCUPATION_STARTED_FIRST
 */
declare const MA_OCCUPATION_STARTED_FIRST: any

/**
 * GAMEMODE: BASE
 * MA_OCCUPATION_STARTED_FOURTH
 */
declare const MA_OCCUPATION_STARTED_FOURTH: any

/**
 * GAMEMODE: BASE
 * MA_OCCUPATION_STARTED_SECOND
 */
declare const MA_OCCUPATION_STARTED_SECOND: any

/**
 * GAMEMODE: BASE
 * MA_OCCUPATION_STARTED_SIXTH
 */
declare const MA_OCCUPATION_STARTED_SIXTH: any

/**
 * GAMEMODE: BASE
 * MA_OCCUPATION_STARTED_THIRD
 */
declare const MA_OCCUPATION_STARTED_THIRD: any

/**
 * GAMEMODE: campaign
 * MAX_ACTION_GAP
 */
declare const MAX_ACTION_GAP: number

/**
 * GAMEMODE: campaign
 * MOB_ALLIANCE_ANY
 */
declare const MOB_ALLIANCE_ANY: []

/**
 * GAMEMODE: BASE
 * MOB_ALLIANCE_NAME_CREEPER
 */
declare const MOB_ALLIANCE_NAME_CREEPER: string

/**
 * GAMEMODE: BASE
 * Faction name for the piglin village that attacks the creeper mob alliance.
 */
declare const MOB_ALLIANCE_NAME_CREEPER_PIGLINS: string

/**
 * GAMEMODE: BASE
 * MOB_ALLIANCE_NAME_SKELETON
 */
declare const MOB_ALLIANCE_NAME_SKELETON: string

/**
 * GAMEMODE: BASE
 * Faction name for the piglin village that attacks the skeleton mob alliance.
 */
declare const MOB_ALLIANCE_NAME_SKELETON_PIGLINS: string

/**
 * GAMEMODE: BASE
 * MOB_ALLIANCE_NAME_ZOMBIE
 */
declare const MOB_ALLIANCE_NAME_ZOMBIE: string

/**
 * GAMEMODE: BASE
 * Faction name for the piglin village that attacks the zombie mob alliance.
 */
declare const MOB_ALLIANCE_NAME_ZOMBIE_PIGLINS: string

/**
 * GAMEMODE: campaign
 * MobAllianceOccupation
 */
declare const MobAllianceOccupation: any

/**
 * GAMEMODE: BASE
 * MOIST_BIOMES_LIST
 */
declare const MOIST_BIOMES_LIST: []

/**
 * GAMEMODE: BASE
 * NEARBY_PLAYER_RANGE
 */
declare const NEARBY_PLAYER_RANGE: number

/**
 * GAMEMODE: campaign
 * NEAREST_HORDE
 */
declare const NEAREST_HORDE: string

/**
 * GAMEMODE: campaign
 * NEAREST_VILLAGE
 */
declare const NEAREST_VILLAGE: number

/**
 * GAMEMODE: campaign
 * NO_ACTION
 */
declare const NO_ACTION: string

/**
 * GAMEMODE: campaign
 * NO_FUNCTION
 */
declare const NO_FUNCTION: any

/**
 * GAMEMODE: campaign
 * NO_VILLAGE
 */
declare const NO_VILLAGE: number

/**
 * GAMEMODE: BASE
 * NORTH
 */
declare const NORTH: string

/**
 * GAMEMODE: BASE
 * ONBOARDING_MESSAGE_PRIORITY
 */
declare const ONBOARDING_MESSAGE_PRIORITY: number

/**
 * GAMEMODE: BASE
 * OWNER_VILLAGE_OPT_OUT
 */
declare const OWNER_VILLAGE_OPT_OUT: number

/**
 * GAMEMODE: BASE
 * PIGLIN_BASE_STINGERS
 */
declare const PIGLIN_BASE_STINGERS: []

/**
 * GAMEMODE: BASE
 * PIGLIN_PORTAL_DAMGED_VO_DEBOUNCE_TIME
 */
declare const PIGLIN_PORTAL_DAMGED_VO_DEBOUNCE_TIME: number

/**
 * GAMEMODE: pvp
 * PiglinPVPHordes
 */
declare const PiglinPVPHordes: []

/**
 * GAMEMODE: BASE
 * PLACEMENT_CLOSE_TO_VILLAGE_START
 */
declare const PLACEMENT_CLOSE_TO_VILLAGE_START: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_CLOSE_TO_DISTRICT_START
 */
declare const PLACEMENT_CLOSE_TO_DISTRICT_START: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_CLOSE_TO_WALLS
 */
declare const PLACEMENT_CLOSE_TO_WALLS: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_CONNECT_TO_PATH
 */
declare const PLACEMENT_CONNECT_TO_PATH: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_FAR_FROM_VILLAGE_START
 */
declare const PLACEMENT_FAR_FROM_VILLAGE_START: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_OUTSIDE_VILLAGE
 */
declare const PLACEMENT_OUTSIDE_VILLAGE: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_RANDOM
 */
declare const PLACEMENT_RANDOM: string

/**
 * GAMEMODE: BASE
 * PLACEMENT_WITHOUT_SPACING
 */
declare const PLACEMENT_WITHOUT_SPACING: string

/**
 * GAMEMODE: campaign
 * PLAYER_MOVE_SCENARIO_A
 */
declare const PLAYER_MOVE_SCENARIO_A: string

/**
 * GAMEMODE: campaign
 * PLAYER_MOVE_SCENARIO_B
 */
declare const PLAYER_MOVE_SCENARIO_B: string

/**
 * GAMEMODE: campaign
 * PLAYER_MOVE_SCENARIO_C
 */
declare const PLAYER_MOVE_SCENARIO_C: string

/**
 * GAMEMODE: campaign
 * PLAYER_MOVE_SCENARIO_NONE
 */
declare const PLAYER_MOVE_SCENARIO_NONE: string

/**
 * GAMEMODE: campaign
 * PlayersParticipatingInVillageAttackCounter
 */
declare const PlayersParticipatingInVillageAttackCounter: any

/**
 * GAMEMODE: BASE
 * POI_BUILD_DECK_NAME
 */
declare const POI_BUILD_DECK_NAME: string

/**
 * GAMEMODE: BASE
 * POI_CARD_LIBRARY_NAME
 */
declare const POI_CARD_LIBRARY_NAME: string

/**
 * GAMEMODE: BASE
 * POI_NAME_ALLY_01
 */
declare const POI_NAME_ALLY_01: string

/**
 * GAMEMODE: BASE
 * POI_NAME_ALLY_02
 */
declare const POI_NAME_ALLY_02: string

/**
 * GAMEMODE: BASE
 * POI_NAME_ALLY_04
 */
declare const POI_NAME_ALLY_04: string

/**
 * GAMEMODE: BASE
 * POI_NAME_ALLY_05
 */
declare const POI_NAME_ALLY_05: string

/**
 * GAMEMODE: BASE
 * POI_NAME_MOUNT_01
 */
declare const POI_NAME_MOUNT_01: string

/**
 * GAMEMODE: BASE
 * POI_NAME_MOUNT_03
 */
declare const POI_NAME_MOUNT_03: string

/**
 * GAMEMODE: BASE
 * POI_NAME_MOUNT_04
 */
declare const POI_NAME_MOUNT_04: string

/**
 * GAMEMODE: BASE
 * POI_NAME_TOWER_FREEZE
 */
declare const POI_NAME_TOWER_FREEZE: string

/**
 * GAMEMODE: BASE
 * POI_NAME_TOWER_KNOCKBACK
 */
declare const POI_NAME_TOWER_KNOCKBACK: string

/**
 * GAMEMODE: BASE
 * POI_NAME_TOWER_STUN
 */
declare const POI_NAME_TOWER_STUN: string

/**
 * GAMEMODE: BASE
 * POI_TOWER_NAME_FREEZE
 */
declare const POI_TOWER_NAME_FREEZE: string

/**
 * GAMEMODE: BASE
 * POI_TOWER_NAME_KNOCKBACK
 */
declare const POI_TOWER_NAME_KNOCKBACK: string

/**
 * GAMEMODE: BASE
 * POI_TOWER_NAME_STUN
 */
declare const POI_TOWER_NAME_STUN: string

/**
 * GAMEMODE: pvp
 * PVP_CAPTURE_BUILDABLE_ID
 */
declare const PVP_CAPTURE_BUILDABLE_ID: string

/**
 * GAMEMODE: pvp
 * PVP_CAPTURE_BUILDABLE_TAG
 */
declare const PVP_CAPTURE_BUILDABLE_TAG: string

/**
 * GAMEMODE: pvp
 * PVP_HEADQUARTERS_BLUE
 */
declare const PVP_HEADQUARTERS_BLUE: string

/**
 * GAMEMODE: pvp
 * PVP_HEADQUARTERS_RED
 */
declare const PVP_HEADQUARTERS_RED: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_ATTACK_HORDE
 */
declare const RANDOM_GROUP_ATTACK_HORDE: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_DBB_HORDE
 */
declare const RANDOM_GROUP_DBB_HORDE: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_DEFEND_HORDE
 */
declare const RANDOM_GROUP_DEFEND_HORDE: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_INVASION
 */
declare const RANDOM_GROUP_INVASION: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_MOB_OCCUPATION
 */
declare const RANDOM_GROUP_MOB_OCCUPATION: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_OBSTACLE_HORDE
 */
declare const RANDOM_GROUP_OBSTACLE_HORDE: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_VILLAGER
 */
declare const RANDOM_GROUP_VILLAGER: string

/**
 * GAMEMODE: BASE
 * RANDOM_GROUP_WOF_HORDE
 */
declare const RANDOM_GROUP_WOF_HORDE: string

/**
 * GAMEMODE: campaign
 * RESERVE_TAG
 */
declare const RESERVE_TAG: string

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 * ResourcesConfig
 */
declare const ResourcesConfig: []

/**
 * GAMEMODE: BASE
 * SKY_STATE_ALL
 */
declare const SKY_STATE_ALL: []

/**
 * GAMEMODE: BASE
 * SKY_STATE_DARK_SUN
 */
declare const SKY_STATE_DARK_SUN: string

/**
 * GAMEMODE: BASE
 * SKY_STATE_SUN_MOON
 */
declare const SKY_STATE_SUN_MOON: string

/**
 * GAMEMODE: BASE
 * SKY_STATE_TWO_SUNS
 */
declare const SKY_STATE_TWO_SUNS: string

/**
 * GAMEMODE: BASE
 * SKY_STATE_WELL_OF_FATE
 */
declare const SKY_STATE_WELL_OF_FATE: string

/**
 * GAMEMODE: BASE
 * SKY_STATE_WOF_BATTLE
 */
declare const SKY_STATE_WOF_BATTLE: string

/**
 * GAMEMODE: BASE
 * SLICE_SUFFIX
 */
declare const SLICE_SUFFIX: string

/**
 * GAMEMODE: campaign
 * SNAPSHOT_NOT_SET
 */
declare const SNAPSHOT_NOT_SET: number

/**
 * GAMEMODE: BASE
 * SOUTH
 */
declare const SOUTH: string

/**
 * GAMEMODE: BASE
 * SPAWNER_NO_CAP
 */
declare const SPAWNER_NO_CAP: number

/**
 * GAMEMODE: campaign
 * StaggeredEntryCounter
 */
declare const StaggeredEntryCounter: any

/**
 * GAMEMODE: campaign
 * StaggeredEntryHordePhaseCounter
 */
declare const StaggeredEntryHordePhaseCounter: any

/**
 * GAMEMODE: campaign
 * StaggeredMobAllianceOccupationCounter
 */
declare const StaggeredMobAllianceOccupationCounter: any

/**
 * GAMEMODE: BASE
 * STAMP_TEXTURES
 */
declare const STAMP_TEXTURES: []

/**
 * GAMEMODE: BASE
 * TAG_BARRACKS
 */
declare const TAG_BARRACKS: string

/**
 * GAMEMODE: BASE
 * TAG_BOSS_VILLAGE
 */
declare const TAG_BOSS_VILLAGE: string

/**
 * GAMEMODE: BASE
 * TAG_BUILDABLE
 */
declare const TAG_BUILDABLE: string

/**
 * GAMEMODE: pvp
 * TAG_BUILDABLE_BUILDING
 */
declare const TAG_BUILDABLE_BUILDING: string

/**
 * GAMEMODE: BASE
 * TAG_DISABLED
 */
declare const TAG_DISABLED: string

/**
 * GAMEMODE: BASE
 * TAG_DO_NOT_ATTACK
 */
declare const TAG_DO_NOT_ATTACK: string

/**
 * GAMEMODE: BASE
 * TAG_HAMMER_BOSS
 */
declare const TAG_HAMMER_BOSS: string

/**
 * GAMEMODE: BASE
 * TAG_HOUSE
 */
declare const TAG_HOUSE: string

/**
 * GAMEMODE: BASE
 * TAG_HQ
 */
declare const TAG_HQ: string

/**
 * GAMEMODE: BASE
 * TAG_INACTIVE_VILLAGE
 */
declare const TAG_INACTIVE_VILLAGE: string

/**
 * GAMEMODE: BASE
 * TAG_MOB
 */
declare const TAG_MOB: string

/**
 * GAMEMODE: BASE
 * TAG_MOB_ALLEGIANCE_STRUCTURE
 */
declare const TAG_MOB_ALLEGIANCE_STRUCTURE: string

/**
 * GAMEMODE: BASE
 * TAG_MOB_ALLIANCE_ALLIED
 */
declare const TAG_MOB_ALLIANCE_ALLIED: string

/**
 * GAMEMODE: BASE
 * TAG_OUTPOST_STRUCTURE
 */
declare const TAG_OUTPOST_STRUCTURE: string

/**
 * GAMEMODE: BASE
 * TAG_PLAYER
 */
declare const TAG_PLAYER: string

/**
 * GAMEMODE: BASE
 * TAG_PORTAL_OB
 */
declare const TAG_PORTAL_OB: string

/**
 * GAMEMODE: BASE
 * TAG_PORTAL_PIGLIN
 */
declare const TAG_PORTAL_PIGLIN: string

/**
 * GAMEMODE: pvp
 * TAG_PVP_HQ
 */
declare const TAG_PVP_HQ: string

/**
 * GAMEMODE: BASE
 * TAG_REVEALED_POI
 */
declare const TAG_REVEALED_POI: string

/**
 * GAMEMODE: BASE
 * TAG_ROAMING
 */
declare const TAG_ROAMING: string

/**
 * GAMEMODE: BASE
 * TAG_VILLAGE_FOUNTAIN
 */
declare const TAG_VILLAGE_FOUNTAIN: string

/**
 * GAMEMODE: BASE
 * TAG_VISITED_VILLAGE
 */
declare const TAG_VISITED_VILLAGE: string

/**
 * GAMEMODE: BASE
 * TAG_WELL_OF_FATE
 */
declare const TAG_WELL_OF_FATE: string

/**
 * GAMEMODE: BASE
 * TAGS_AI_CONTROL_GROUPS
 */
declare const TAGS_AI_CONTROL_GROUPS: []

/**
 * GAMEMODE: BASE
 * TAGS_PIGLIN_MOB
 */
declare const TAGS_PIGLIN_MOB: []

/**
 * GAMEMODE: BASE
 * TAGS_PIGLIN_PROJECTILE_SPAWN
 */
declare const TAGS_PIGLIN_PROJECTILE_SPAWN: []

/**
 * GAMEMODE: BASE
 * TAGSET_PLAYER
 */
declare const TAGSET_PLAYER: []

/**
 * GAMEMODE: BASE
 * TAGSET_PLAYER_BRIDGE
 */
declare const TAGSET_PLAYER_BRIDGE: []

/**
 * GAMEMODE: BASE
 * TAGSET_PLAYER_MOB_OR_SPAWNER
 */
declare const TAGSET_PLAYER_MOB_OR_SPAWNER: []

/**
 * GAMEMODE: BASE
 * TAGSET_PLAYER_OR_MOB
 */
declare const TAGSET_PLAYER_OR_MOB: []

/**
 * GAMEMODE: BASE
 * TEAM_BLUE
 */
declare const TEAM_BLUE: string

/**
 * GAMEMODE: BASE
 * TEAM_MOB_ALLIANCE
 */
declare const TEAM_MOB_ALLIANCE: string

/**
 * GAMEMODE: BASE
 * TEAM_NONE
 */
declare const TEAM_NONE: string

/**
 * GAMEMODE: BASE
 * TEAM_ORANGE
 */
declare const TEAM_ORANGE: string

/**
 * GAMEMODE: BASE
 * TEAM_RED
 */
declare const TEAM_RED: string

/**
 * GAMEMODE: BASE
 * TEAM_WILD
 */
declare const TEAM_WILD: string

/**
 * GAMEMODE: campaign
 * TelemetryInvasionBreakDaysPassedCounter
 */
declare const TelemetryInvasionBreakDaysPassedCounter: any

/**
 * GAMEMODE: BASE
 * TEST_TARGET_HORDE_VAR
 */
declare const TEST_TARGET_HORDE_VAR: string

/**
 * GAMEMODE: BASE
 * TICKET_BUILD
 */
declare const TICKET_BUILD: string

/**
 * GAMEMODE: BASE
 * TICKET_BUILD_DECK_NAME
 */
declare const TICKET_BUILD_DECK_NAME: string

/**
 * GAMEMODE: BASE
 * TICKET_GATHER
 */
declare const TICKET_GATHER: string

/**
 * GAMEMODE: BASE
 * TICKET_SPAWN
 */
declare const TICKET_SPAWN: string

/**
 * GAMEMODE: BASE
 * TIME_BETWEEN_BASE_SPAWN
 */
declare const TIME_BETWEEN_BASE_SPAWN: number

/**
 * GAMEMODE: BASE
 * TIME_DAWN
 */
declare const TIME_DAWN: number

/**
 * GAMEMODE: BASE
 * TIME_DUSK
 */
declare const TIME_DUSK: number

/**
 * GAMEMODE: BASE
 * TIME_INVASION_RESOLUTION
 */
declare const TIME_INVASION_RESOLUTION: number

/**
 * GAMEMODE: BASE
 * TIME_LANDMARKS
 */
declare const TIME_LANDMARKS: []

/**
 * GAMEMODE: BASE
 * TIME_MIDNIGHT
 */
declare const TIME_MIDNIGHT: number

/**
 * GAMEMODE: BASE
 * TIME_NOON
 */
declare const TIME_NOON: number

/**
 * GAMEMODE: BASE
 * TIME_ONBOARDING_FIRST_SLOT
 */
declare const TIME_ONBOARDING_FIRST_SLOT: number

/**
 * GAMEMODE: BASE
 * TIME_ONBOARDING_FOURTH_SLOT
 */
declare const TIME_ONBOARDING_FOURTH_SLOT: number

/**
 * GAMEMODE: BASE
 * TIME_ONBOARDING_SECOND_SLOT
 */
declare const TIME_ONBOARDING_SECOND_SLOT: number

/**
 * GAMEMODE: BASE
 * TIME_ONBOARDING_THIRD_SLOT
 */
declare const TIME_ONBOARDING_THIRD_SLOT: number

/**
 * GAMEMODE: campaign
 * TRIGGER_TIME_AT_VILLAGE
 */
declare const TRIGGER_TIME_AT_VILLAGE: string

/**
 * GAMEMODE: campaign
 * TRIGGER_TIME_DAWN
 */
declare const TRIGGER_TIME_DAWN: string

/**
 * GAMEMODE: campaign
 * TRIGGER_TIME_DUSK
 */
declare const TRIGGER_TIME_DUSK: string

/**
 * GAMEMODE: campaign
 * TRIGGER_TIME_IMMEDIATE
 */
declare const TRIGGER_TIME_IMMEDIATE: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VARIATION_BEHAVIOUR_DEFAULT
 */
declare const VARIATION_BEHAVIOUR_DEFAULT: number

/**
 * GAMEMODE: Demo_MinecraftLive
 * VARIATION_BEHAVIOUR_OVERRIDE
 */
declare const VARIATION_BEHAVIOUR_OVERRIDE: number

/**
 * GAMEMODE: BASE
 * VARIATION_DECK_LIBRARY_NAME
 */
declare const VARIATION_DECK_LIBRARY_NAME: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VARIATION_ID_FLAVOUR
 */
declare const VARIATION_ID_FLAVOUR: number

/**
 * GAMEMODE: Demo_MinecraftLive
 * VARIATION_ID_OBJECTIVE
 */
declare const VARIATION_ID_OBJECTIVE: number

/**
 * GAMEMODE: campaign
 * VictoriesOverPiglinsCounter
 */
declare const VictoriesOverPiglinsCounter: any

/**
 * GAMEMODE: BASE
 * VILLAGE_BEHAVIOR_TIMER
 */
declare const VILLAGE_BEHAVIOR_TIMER: string

/**
 * GAMEMODE: BASE
 * VILLAGE_SIZE_DEBUG
 */
declare const VILLAGE_SIZE_DEBUG: string

/**
 * GAMEMODE: BASE
 * VILLAGE_SIZE_DEFAULT
 */
declare const VILLAGE_SIZE_DEFAULT: string

/**
 * GAMEMODE: BASE
 * VILLAGE_SIZE_PLAYER
 */
declare const VILLAGE_SIZE_PLAYER: string

/**
 * GAMEMODE: BASE
 * VILLAGE_TIMER_REESCALATION
 */
declare const VILLAGE_TIMER_REESCALATION: string

/**
 * GAMEMODE: BASE
 * VILLAGE_VARIABLE_TEMP_BEHAVIOR_STATE
 */
declare const VILLAGE_VARIABLE_TEMP_BEHAVIOR_STATE: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_A
 */
declare const VILLAGE_VARIATION_A: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_B
 */
declare const VILLAGE_VARIATION_B: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_C
 */
declare const VILLAGE_VARIATION_C: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_D
 */
declare const VILLAGE_VARIATION_D: string


/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_CAPTURE_POINT
 */
declare const VILLAGE_VARIATION_CAPTURE_POINT: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_DEFAULT
 */
declare const VILLAGE_VARIATION_DEFAULT: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_GOLDRUSH
 */
declare const VILLAGE_VARIATION_GOLDRUSH: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_OBJECTIVE_DEFAULT
 */
declare const VILLAGE_VARIATION_OBJECTIVE_DEFAULT: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_RAIDING_PARTY
 */
declare const VILLAGE_VARIATION_RAIDING_PARTY: string

/**
 * GAMEMODE: Demo_MinecraftLive
 * VILLAGE_VARIATION_STRUCTURE_DESTRUCTION
 */
declare const VILLAGE_VARIATION_STRUCTURE_DESTRUCTION: string

/**
 * GAMEMODE: BASE
 * VILLAGE_WITH_CARRIER_GOLEM_PIECE_TAG
 */
declare const VILLAGE_WITH_CARRIER_GOLEM_PIECE_TAG: string

/**
 * GAMEMODE: campaign
 * VillageAttacksDefendedCounter
 */
declare const VillageAttacksDefendedCounter: any

/**
 * GAMEMODE: campaign
 * VillageAttacksFoughtCounter
 */
declare const VillageAttacksFoughtCounter: any

/**
 * GAMEMODE: campaign
 * VillageAttacksResolvedCounter
 */
declare const VillageAttacksResolvedCounter: any

/**
 * GAMEMODE: campaign
 * VillageDaysSincePlayerDamage
 */
declare const VillageDaysSincePlayerDamage: any

/**
 * GAMEMODE: campaign
 * VillageNotUnderAttackEnteredCounter
 */
declare const VillageNotUnderAttackEnteredCounter: any

/**
 * GAMEMODE: campaign
 * VillageNotUnderAttackExitedCounter
 */
declare const VillageNotUnderAttackExitedCounter: any

/**
 * GAMEMODE: BASE
 * VILLAGERS_ILLAGERS_INSIDE_CAGE_TAG
 */
declare const VILLAGERS_ILLAGERS_INSIDE_CAGE_TAG: string

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 * WavesConfig
 */
declare const WavesConfig: []

/**
 * GAMEMODE: BASE
 * WELL_OF_FATE
 */
declare const WELL_OF_FATE: string

/**
 * GAMEMODE: BASE
 * WEST
 */
declare const WEST: string


// FILE CONTENTS: bsharp_api_dictionaries.gen.d.ts


/**
 * GAMEMODE: BASE
 * A list of all the campaign acts.
 */
declare interface ACTS {
    /**
     * ACT_1A
     */
    ACT_1A: string
    /**
     * ACT_1B
     */
    ACT_1B: any
    /**
     * ACT_2
     */
    ACT_2: any
    /**
     * ACT_3A
     */
    ACT_3A: any
    /**
     * ACT_3B
     */
    ACT_3B: any
    /**
     * EPILOGUE
     */
    EPILOGUE: any
}

/**
 * GAMEMODE: BASE
 * Tags to manage piglins using AI responses
 */
declare interface AI_TAG {
    /**
     * EXEMPT
     */
    EXEMPT: string
    /**
     * ASSIGNED
     */
    ASSIGNED: string
}

/**
 * GAMEMODE: campaign
 
 */
declare interface AllyBarracksConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * darkBeacon
     */
    darkBeacon: any
}

/**
 * GAMEMODE: campaign
 * AllyBarracksCreeperConfig_DBBFaction
 */
declare interface AllyBarracksCreeperConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * darkBeacon
     */
    darkBeacon: any
}

/**
 * GAMEMODE: campaign
 * AllyBarracksSkeletonConfig_DBBFaction
 */
declare interface AllyBarracksSkeletonConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * darkBeacon
     */
    darkBeacon: any
}

/**
 * GAMEMODE: campaign
 * AllyBarracksZombieConfig_DBBFaction
 */
declare interface AllyBarracksZombieConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * darkBeacon
     */
    darkBeacon: any
}

/**
 * GAMEMODE: BASE
 * AUDIO_VAR_KEY
 */
declare interface AUDIO_VAR_KEY {
    /**
     * ACT
     */
    ACT: string
}

/**
 * GAMEMODE: BASE
 * AUDIO_VAR_VALUE
 */
declare interface AUDIO_VAR_VALUE {
    /**
     * ACT
     */
    ACT: any
}
/**
 * GAMEMODE: campaign
 * Custom game opitons global consts
 */
declare interface CUSTOM_OPTIONS {
    /**
     * global variable
     */
    SKIP_ACT_1: string
}
/**
 * GAMEMODE: campaign
 *
 */
declare interface BaseToBaseMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface BaseToMobAlliancesMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface BaseToOtherVillagesMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 * Minimum spawn distance from a base to outpost.
 */
declare interface BaseToOutpostMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface BaseToVillagerVillagesMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 * Values relating to boss bases.
 */
declare interface BOSS_BASE_VALS {
    /**
     * globals
     */
    globals: any
    /**
     * commonVO
     */
    commonVO: any
    /**
     * minDistanceFromPlayers
     */
    minDistanceFromPlayers: number
    /**
     * maxDistanceFromPlayers
     */
    maxDistanceFromPlayers: number
    /**
     * factionObjects
     */
    factionObjects: []
    /**
     * basesDestroyedForBossIsMad
     */
    basesDestroyedForBossIsMad: number
    /**
     * basesRemainingForBossIsMad
     */
    basesRemainingForBossIsMad: number
}

/**
 * GAMEMODE: BASE
 * Contains interfaceant values for use with BSharpPlacement functions
 */
declare interface BSHARP_PLACEMENT {
    /**
     * Indicates that all provided entities to a rule should satisfy the rule in order to be successful.
     */
    requireAll: number
    /**
     * Indicates that a proximity rule's max distance should be bounded only by the size of the world.
     */
    maxDistance: number
}

/**
 * GAMEMODE: BASE
 * Contains strings for buildable cards defined in costs_piglin.json
 */
declare interface BUILDABLE_CARD {
    /**
     * PORTAL_ACT1
     */
    PORTAL_ACT1: string
    /**
     * PORTAL_DARK_BEACON
     */
    PORTAL_DARK_BEACON: string
    /**
     * PORTAL_SMALL
     */
    PORTAL_SMALL: string
    /**
     * PORTAL_MEDIUM
     */
    PORTAL_MEDIUM: string
    /**
     * PORTAL_LARGE
     */
    PORTAL_LARGE: string
    /**
     * PORTAL_MINI
     */
    PORTAL_MINI: string
    /**
     * SUPER_GOLDMINE
     */
    SUPER_GOLDMINE: string
    /**
     * PIGLIN_CRYSTAL
     */
    PIGLIN_CRYSTAL: string
    /**
     * TOWER_PIGLIN_ARROW
     */
    TOWER_PIGLIN_ARROW: string
    /**
     * TOWER_PIGLIN_KNOCKBACK
     */
    TOWER_PIGLIN_KNOCKBACK: string
    /**
     * TOWER_PIGLIN_THROWER_RUNT
     */
    TOWER_PIGLIN_THROWER_RUNT: string
    /**
     * TOWER_PIGLIN_THROWER_WARBOAR
     */
    TOWER_PIGLIN_THROWER_WARBOAR: string
    /**
     * TOWER_PIGLIN_THROWER_PIGMADILO
     */
    TOWER_PIGLIN_THROWER_PIGMADILO: string
    /**
     * TOWER_LAVA_SPREADER
     */
    TOWER_LAVA_SPREADER: string
    /**
     * TOWER_PIGLIN_SHIELD
     */
    TOWER_PIGLIN_SHIELD: string
    /**
     * BARRACKS_FIGHTER
     */
    BARRACKS_FIGHTER: string
    /**
     * BARRACKS_DISRUPTOR
     */
    BARRACKS_DISRUPTOR: string
    /**
     * BARRACKS_SIEGER
     */
    BARRACKS_SIEGER: string
    /**
     * BARRACKS_SPECIALIST
     */
    BARRACKS_SPECIALIST: string
    /**
     * NETHERSPREADER
     */
    NETHERSPREADER: string
    /**
     * NETHERSPREADER_SUPER_FEAR
     */
    NETHERSPREADER_SUPER_FEAR: string
    /**
     * NETHERSPREADER_INSTANT
     */
    NETHERSPREADER_INSTANT: string
    /**
     * GOLDMINE
     */
    GOLDMINE: string
    /**
     * PIGLIN_CRATE
     */
    PIGLIN_CRATE: string
    /**
     * RANGE_EXTENDER
     */
    RANGE_EXTENDER: string
    /**
     * BUILDING_REGENERATOR
     */
    BUILDING_REGENERATOR: string
    /**
     * RALLYPOINT
     */
    RALLYPOINT: string
    /**
     * ATTACK_HORDE_RALLY_POINT
     */
    ATTACK_HORDE_RALLY_POINT: string
    /**
     * DEFEND_HORDE_RALLY_POINT
     */
    DEFEND_HORDE_RALLY_POINT: string
    /**
     * MOB_CAGE
     */
    MOB_CAGE: string
}

/**
 * GAMEMODE: BASE
 * Building tags
 */
declare interface BUILDING_TAG {
    /**
     * RALLYPOINT
     */
    RALLYPOINT: string
}

/**
 * GAMEMODE: BASE
 * Names of all the celebrations
 */
declare interface CELEBRATION_NAMES {
    /**
     * ALLAY_DANCE_SMALL
     */
    ALLAY_DANCE_SMALL: string
    /**
     * ALLAY_DANCE_MEDIUM
     */
    ALLAY_DANCE_MEDIUM: string
    /**
     * ALLAY_DANCE_LARGE
     */
    ALLAY_DANCE_LARGE: string
    /**
     * MOBS
     */
    MOBS: string
    /**
     * CAGED_MOBS
     */
    CAGED_MOBS: string
    /**
     * VILLAGER
     */
    VILLAGER: string
    /**
     * HOSTS
     */
    HOSTS: string
    /**
     * PORTAL_DESTROYED_GOLEM_SUPPORT
     */
    PORTAL_DESTROYED_GOLEM_SUPPORT: string
    /**
     * MOB_ALLIANCE_COMPLETE
     */
    MOB_ALLIANCE_COMPLETE: string
    /**
     * PLAYER_DANCE
     */
    PLAYER_DANCE: string
}

/**
 * GAMEMODE: BASE
 * An object containing all the celebrations details.
 */
declare interface CELEBRATIONS {

}

/**
 * GAMEMODE: campaign
 * Claimed area sizes for the defend horde.
 */
declare interface CLAIMED_AREAS_DEF {

}

/**
 * GAMEMODE: BASE
 *
 */
declare interface DEFEND_DEFEND_AI {
    /**
     * TAG
     */
    TAG: string
    /**
     * RALLY_POINT
     */
    RALLY_POINT: string
    /**
     * CG_0
     */
    CG_0: string
    /**
     * CG_1
     */
    CG_1: string
}

/**
 * GAMEMODE: BASE
 *
 */
declare interface DEFEND_SIEGE_AI {
    /**
     * TAG
     */
    TAG: string
    /**
     * RALLY_POINT
     */
    RALLY_POINT: string
    /**
     * CG_0
     */
    CG_0: string
    /**
     * CG_1
     */
    CG_1: string
}

/**
 * GAMEMODE: BASE
 *
 */
declare interface DEFEND_UNIQUE_AI {
    /**
     * TAG
     */
    TAG: string
    /**
     * RALLY_POINT
     */
    RALLY_POINT: string
    /**
     * CG_0
     */
    CG_0: string
    /**
     * CG_1
     */
    CG_1: string
}

/**
 * GAMEMODE: Demo_MinecraftLive
 *
 */
declare interface DemoConfig {
    /**
     * extraRunts
     */
    extraRunts: number
    /**
     * extraGrunters
     */
    extraGrunters: number
    /**
     * extraGrenadiers
     */
    extraGrenadiers: number
    /**
     * extraLavaLaunchers
     */
    extraLavaLaunchers: number
}

/**
 * GAMEMODE: Demo_MinecraftLive
 *
 */
declare interface DemoWorldGenDefinition {
    /**
     * base
     */
    base: any
    /**
     * modify
     */
    modify: any
}

/**
 * GAMEMODE: BASE
 * Contains strings for direction filter cards defined in costs_placement_preferences.json
 */
declare interface DIRECTION_CARD {
    /**
     * none
     */
    none: string
    /**
     * northWedge
     */
    northWedge: string
    /**
     * eastWedge
     */
    eastWedge: string
    /**
     * southWedge
     */
    southWedge: string
    /**
     * westWedge
     */
    westWedge: string
    /**
     * northWestWedge
     */
    northWestWedge: string
    /**
     * northEastWedge
     */
    northEastWedge: string
    /**
     * southWestWedge
     */
    southWestWedge: string
    /**
     * southEastWedge
     */
    southEastWedge: string
    /**
     * northRect
     */
    northRect: string
    /**
     * eastRect
     */
    eastRect: string
    /**
     * southRect
     */
    southRect: string
    /**
     * westRect
     */
    westRect: string
    /**
     * northWestRect
     */
    northWestRect: string
    /**
     * northEastRect
     */
    northEastRect: string
    /**
     * southWestRect
     */
    southWestRect: string
    /**
     * southEastRect
     */
    southEastRect: string
}

/**
 * GAMEMODE: campaign
 * Attack faction disruptor barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface DisruptorBarracksConfig_AttackFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * frontlineA
     */
    frontlineA: any
}

/**
 * GAMEMODE: campaign
 * Attack faction disruptor barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface DisruptorBarracksConfig_AttackFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * DisruptorBarracksConfig_DBBFaction
 */
declare interface DisruptorBarracksConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * act1_a
     */
    act1_a: any
    /**
     * act1_b
     */
    act1_b: any
    /**
     * act1_c
     */
    act1_c: any
    /**
     * piglin_act1_non_portal_attack_base
     */
    piglin_act1_non_portal_attack_base: any
    /**
     * darkBeacon
     */
    darkBeacon: any
}

/**
 * GAMEMODE: Demo_Gamescom
 * Defend faction disruptor barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface DisruptorBarracksConfig_DefendFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
}

/**
 * GAMEMODE: campaign
 * Obstacle faction disruptor barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface DisruptorBarracksConfig_ObstacleFaction {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
}

/**
 * GAMEMODE: campaign
 * Obstacle faction disruptor barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface DisruptorBarracksConfig_ObstacleFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * DisruptorBarracksConfig_WOFFaction
 */
declare interface DisruptorBarracksConfig_WOFFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
}

/**
 * GAMEMODE: Demo_Gamescom
 * Defend faction engineer barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface EngineerBarracksConfig_DefendFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
}

/**
 * GAMEMODE: campaign
 *
 */
declare interface FactionBaseElevationRestrictions {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface FactionBiomePreferences {

}

/**
 * GAMEMODE: campaign
 * Attack faction fighter barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface FighterBarracksConfig_AttackFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * frontlineA
     */
    frontlineA: any
}

/**
 * GAMEMODE: campaign
 * Attack faction fighter barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface FighterBarracksConfig_AttackFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * FighterBarracksConfig_DBBFaction
 */
declare interface FighterBarracksConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * act1_a
     */
    act1_a: any
    /**
     * act1_b
     */
    act1_b: any
    /**
     * act1_c
     */
    act1_c: any
    /**
     * darkBeacon
     */
    darkBeacon: any
    /**
     * piglin_act1_first_skirmish
     */
    piglin_act1_first_skirmish: any
    /**
     * piglin_act1_second_skirmish
     */
    piglin_act1_second_skirmish: any
    /**
     * large
     */
    large: any
    /**
     * piglin_act1_non_portal_attack_base
     */
    piglin_act1_non_portal_attack_base: any
}

/**
 * GAMEMODE: campaign
 * Defend faction fighter barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface FighterBarracksConfig_DefendFaction {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
}

/**
 * GAMEMODE: Demo_Gamescom
 * Defend faction fighter barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface FighterBarracksConfig_DefendFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * Obstacle faction fighter barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface FighterBarracksConfig_ObstacleFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * FighterBarracksConfig_WOFFaction
 */
declare interface FighterBarracksConfig_WOFFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
}

/**
 * GAMEMODE: BASE
 * Telemetry funnel steps
 */
declare interface FunnelSteps {
    /**
     * TUTORIAL_START
     */
    TUTORIAL_START: any
    /**
     * TUTORIAL_GATHERWOOD
     */
    TUTORIAL_GATHERWOOD: any
    /**
     * TUTORIAL_GATHERSTONE
     */
    TUTORIAL_GATHERSTONE: any
    /**
     * TUTORIAL_BUILDSTAIRS
     */
    TUTORIAL_BUILDSTAIRS: any
    /**
     * TUTORIAL_OBJECTIVEREACHED
     */
    TUTORIAL_OBJECTIVEREACHED: any
    /**
     * TUTORIAL_OPENCHEST
     */
    TUTORIAL_OPENCHEST: any
    /**
     * TUTORIAL_BUILDSPAWNER
     */
    TUTORIAL_BUILDSPAWNER: any
    /**
     * TUTORIAL_SPAWNGOLEM
     */
    TUTORIAL_SPAWNGOLEM: any
    /**
     * TUTORIAL_RALLYGOLEMTOOBJECTIVE
     */
    TUTORIAL_RALLYGOLEMTOOBJECTIVE: any
    /**
     * TUTORIAL_STOPRALLYING
     */
    TUTORIAL_STOPRALLYING: any
    /**
     * TUTORIAL_DIRECTGOLEMTOOBJECTIVE
     */
    TUTORIAL_DIRECTGOLEMTOOBJECTIVE: any
    /**
     * TUTORIAL_DESTROYENEMYSPAWNERS
     */
    TUTORIAL_DESTROYENEMYSPAWNERS: any
    /**
     * TUTORIAL_COMPLETE
     */
    TUTORIAL_COMPLETE: any
    /**
     * ACT1_START
     */
    ACT1_START: any
    /**
     * ACT1_VILLAGE1ARRIVE
     */
    ACT1_VILLAGE1ARRIVE: any
    /**
     * ACT1_VILLAGE1SAVED
     */
    ACT1_VILLAGE1SAVED: any
    /**
     * ACT1_VILLAGE1CARPENTER
     */
    ACT1_VILLAGE1CARPENTER: any
    /**
     * ACT1_VILLAGE2ARRIVE
     */
    ACT1_VILLAGE2ARRIVE: any
    /**
     * ACT1_VILLAGE2PIGLINSDEFEATED
     */
    ACT1_VILLAGE2PIGLINSDEFEATED: any
    /**
     * ACT1_VILLAGE2OPENCHEST
     */
    ACT1_VILLAGE2OPENCHEST: any
    /**
     * ACT1_VILLAGE2CARPENTER
     */
    ACT1_VILLAGE2CARPENTER: any
    /**
     * ACT1_VILLAGE2PIGLINBARRACKSDESTROYED
     */
    ACT1_VILLAGE2PIGLINBARRACKSDESTROYED: any
    /**
     * ACT1_PIGLINCAMPDESTROYED1
     */
    ACT1_PIGLINCAMPDESTROYED1: any
    /**
     * ACT1_PIGLINCAMPDESTROYED2
     */
    ACT1_PIGLINCAMPDESTROYED2: any
    /**
     * ACT1_PIGLINCAMPDESTROYED3
     */
    ACT1_PIGLINCAMPDESTROYED3: any
    /**
     * ACT1_ARRIVEWELLOFFATE
     */
    ACT1_ARRIVEWELLOFFATE: any
    /**
     * ACT1_UPGRADEWELLOFFATE
     */
    ACT1_UPGRADEWELLOFFATE: any
    /**
     * ACT1_VILLAGE3ARRIVE
     */
    ACT1_VILLAGE3ARRIVE: any
    /**
     * ACT1_VILLAGE3PIGLINCORESTRUCTUREDAMAGED
     */
    ACT1_VILLAGE3PIGLINCORESTRUCTUREDAMAGED: any
    /**
     * ACT1_VILLAGE3PIGLINCORESTRUCTURESDESTROYED1
     */
    ACT1_VILLAGE3PIGLINCORESTRUCTURESDESTROYED1: any
    /**
     * ACT1_VILLAGE3PIGLINCORESTRUCTURESDESTROYED2
     */
    ACT1_VILLAGE3PIGLINCORESTRUCTURESDESTROYED2: any
    /**
     * ACT1_VILLAGE3PIGLINCORESTRUCTURESDESTROYED3
     */
    ACT1_VILLAGE3PIGLINCORESTRUCTURESDESTROYED3: any
    /**
     * ACT1_VILLAGE3SAVED
     */
    ACT1_VILLAGE3SAVED: any
    /**
     * ACT1_ARRIVEDBB
     */
    ACT1_ARRIVEDBB: any
    /**
     * ACT1_PORTALDAMAGEDDBB
     */
    ACT1_PORTALDAMAGEDDBB: any
    /**
     * ACT1_PORTAL90PERCENTDBB
     */
    ACT1_PORTAL90PERCENTDBB: any
    /**
     * ACT1_PORTAL75PERCENTDBB
     */
    ACT1_PORTAL75PERCENTDBB: any
    /**
     * ACT1_PORTAL50PERCENTDBB
     */
    ACT1_PORTAL50PERCENTDBB: any
    /**
     * ACT1_PORTAL25PERCENTDBB
     */
    ACT1_PORTAL25PERCENTDBB: any
    /**
     * ACT1_COMPLETE
     */
    ACT1_COMPLETE: any
}

/**
 * GAMEMODE: BASE
 * Dictionary for game difficulty setting names.
 */
declare interface GAME_DIFFICULTY {
    /**
     * peaceful
     */
    peaceful: string
    /**
     * easy
     */
    easy: string
    /**
     * normal
     */
    normal: string
    /**
     * hard
     */
    hard: string
}

/**
 * GAMEMODE: BASE
 * Dictionary containing the global variable names for tracking ongoing game mode state.
 */
declare interface GAME_MODE_GLOBAL {
    /**
     * Has the match started. (true/false flag variable)
     */
    matchStarted: string
    /**
     * Has the match ended. (true/false flag variable)
     */
    matchEnded: string
}

/**
 * GAMEMODE: BASE
 * The game rule for the map system
 */
declare interface GAME_RULE {
    /**
     * PVP
     */
    PVP: string
}

/**
 * GAMEMODE: BASE
 * Dictionary containing the global variable names for game rule values.
 */
declare interface GAME_RULE_NAMES {
    /**
     * How many teams are present in the game mode.
     */
    teamCount: string
    /**
     * Should BSharp automatically place HQs for teams that don't have one after some time since game start?
     */
    autoPlaceHqsOnTimer: string
    /**
     * Flag to indicate if we start the match when all teams have an HQ.
     */
    matchStartHQsBuilt: string
    /**
     * Flag to indicate if we end the match when only one HQ remains.
     */
    matchEndHQsLastStanding: string
    /**
     * Flag to indicate if campaign acts should be active.
     */
    campaignActsEnabled: string
    /**
     * campaignBasesEnabled
     */
    campaignBasesEnabled: string
    /**
     * Flag to indicate if invasion should be active.
     */
    invasionEnabled: string
    /**
     * campaignOnboardingEnabled
     */
    campaignOnboardingEnabled: string
    /**
     * GAME_MODE
     */
    GAME_MODE: string
}

/**
 * GAMEMODE: BASE
 * Global Onboarding Message Variables
 */
declare interface GlobalOnboardingVal {
    /**
     * isCampaignOnboardingMessageUp
     */
    isCampaignOnboardingMessageUp: string
    /**
     * isBasicsOnboardingMessageUp
     */
    isBasicsOnboardingMessageUp: string
}

/**
 * GAMEMODE: pvp
 *
 */
declare interface GRUDGE_STATE {
    /**
     * NONE
     */
    NONE: number
    /**
     * PLANNING
     */
    PLANNING: number
}

/**
 * GAMEMODE: BASE
 * All the roaming piglin spawners global variables
 */
declare interface GV_ROAMING_PIGLIN_SPAWNERS_CONTROL {
    /**
     * PACK_GRUNTER
     */
    PACK_GRUNTER: string
    /**
     * PACK_GRUNTER_DAY_NETHER
     */
    PACK_GRUNTER_DAY_NETHER: string
    /**
     * PACK_MEDIC
     */
    PACK_MEDIC: string
    /**
     * PACK_RUNT
     */
    PACK_RUNT: string
    /**
     * PACK_RUNT_DAY_NETHER
     */
    PACK_RUNT_DAY_NETHER: string
    /**
     * PACK_WARBOAR
     */
    PACK_WARBOAR: string
    /**
     * PACK_WARBOAR_DAY_NETHER
     */
    PACK_WARBOAR_DAY_NETHER: string
    /**
     * GROUP_BRUISER
     */
    GROUP_BRUISER: string
    /**
     * GROUP_BRUISER_DAY_NETHER
     */
    GROUP_BRUISER_DAY_NETHER: string
    /**
     * GROUP_GRENADIER
     */
    GROUP_GRENADIER: string
    /**
     * GROUP_GRENADIER_DAY_NETHER
     */
    GROUP_GRENADIER_DAY_NETHER: string
    /**
     * GROUP_SEEKER
     */
    GROUP_SEEKER: string
    /**
     * GROUP_SEEKER_DAY_NETHER
     */
    GROUP_SEEKER_DAY_NETHER: string
    /**
     * ARMY_WARBOAR
     */
    ARMY_WARBOAR: string
    /**
     * ARMY_WARBOAR_DAY_NETHER
     */
    ARMY_WARBOAR_DAY_NETHER: string
    /**
     * ARMY_RUNT
     */
    ARMY_RUNT: string
    /**
     * ARMY_RUNT_DAY_NETHER
     */
    ARMY_RUNT_DAY_NETHER: string
    /**
     * ARMY_GRUNTER
     */
    ARMY_GRUNTER: string
    /**
     * ARMY_GRUNTER_DAY_NETHER
     */
    ARMY_GRUNTER_DAY_NETHER: string
    /**
     * HORDE_PACK_BRUISER
     */
    HORDE_PACK_BRUISER: string
    /**
     * HORDE_PACK_BRUISER_DAY_NETHER
     */
    HORDE_PACK_BRUISER_DAY_NETHER: string
    /**
     * HORDE_PACK_GRENADIER
     */
    HORDE_PACK_GRENADIER: string
    /**
     * HORDE_PACK_GRENADIER_DAY_NETHER
     */
    HORDE_PACK_GRENADIER_DAY_NETHER: string
    /**
     * HORDE_PACK_SEEKER
     */
    HORDE_PACK_SEEKER: string
    /**
     * HORDE_PACK_SEEKER_DAY_NETHER
     */
    HORDE_PACK_SEEKER_DAY_NETHER: string
    /**
     * HORDE_PACK_WARBOAR
     */
    HORDE_PACK_WARBOAR: string
    /**
     * HORDE_PACK_WARBOAR_DAY_NETHER
     */
    HORDE_PACK_WARBOAR_DAY_NETHER: string
    /**
     * HORDE_PACK_RUNT
     */
    HORDE_PACK_RUNT: string
    /**
     * HORDE_PACK_RUNT_DAY_NETHER
     */
    HORDE_PACK_RUNT_DAY_NETHER: string
    /**
     * HORDE_PACK_GRUNTER
     */
    HORDE_PACK_GRUNTER: string
    /**
     * HORDE_PACK_GRUNTER_DAY_NETHER
     */
    HORDE_PACK_GRUNTER_DAY_NETHER: string
    /**
     * HORDE_PACK_PACK_PIGMADILO
     */
    HORDE_PACK_PACK_PIGMADILO: string
    /**
     * HORDE_PACK_PACK_PIGMADILO_DAY_NETHER
     */
    HORDE_PACK_PACK_PIGMADILO_DAY_NETHER: string
    /**
     * HORDE_PACK_PORTAL_GUARD
     */
    HORDE_PACK_PORTAL_GUARD: string
    /**
     * HORDE_PACK_PORTAL_GUARD_DAY_NETHER
     */
    HORDE_PACK_PORTAL_GUARD_DAY_NETHER: string
    /**
     * HORDE_PACK_ENGINEER
     */
    HORDE_PACK_ENGINEER: string
    /**
     * HORDE_PACK_ENGINEER_DAY_NETHER
     */
    HORDE_PACK_ENGINEER_DAY_NETHER: string
    /**
     * HORDE_PACK_PIGGO_LAUNCHER
     */
    HORDE_PACK_PIGGO_LAUNCHER: string
    /**
     * HORDE_PACK_PIGGO_LAUNCHER_DAY_NETHER
     */
    HORDE_PACK_PIGGO_LAUNCHER_DAY_NETHER: string
    /**
     * HORDE_DEFEND_MEDIC
     */
    HORDE_DEFEND_MEDIC: string
    /**
     * HORDE_ATTACK_MEDIC
     */
    HORDE_ATTACK_MEDIC: string
    /**
     * HORDE_OBSTACLE_MEDIC
     */
    HORDE_OBSTACLE_MEDIC: string
    /**
     * HORDE_DEFEND_MEDIC_DAY
     */
    HORDE_DEFEND_MEDIC_DAY: string
    /**
     * HORDE_ATTACK_MEDIC_DAY
     */
    HORDE_ATTACK_MEDIC_DAY: string
    /**
     * HORDE_OBSTACLE_MEDIC_DAY
     */
    HORDE_OBSTACLE_MEDIC_DAY: string
}

/**
 * GAMEMODE: BASE
 * Global variable of each mob alliance occupation
 */
declare interface GV_START_MOB_ALLIANCE_OCCUPATION {

}

/**
 * GAMEMODE: BASE
 * Valid options for the `LISTENFOR_HealthChanged` `direction` rule.
 */
declare interface HEALTH_DIRECTION {
    /**
     * DAMAGE
     */
    DAMAGE: number
    /**
     * HEAL
     */
    HEAL: number
}

/**
 * GAMEMODE: BASE
 * Valid options for the `LISTENFOR_HealthChanged` `triggerMode` rule.
 */
declare interface HEALTH_TRIGGER_MODE {
    /**
     * CROSS
     */
    CROSS: number
    /**
     * BELOW
     */
    BELOW: number
    /**
     * ABOVE
     */
    ABOVE: number
}

/**
 * GAMEMODE: BASE
 * Horde arrival world map keys.
 */
declare interface HORDE_ARRIVAL_MAP_KEYS {

}

/**
 * GAMEMODE: campaign
 * Horde-wise configuration for the initial bases that spawn at the start of Act 2.
 */
declare interface HordeBasesSetup {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface HordeBasesSetup_Hard {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface HordeBasesSetup_Normal {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface HordeBasesSetup_Peaceful {

}

/**
 * GAMEMODE: campaign
 * Configuration for staggered entry where conditions for each arrival is specified.
 */
declare interface HordeEntryConfig {
    /**
     * invasionStartAfterFirstEstablished
     */
    invasionStartAfterFirstEstablished: number
    /**
     * hordes
     */
    hordes: []
    /**
     * mobAlliances
     */
    mobAlliances: []
}

/**
 * GAMEMODE: campaign
 *
 */
declare interface HordeEntryConfig_Hard {
    /**
     * invasionStartAfterFirstEstablished
     */
    invasionStartAfterFirstEstablished: number
    /**
     * hordes
     */
    hordes: []
    /**
     * mobAlliances
     */
    mobAlliances: []
}

/**
 * GAMEMODE: campaign
 *
 */
declare interface HordeEntryConfig_Normal {
    /**
     * invasionStartAfterFirstEstablished
     */
    invasionStartAfterFirstEstablished: number
    /**
     * hordes
     */
    hordes: []
    /**
     * mobAlliances
     */
    mobAlliances: []
}

/**
 * GAMEMODE: campaign
 *
 */
declare interface HordeEntryConfig_Peaceful {
    /**
     * invasionStartAfterFirstEstablished
     */
    invasionStartAfterFirstEstablished: number
    /**
     * hordes
     */
    hordes: []
    /**
     * mobAlliances
     */
    mobAlliances: []
}

/**
 * GAMEMODE: campaign
 * HordeEstablishment
 */
declare interface HordeEstablishment {
    /**
     * gvCentralBaseId
     */
    gvCentralBaseId: boolean
    /**
     * gvSizeCount
     */
    gvSizeCount: boolean
    /**
     * gvDayEstablished
     */
    gvDayEstablished: boolean
    /**
     * gvPreGameRemaining
     */
    gvPreGameRemaining: boolean
    /**
     * SetSizeCount
     */
    SetSizeCount: boolean
    /**
     * GetSizeCount
     */
    GetSizeCount: boolean
    /**
     * DecrementSizeCount
     */
    DecrementSizeCount: boolean
    /**
     * IsEstablished
     */
    IsEstablished: boolean
    /**
     * IsCentralBaseEstablished
     */
    IsCentralBaseEstablished: boolean
    /**
     * GetCentralBaseID
     */
    GetCentralBaseID: boolean
    /**
     * SetCentralBaseID
     */
    SetCentralBaseID: boolean
    /**
     * GetPreGameRemaining
     */
    GetPreGameRemaining: boolean
    /**
     * SetPreGameRemaining
     */
    SetPreGameRemaining: boolean
    /**
     * DecrementPreGameRemaining
     */
    DecrementPreGameRemaining: boolean
    /**
     * GetHordes
     */
    GetHordes: boolean
    /**
     * GetNextBaseSizeToBuild
     */
    GetNextBaseSizeToBuild: boolean
}

/**
 * GAMEMODE: BASE
 * UI event names AND the UI visibility unlock resource.
 */
declare interface HUD_EVENT_NAME {
    /**
     * SONGBOOK_OPENED
     */
    SONGBOOK_OPENED: string
    /**
     * SONGBOOK_CLOSED
     */
    SONGBOOK_CLOSED: string
    /**
     * MAP_OPENED
     */
    MAP_OPENED: string
    /**
     * MAP_CLOSED
     */
    MAP_CLOSED: string
    /**
     * TOOLBAR_0
     */
    TOOLBAR_0: string
    /**
     * TOOLBAR_1
     */
    TOOLBAR_1: string
    /**
     * TOOLBAR_2
     */
    TOOLBAR_2: string
    /**
     * TOOLBAR_3
     */
    TOOLBAR_3: string
    /**
     * DYNAMIC
     */
    DYNAMIC: any
}

/**
 * GAMEMODE: BASE
 * Audio for invasion village attacks.
 */
declare interface INVASION_ATTACK_AUDIO {
    /**
     * PHASES
     */
    PHASES: any
}

/**
 * GAMEMODE: BASE
 * Valid WM3 values for key `INVASION_ATTACK_AUTO_RESOLVE`.
 */
declare interface INVASION_ATTACK_AUTO_RESOLVE {
    /**
     * DAMAGED
     */
    DAMAGED: string
    /**
     * UNDAMAGED
     */
    UNDAMAGED: string
}

/**
 * GAMEMODE: BASE
 * INVASION_ATTACK_RESULT
 */
declare interface INVASION_ATTACK_RESULT {
    /**
     * OBDESTROYED
     */
    OBDESTROYED: number
    /**
     * UNDAMAGED
     */
    UNDAMAGED: number
    /**
     * DAMAGED
     */
    DAMAGED: number
    /**
     * DESTROYED
     */
    DESTROYED: number
}

/**
 * GAMEMODE: BASE
 * Contains the actions for spawning invasions bases, so that the UI will know what kind of
 * base was created and what should be displayed as a result.
 */
declare interface INVASION_BASE_SPAWN_ACTION {
    /**
     * outpost
     */
    outpost: string
    /**
     * vanguard
     */
    vanguard: string
}

/**
 * GAMEMODE: BASE
 * Contains the variables for controlling the invasion state related to phases
 */
declare interface INVASION_PHASE_STATE {
    /**
     * MOB_ALLIANCES_COMPLETED_COUNT
     */
    MOB_ALLIANCES_COMPLETED_COUNT: string
    /**
     * TOWERS_COMPLETED_COUNT
     */
    TOWERS_COMPLETED_COUNT: string
    /**
     * ALLIES_COMPLETED_COUNT
     */
    ALLIES_COMPLETED_COUNT: string
    /**
     * MOUNTS_COMPLETED_COUNT
     */
    MOUNTS_COMPLETED_COUNT: string
    /**
     * WOF_UPGRADES_PRESENT_COUNT
     */
    WOF_UPGRADES_PRESENT_COUNT: string
    /**
     * BASES_DESTROYED_COUNT
     */
    BASES_DESTROYED_COUNT: string
    /**
     * ATTACK_HORDE_DESTROYED
     */
    ATTACK_HORDE_DESTROYED: string
    /**
     * DEFEND_HORDE_DESTROYED
     */
    DEFEND_HORDE_DESTROYED: string
    /**
     * OBSTACLE_HORDE_DESTROYED
     */
    OBSTACLE_HORDE_DESTROYED: string
}

/**
 * GAMEMODE: BASE
 * INVULNERABILITY_EFFECT
 */
declare interface INVULNERABILITY_EFFECT {
    /**
     * DEFAULT
     */
    DEFAULT: number
    /**
     * EFFECT_A
     */
    EFFECT_A: number
    /**
     * EFFECT_B
     */
    EFFECT_B: number
    /**
     * EFFECT_C
     */
    EFFECT_C: number
    /**
     * EFFECT_D
     */
    EFFECT_D: number
}

/**
 * GAMEMODE: BASE
 * Valid map values for `MAP_KEY.IS_DESTROYED`
 */
declare interface IS_DESTROYED {
    /**
     * TRUE
     */
    TRUE: string
}

/**
 * GAMEMODE: BASE
 * JOURNAL_UNLOCKS
 */
declare interface JOURNAL_UNLOCKS {
    /**
     * TREASURE_CHEST
     */
    TREASURE_CHEST: string
    /**
     * CAVALRY_GOLEM
     */
    CAVALRY_GOLEM: string
    /**
     * SUPPORT_GOLEM
     */
    SUPPORT_GOLEM: string
    /**
     * PLANK_GOLEM
     */
    PLANK_GOLEM: string
    /**
     * STONE_GOLEM
     */
    STONE_GOLEM: string
    /**
     * MOB_CREEPER
     */
    MOB_CREEPER: string
    /**
     * MOB_ZOMBIE
     */
    MOB_ZOMBIE: string
    /**
     * MOB_SKELETON
     */
    MOB_SKELETON: string
    /**
     * MOUNT_TIGER
     */
    MOUNT_TIGER: string
    /**
     * MOUNT_BEETLE
     */
    MOUNT_BEETLE: string
    /**
     * MOUNT_BIRD
     */
    MOUNT_BIRD: string
    /**
     * VILLAGE
     */
    VILLAGE: string
    /**
     * VINDICATOR
     */
    VINDICATOR: string
    /**
     * ALLY_FALLEN_WARRIOR
     */
    ALLY_FALLEN_WARRIOR: string
    /**
     * ALLY_SPAWNER
     */
    ALLY_SPAWNER: string
    /**
     * ALLY_SHIELD
     */
    ALLY_SHIELD: string
    /**
     * ALLY_SNIPER
     */
    ALLY_SNIPER: string
    /**
     * TOWER_BLAST
     */
    TOWER_BLAST: string
    /**
     * TOWER_STUN
     */
    TOWER_STUN: string
    /**
     * TOWER_FROST
     */
    TOWER_FROST: string
    /**
     * BUFF_SPEED_WEED
     */
    BUFF_SPEED_WEED: string
    /**
     * BUFF_BOUNCY_MUSHROOM
     */
    BUFF_BOUNCY_MUSHROOM: string
    /**
     * BUFF_REGEN_STONE
     */
    BUFF_REGEN_STONE: string
    /**
     * HAZARD_REDTHORN
     */
    HAZARD_REDTHORN: string
    /**
     * HAZARD_TAR_PIT
     */
    HAZARD_TAR_PIT: string
    /**
     * HAZARD_MUD_PIT
     */
    HAZARD_MUD_PIT: string
    /**
     * HAZARD_VENOM_VINES
     */
    HAZARD_VENOM_VINES: string
    /**
     * HAZARD_GEYSER
     */
    HAZARD_GEYSER: string
    /**
     * HORDE_ATTACK_FACTION
     */
    HORDE_ATTACK_FACTION: string
    /**
     * HORDE_DEFEND_FACTION
     */
    HORDE_DEFEND_FACTION: string
    /**
     * HORDE_OBSTACLE_FACTION
     */
    HORDE_OBSTACLE_FACTION: string
    /**
     * HORDE_ATTACK_BOSS
     */
    HORDE_ATTACK_BOSS: string
    /**
     * HORDE_DEFEND_BOSS
     */
    HORDE_DEFEND_BOSS: string
    /**
     * HORDE_OBSTACLE_BOSS
     */
    HORDE_OBSTACLE_BOSS: string
    /**
     * GREAT_HOG
     */
    GREAT_HOG: string
    /**
     * PIGLIN_INVASION
     */
    PIGLIN_INVASION: string
    /**
     * PIGLIN_CRATE
     */
    PIGLIN_CRATE: string
    /**
     * PIGLIN_UNIT_RUNT
     */
    PIGLIN_UNIT_RUNT: string
    /**
     * PIGLIN_UNIT_GRUNTER
     */
    PIGLIN_UNIT_GRUNTER: string
    /**
     * PIGLIN_UNIT_BRUISER
     */
    PIGLIN_UNIT_BRUISER: string
    /**
     * PIGLIN_UNIT_ENGINEER
     */
    PIGLIN_UNIT_ENGINEER: string
    /**
     * PIGLIN_UNIT_GRENADIER
     */
    PIGLIN_UNIT_GRENADIER: string
    /**
     * PIGLIN_UNIT_MEDIC
     */
    PIGLIN_UNIT_MEDIC: string
    /**
     * PIGLIN_UNIT_SEEKER
     */
    PIGLIN_UNIT_SEEKER: string
    /**
     * PIGLIN_UNIT_PIGMADILO
     */
    PIGLIN_UNIT_PIGMADILO: string
    /**
     * PIGLIN_UNIT_WARBOAR
     */
    PIGLIN_UNIT_WARBOAR: string
    /**
     * PIGLIN_UNIT_PORTALGUARD
     */
    PIGLIN_UNIT_PORTALGUARD: string
    /**
     * PIGLIN_UNIT_LAVALAUNCHER
     */
    PIGLIN_UNIT_LAVALAUNCHER: string
    /**
     * PIGLIN_STRUCTURE_NETHER_SPREADER
     */
    PIGLIN_STRUCTURE_NETHER_SPREADER: string
    /**
     * PIGLIN_STRUCTURE_PIGLIN_THROWER
     */
    PIGLIN_STRUCTURE_PIGLIN_THROWER: string
    /**
     * PIGLIN_STRUCTURE_LAVA_TOWER
     */
    PIGLIN_STRUCTURE_LAVA_TOWER: string
    /**
     * PIGLIN_STRUCTURE_KNOCKBACK_TOWER
     */
    PIGLIN_STRUCTURE_KNOCKBACK_TOWER: string
    /**
     * PIGLIN_STRUCTURE_ARROW_TOWER
     */
    PIGLIN_STRUCTURE_ARROW_TOWER: string
    /**
     * PIGLIN_STRUCTURE_BARRACKS
     */
    PIGLIN_STRUCTURE_BARRACKS: string
    /**
     * PIGLIN_STRUCTURE_SUPER_NETHER_SPREADER
     */
    PIGLIN_STRUCTURE_SUPER_NETHER_SPREADER: string
    /**
     * PIGLIN_STRUCTURE_RANGE_EXTENDER
     */
    PIGLIN_STRUCTURE_RANGE_EXTENDER: string
    /**
     * PIGLIN_STRUCTURE_REGENERATOR
     */
    PIGLIN_STRUCTURE_REGENERATOR: string
}

/**
 * GAMEMODE: challenge_pack_1_TimedBaseDestruction
 *
 */
declare interface LocksKeys {

}

/**
 * GAMEMODE: BASE
 * Loot override table names for entities. These correspond to the name defined on the entity, not the loot table ID.
 */
declare interface LOOT_OVERRIDE {
    /**
     * PIGLIN_ROAMING
     */
    PIGLIN_ROAMING: string
    /**
     * PIGLIN_OUTPOST
     */
    PIGLIN_OUTPOST: string
    /**
     * PIGLIN_VILLAGE_ATTACK
     */
    PIGLIN_VILLAGE_ATTACK: string
}

/**
 * GAMEMODE: BASE
 * LOOT_TYPE
 */
declare interface LOOT_TYPE {
    /**
     * treasureChest
     */
    treasureChest: number
    /**
     * piglinCrate
     */
    piglinCrate: number
    /**
     * treasureChestPvP
     */
    treasureChestPvP: number
}

/**
 * GAMEMODE: BASE
 * Base size
 */
declare interface MAP_BASE_SIZE {
    /**
     * SMALL
     */
    SMALL: string
    /**
     * MEDIUM
     */
    MEDIUM: string
    /**
     * LARGE
     */
    LARGE: string
    /**
     * OCCUPYING_CREEPER
     */
    OCCUPYING_CREEPER: string
    /**
     * OCCUPYING_SKELETON
     */
    OCCUPYING_SKELETON: string
    /**
     * OCCUPYING_ZOMBIE
     */
    OCCUPYING_ZOMBIE: string
    /**
     * ACT1_A
     */
    ACT1_A: string
    /**
     * ACT1_B
     */
    ACT1_B: string
    /**
     * ACT1_C
     */
    ACT1_C: string
    /**
     * ACT1_FIRST_SKIRMISH
     */
    ACT1_FIRST_SKIRMISH: string
    /**
     * ACT1_SECOND_SKIRMISH
     */
    ACT1_SECOND_SKIRMISH: string
    /**
     * BASE_SIZE_ACT1_NON_PORTAL_ATTACK_BASE
     */
    BASE_SIZE_ACT1_NON_PORTAL_ATTACK_BASE: string
    /**
     * FOB_SMALL
     */
    FOB_SMALL: string
    /**
     * FOB_MEDIUM
     */
    FOB_MEDIUM: string
    /**
     * FOB_LARGE
     */
    FOB_LARGE: string
}

/**
 * GAMEMODE: BASE
 * Map boss
 */
declare interface MAP_BOSS {
    /**
     * DEFEATED
     */
    DEFEATED: string
    /**
     * DARK_BEACON
     */
    DARK_BEACON: string
    /**
     * DEFEND_BOSS
     */
    DEFEND_BOSS: string
    /**
     * ATTACK_BOSS
     */
    ATTACK_BOSS: string
    /**
     * OBSTACLE_BOSS
     */
    OBSTACLE_BOSS: string
    /**
     * FINAL_BOSS
     */
    FINAL_BOSS: string
}

/**
 * GAMEMODE: BASE
 * Buildings ids used by the map system
 */
declare interface MAP_BUILDABLE_IDS {
    /**
     * TOWER_01
     */
    TOWER_01: string
    /**
     * TOWER_02
     */
    TOWER_02: string
    /**
     * TOWER_04
     */
    TOWER_04: string
    /**
     * PVP_HQ
     */
    PVP_HQ: string
}

/**
 * GAMEMODE: BASE
 * Map IDs used by the fast travel system.
 */
declare interface MAP_CAN_FAST_TRAVEL {
    /**
     * TRUE
     */
    TRUE: string
    /**
     * FALSE
     */
    FALSE: string
}

/**
 * GAMEMODE: BASE
 * The map categories
 */
declare interface MAP_CATEGORY {
    /**
     * FACTION
     */
    FACTION: string
    /**
     * PLAYER
     */
    PLAYER: string
    /**
     * BUILDABLE
     */
    BUILDABLE: string
    /**
     * MOB
     */
    MOB: string
}

/**
 * GAMEMODE: BASE
 * World map values for claimed area visibiliy.
 */
declare interface MAP_CLAIMED_AREA_VISIBILITY {
    /**
     * VISIBLE
     */
    VISIBLE: string
    /**
     * INVISIBLE
     */
    INVISIBLE: string
}

/**
 * GAMEMODE: BASE
 * List of the faction ids used by the map
 */
declare interface MAP_FACTION_IDS {
    /**
     * WELL_OF_FATE
     */
    WELL_OF_FATE: string
    /**
     * FACTION_DEFEND
     */
    FACTION_DEFEND: string
    /**
     * FACTION_ATTACK
     */
    FACTION_ATTACK: string
    /**
     * FACTION_OBSTACLE
     */
    FACTION_OBSTACLE: string
    /**
     * FACTION_DBB
     */
    FACTION_DBB: string
    /**
     * CULTURE_VILLAGER
     */
    CULTURE_VILLAGER: string
    /**
     * MOB_ALLIANCE_CREEPER
     */
    MOB_ALLIANCE_CREEPER: string
    /**
     * MOB_ALLIANCE_SKELETON
     */
    MOB_ALLIANCE_SKELETON: string
    /**
     * MOB_ALLIANCE_ZOMBIE
     */
    MOB_ALLIANCE_ZOMBIE: string
    /**
     * TOWER_01
     */
    TOWER_01: string
    /**
     * TOWER_02
     */
    TOWER_02: string
    /**
     * TOWER_04
     */
    TOWER_04: string
    /**
     * ALLY_01
     */
    ALLY_01: string
    /**
     * ALLY_02
     */
    ALLY_02: string
    /**
     * ALLY_04
     */
    ALLY_04: string
    /**
     * ALLY_05
     */
    ALLY_05: string
    /**
     * MOUNT_01
     */
    MOUNT_01: string
    /**
     * MOUNT_03
     */
    MOUNT_03: string
    /**
     * MOUNT_04
     */
    MOUNT_04: string
    /**
     * UNNATURAL_LANDMARK_01
     */
    UNNATURAL_LANDMARK_01: string
}

/**
 * GAMEMODE: BASE
 * The fast travel state of a village
 */
declare interface MAP_FAST_TRAVEL {
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * ENABLED
     */
    ENABLED: string
}

/**
 * GAMEMODE: BASE
 * World map values for horde arrival.
 */
declare interface MAP_HORDE_ARRIVAL {
    /**
     * FALSE
     */
    FALSE: string
    /**
     * TRUE
     */
    TRUE: string
}

/**
 * GAMEMODE: BASE
 * General map icon state
 */
declare interface MAP_ICON_STATE {
    /**
     * DEFAULT
     */
    DEFAULT: string
    /**
     * VISITED
     */
    VISITED: string
    /**
     * COMPLETED
     */
    COMPLETED: string
    /**
     * UNHURT
     */
    UNHURT: string
    /**
     * DAMAGED
     */
    DAMAGED: string
    /**
     * DESTROYED
     */
    DESTROYED: string
    /**
     * UNDER_ATTACK
     */
    UNDER_ATTACK: string
    /**
     * TARGETED
     */
    TARGETED: string
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * DISABLED_ACT1
     */
    DISABLED_ACT1: string
    /**
     * DAMAGED_ACT1
     */
    DAMAGED_ACT1: string
    /**
     * TARGTED_VA_ACT1
     */
    TARGTED_VA_ACT1: string
}

/**
 * GAMEMODE: BASE
 * Map invasion states
 */
declare interface MAP_INVASION {
    /**
     * VILLAGE_INVASION_DISABLED
     */
    VILLAGE_INVASION_DISABLED: string
    /**
     * VILLAGE_INVASION_ENABLED
     */
    VILLAGE_INVASION_ENABLED: string
    /**
     * NEW_VILLAGE_INVASION
     */
    NEW_VILLAGE_INVASION: string
    /**
     * OLD_VILLAGE_INVASION
     */
    OLD_VILLAGE_INVASION: string
    /**
     * NEW_INVASION_BASE
     */
    NEW_INVASION_BASE: string
    /**
     * BASE_EXPANDED
     */
    BASE_EXPANDED: string
    /**
     * BASE_UPGRADED
     */
    BASE_UPGRADED: string
}

/**
 * GAMEMODE: BASE
 * Valid WM3 values for key `MAP_INVASION_ACTIVE`
 */
declare interface MAP_INVASION_ACTIVE {
    /**
     * IS_ATTACKING
     */
    IS_ATTACKING: string
    /**
     * IS_BUILDING
     */
    IS_BUILDING: string
    /**
     * IS_UPGRADING
     */
    IS_UPGRADING: string
    /**
     * IS_UNDER_ATTACK
     */
    IS_UNDER_ATTACK: string
    /**
     * IS_OCCUPIED
     */
    IS_OCCUPIED: string
    /**
     * IS_BOSS_OCCUPATION
     */
    IS_BOSS_OCCUPATION: string
}

/**
 * GAMEMODE: BASE
 * Valid WM3 values for key `MAP_INVASION_ATTACK`
 */
declare interface MAP_INVASION_ATTACK {
    /**
     * ACTIVATED
     */
    ACTIVATED: string
    /**
     * ABANDONED
     */
    ABANDONED: string
}

/**
 * GAMEMODE: BASE
 * Valid WM3 values for key `MAP_INVASION_INTENTION`
 */
declare interface MAP_INVASION_INTENTION {
    /**
     * ATTACKING
     */
    ATTACKING: string
    /**
     * CLAIMING
     */
    CLAIMING: string
    /**
     * BUILDING
     */
    BUILDING: string
    /**
     * BUILDING_OUTPOST
     */
    BUILDING_OUTPOST: string
    /**
     * UPGRADING
     */
    UPGRADING: string
    /**
     * TARGETED
     */
    TARGETED: string
    /**
     * SAVED
     */
    SAVED: string
    /**
     * BOSS_OCCUPATION
     */
    BOSS_OCCUPATION: string
}

/**
 * GAMEMODE: BASE
 * Valid WM3 values for key `MAP_INVASION_RECAP`
 */
declare interface MAP_INVASION_RECAP {
    /**
     * ATTACK_FAILURE
     */
    ATTACK_FAILURE: string
    /**
     * ATTACK_SUCCESS
     */
    ATTACK_SUCCESS: string
    /**
     * BUILT_OFFENSIVE_OUTPOST
     */
    BUILT_OFFENSIVE_OUTPOST: string
    /**
     * BUILT_DEFENSIVE_OUTPOST
     */
    BUILT_DEFENSIVE_OUTPOST: string
    /**
     * BUILT_NEW_BASE
     */
    BUILT_NEW_BASE: string
    /**
     * UPGRADED
     */
    UPGRADED: string
    /**
     * OOPSED
     */
    OOPSED: string
    /**
     * CLAIMED_AREA
     */
    CLAIMED_AREA: string
}

/**
 * GAMEMODE: BASE
 * World map values for invasion special.
 */
declare interface MAP_INVASION_SPECIAL {
    /**
     * IS_NORMAL
     */
    IS_NORMAL: string
    /**
     * IS_BOSS
     */
    IS_BOSS: string
}

/**
 * GAMEMODE: BASE
 * Invasion map state
 */
declare interface MAP_INVASION_STATE {
    /**
     * ENABLED
     */
    ENABLED: string
    /**
     * DISABLED
     */
    DISABLED: string
}

/**
 * GAMEMODE: BASE
 * The keys used by the map system
 */
declare interface MAP_KEY {
    /**
     * MODE
     */
    MODE: string
    /**
     * ZOOM
     */
    ZOOM: string
    /**
     * SIZE
     */
    SIZE: string
    /**
     * STATE
     */
    STATE: string
    /**
     * VISIBILITY
     */
    VISIBILITY: string
    /**
     * TEAM
     */
    TEAM: string
    /**
     * GAME_RULE
     */
    GAME_RULE: string
    /**
     * FAST_TRAVEL
     */
    FAST_TRAVEL: string
    /**
     * BOSS
     */
    BOSS: string
    /**
     * INVASION_STATE
     */
    INVASION_STATE: string
    /**
     * INVASION_INTENTION
     */
    INVASION_INTENTION: string
    /**
     * INVASION_ACTIVE
     */
    INVASION_ACTIVE: string
    /**
     * INVASION_ATTACK
     */
    INVASION_ATTACK: string
    /**
     * INVASION_ATTACK_AUTO_RESOLVE
     */
    INVASION_ATTACK_AUTO_RESOLVE: string
    /**
     * INVASION_RECAP
     */
    INVASION_RECAP: string
    /**
     * INVASION_SPECIAL
     */
    INVASION_SPECIAL: string
    /**
     * PVP_UNDER_ATTACK
     */
    PVP_UNDER_ATTACK: string
    /**
     * IS_DESTROYED
     */
    IS_DESTROYED: string
    /**
     * DOTTED_LINE_TARGET
     */
    DOTTED_LINE_TARGET: string
    /**
     * PLAYER_ID
     */
    PLAYER_ID: string
    /**
     * MOB_ALLEGIANCE
     */
    MOB_ALLEGIANCE: string
    /**
     * ONBOARDING
     */
    ONBOARDING: string
    /**
     * TEAM_OUTLINES
     */
    TEAM_OUTLINES: string
    /**
     * CAN_FAST_TRAVEL
     */
    CAN_FAST_TRAVEL: string
    /**
     * PVP_VILLAGE_OWNERSHIP
     */
    PVP_VILLAGE_OWNERSHIP: string
    /**
     * ACT1_VILLAGE_STATE
     */
    ACT1_VILLAGE_STATE: string
    /**
     * MOUNT_WORLD_SPAWNER
     */
    MOUNT_WORLD_SPAWNER: string
    /**
     * VILLAGE_CHEST_STATE
     */
    VILLAGE_CHEST_STATE: string
    /**
     * VILLAGE_RESOURCE
     */
    VILLAGE_RESOURCE: string
    /**
     * VILLAGE_RESOURCE_VISIBILITY
     */
    VILLAGE_RESOURCE_VISIBILITY: string
    /**
     * VILLAGE_CULTURE_LEVEL
     */
    VILLAGE_CULTURE_LEVEL: string
    /**
     * BASE_LOOT
     */
    BASE_LOOT: string
    /**
     * ATTACKING_FACTION
     */
    ATTACKING_FACTION: string
    /**
     * STRENGTH
     */
    STRENGTH: string
    /**
     * CLAIMED_AREA_VISIBILITY
     */
    CLAIMED_AREA_VISIBILITY: string
    /**
     * ATTACK_HORDE_ARRIVED
     */
    ATTACK_HORDE_ARRIVED: string
    /**
     * DEFEND_HORDE_ARRIVED
     */
    DEFEND_HORDE_ARRIVED: string
    /**
     * OBSTACLE_HORDE_ARRIVED
     */
    OBSTACLE_HORDE_ARRIVED: string
    /**
     * PLAYER_DAMAGED_BASE
     */
    PLAYER_DAMAGED_BASE: string
}

/**
 * GAMEMODE: BASE
 * MAP_MOB_ALLEGIANCE
 */
declare interface MAP_MOB_ALLEGIANCE {
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * ENABLED
     */
    ENABLED: string
}

/**
 * GAMEMODE: BASE
 * The mob ids used by the map
 */
declare interface MAP_MOB_IDS {
    /**
     * ALLY_01
     */
    ALLY_01: string
    /**
     * ALLY_02
     */
    ALLY_02: string
    /**
     * ALLY_04
     */
    ALLY_04: string
    /**
     * ALLY_05
     */
    ALLY_05: string
}

/**
 * GAMEMODE: BASE
 * The map mode
 */
declare interface MAP_MODE {
    /**
     * NORMAL
     */
    NORMAL: string
    /**
     * FAST_TRAVEL
     */
    FAST_TRAVEL: string
}

/**
 * GAMEMODE: BASE
 * MAP_MOUNT_WORLD_SPAWNER - DISABLED/ENABLED
 */
declare interface MAP_MOUNT_WORLD_SPAWNER {
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * ENABLED
     */
    ENABLED: string
}

/**
 * GAMEMODE: BASE
 * MAP_ONBOARDING
 */
declare interface MAP_ONBOARDING {
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * ENABLED
     */
    ENABLED: string
}

/**
 * GAMEMODE: BASE
 * MAP_PLAYER_DAMAGED_BASE
 */
declare interface MAP_PLAYER_DAMAGED_BASE {
    /**
     * DAMAGED
     */
    DAMAGED: string
}

/**
 * GAMEMODE: BASE
 * Is a PvP structure under attack (Used on map icons)
 */
declare interface MAP_PVP_UNDER_ATTACK {
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * ENABLED
     */
    ENABLED: string
}

/**
 * GAMEMODE: BASE
 * List of teams used by the map
 */
declare interface MAP_TEAM {
    /**
     * NEUTRAL
     */
    NEUTRAL: string
    /**
     * WILD
     */
    WILD: string
    /**
     * BLUE
     */
    BLUE: string
    /**
     * TWO
     */
    TWO: string
    /**
     * RED
     */
    RED: string
    /**
     * ONE
     */
    ONE: string
    /**
     * PIGLIN
     */
    PIGLIN: string
}

/**
 * GAMEMODE: BASE
 * States for the village chests on a village
 */
declare interface MAP_VILLAGE_CHEST {
    /**
     * COLLECTED
     */
    COLLECTED: string
    /**
     * UNCOLLECTED
     */
    UNCOLLECTED: string
    /**
     * FULL
     */
    FULL: string
}

/**
 * GAMEMODE: BASE
 * The visibility state of a icon on the map
 */
declare interface MAP_VISIBILITY {
    /**
     * VISIBLE
     */
    VISIBLE: string
    /**
     * HIDDEN
     */
    HIDDEN: string
    /**
     * REVEALED
     */
    REVEALED: string
}

/**
 * GAMEMODE: BASE
 * The zoom of the map
 */
declare interface MAP_ZOOM {
    /**
     * DEFAULT
     */
    DEFAULT: string
}

/**
 * GAMEMODE: BASE
 * Variables to keep track of messaging
 */
declare interface MESSAGING_GLOBALS {
    /**
     * MOB_ALLIANCE_LOST
     */
    MOB_ALLIANCE_LOST: string
    /**
     * VILLAGE_LOST
     */
    VILLAGE_LOST: string
}

/**
 * GAMEMODE: BASE
 * Archetype for villagers/mobs
 */
declare interface MOB_ARCHETYPE {
    /**
     * ZOMBIE
     */
    ZOMBIE: string
    /**
     * CREEPER
     */
    CREEPER: string
    /**
     * SKELETON
     */
    SKELETON: string
    /**
     * VILLAGERS
     */
    VILLAGERS: string
    /**
     * ANIMALS
     */
    ANIMALS: []
}

/**
 * GAMEMODE: BASE
 * List with all the behaviours of each mob
 */
declare interface MOB_BEHAVIOUR_DICTIONARY {
    /**
     * creeper
     */
    creeper: any
    /**
     * skeleton
     */
    skeleton: any
    /**
     * zombie
     */
    zombie: any
}

/**
 * GAMEMODE: BASE
 * MOUNTS
 */
declare interface MOUNTS {
    /**
     * TIGER
     */
    TIGER: string
    /**
     * BEETLE
     */
    BEETLE: string
    /**
     * BIRD
     */
    BIRD: string
    /**
     * HORSE
     */
    HORSE: string
}

/**
 * GAMEMODE: Demo_MinecraftLive
 * Names of different AI configs for obstacle faction bases.
 */
declare interface ObstacleAI {
    /**
     * Siege
     */
    Siege: string
    /**
     * Assault
     */
    Assault: string
    /**
     * Guard
     */
    Guard: string
}

/**
 * GAMEMODE: Demo_MinecraftLive
 *
 */
declare interface ObstacleCompositions {
    /**
     * grunters
     */
    grunters: any
    /**
     * basicSeeker
     */
    basicSeeker: any
    /**
     * grunterPatrol
     */
    grunterPatrol: any
    /**
     * structureSquad
     */
    structureSquad: any
    /**
     * genadiers
     */
    genadiers: any
    /**
     * grenadierSquad
     */
    grenadierSquad: any
    /**
     * longrangeSiege
     */
    longrangeSiege: any
    /**
     * heavySquad
     */
    heavySquad: any
    /**
     * heavyPatrol
     */
    heavyPatrol: any
    /**
     * heavySiege
     */
    heavySiege: any
    /**
     * rotSquad
     */
    rotSquad: any
}

/**
 * GAMEMODE: Demo_MinecraftLive
 *
 */
declare interface ObstacleDiscreteEncounters {
    /**
     * sporeSpread
     */
    sporeSpread: any
    /**
     * sporeBlocakde
     */
    sporeBlocakde: any
    /**
     * seekingVengeance
     */
    seekingVengeance: any
    /**
     * noCannonForYou
     */
    noCannonForYou: any
    /**
     * gruntersEverywhere
     */
    gruntersEverywhere: any
    /**
     * grenadierGuards
     */
    grenadierGuards: any
    /**
     * comeAndTakeIt
     */
    comeAndTakeIt: any
    /**
     * pain
     */
    pain: any
    /**
     * sporeGrowth
     */
    sporeGrowth: any
    /**
     * sporeCannons
     */
    sporeCannons: any
    /**
     * hornsFromAbove
     */
    hornsFromAbove: any
    /**
     * highGround
     */
    highGround: any
    /**
     * sporeScore
     */
    sporeScore: any
    /**
     * greanadierNether
     */
    greanadierNether: any
}

/**
 * GAMEMODE: BASE
 * List of height cards for obstacle faction plateaus as defined in costs_piglin_obstacle.json
 */
declare interface ObstacleHeight {
    /**
     * Flatten
     */
    Flatten: string
    /**
     * H1
     */
    H1: string
    /**
     * H2
     */
    H2: string
    /**
     * H3
     */
    H3: string
    /**
     * H4
     */
    H4: string
    /**
     * H5
     */
    H5: string
    /**
     * H6
     */
    H6: string
    /**
     * H7
     */
    H7: string
    /**
     * H8
     */
    H8: string
    /**
     * H9
     */
    H9: string
    /**
     * H10
     */
    H10: string
    /**
     * H11
     */
    H11: string
    /**
     * H12
     */
    H12: string
    /**
     * H13
     */
    H13: string
    /**
     * H14
     */
    H14: string
    /**
     * H15
     */
    H15: string
    /**
     * H16
     */
    H16: string
    /**
     * H17
     */
    H17: string
    /**
     * H18
     */
    H18: string
    /**
     * H19
     */
    H19: string
    /**
     * H20
     */
    H20: string
    /**
     * H21
     */
    H21: string
    /**
     * H22
     */
    H22: string
    /**
     * H23
     */
    H23: string
    /**
     * H24
     */
    H24: string
    /**
     * H26
     */
    H26: string
    /**
     * H28
     */
    H28: string
    /**
     * H29
     */
    H29: string
    /**
     * H30
     */
    H30: string
    /**
     * H32
     */
    H32: string
    /**
     * H34
     */
    H34: string
    /**
     * H36
     */
    H36: string
    /**
     * H38
     */
    H38: string
    /**
     * H40
     */
    H40: string
    /**
     * H42
     */
    H42: string
    /**
     * H44
     */
    H44: string
    /**
     * H46
     */
    H46: string
    /**
     * H48
     */
    H48: string
    /**
     * H50
     */
    H50: string
    /**
     * H52
     */
    H52: string
    /**
     * H54
     */
    H54: string
}

/**
 * GAMEMODE: BASE
 * ONBOARDING_GLOBALS
 */
declare interface ONBOARDING_GLOBALS {
    /**
     * ONBOARDING_ENABLED
     */
    ONBOARDING_ENABLED: string
    /**
     * INITIAL_ONBOARDING_COMPLETE
     */
    INITIAL_ONBOARDING_COMPLETE: string
    /**
     * WELL_OF_FATE_ONBOARDING_ACTIVE
     */
    WELL_OF_FATE_ONBOARDING_ACTIVE: string
    /**
     * START_INVASION_GAMEPLAY
     */
    START_INVASION_GAMEPLAY: string
    /**
     * START_VILLAGE_PLAN_ATTACK
     */
    START_VILLAGE_PLAN_ATTACK: string
    /**
     * START_VILLAGE_PLAN_ATTACK_2
     */
    START_VILLAGE_PLAN_ATTACK_2: string
    /**
     * START_VILLAGE_DESTROYED
     */
    START_VILLAGE_DESTROYED: string
    /**
     * START_VILLAGE_OCCUPIED
     */
    START_VILLAGE_OCCUPIED: string
    /**
     * VILLAGE_DESTROYED_REBUILT
     */
    VILLAGE_DESTROYED_REBUILT: string
    /**
     * VILLAGE_CHEST_OPENED
     */
    VILLAGE_CHEST_OPENED: string
    /**
     * MOB_OCCUPATION_DEFEATED
     */
    MOB_OCCUPATION_DEFEATED: string
    /**
     * START_PLACED_SPAWNER
     */
    START_PLACED_SPAWNER: string
    /**
     * START_MOB_ALLIANCE_LOST
     */
    START_MOB_ALLIANCE_LOST: string
    /**
     * MOB_ALLIANCE_LOST_RECOVERED
     */
    MOB_ALLIANCE_LOST_RECOVERED: string
    /**
     * ARMED_VILLAGERS
     */
    ARMED_VILLAGERS: string
}

/**
 * GAMEMODE: BASE
 * Outpost Level
 */
declare interface OUTPOST_LEVEL {
    /**
     * LIGHT
     */
    LIGHT: string
    /**
     * MEDIUM
     */
    MEDIUM: string
    /**
     * HEAVY
     */
    HEAVY: string
}

/**
 * GAMEMODE: campaign
 *
 */
declare interface OutpostToMobAlliancesMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface OutpostToOtherVillagesMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface OutpostToOutpostMinDistanceConfiguration {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface OutpostToVillagerVillagesMinDistanceConfiguration {

}

/**
 * GAMEMODE: BASE
 * Entity archetypes for piglin units
 */
declare interface PIGLIN_ARCHETYPE {
    /**
     * MEDIC
     */
    MEDIC: string
    /**
     * ENGINEER
     */
    ENGINEER: string
    /**
     * RUNT
     */
    RUNT: string
    /**
     * GRUNTER
     */
    GRUNTER: string
    /**
     * WARBOAR
     */
    WARBOAR: string
    /**
     * SEEKER
     */
    SEEKER: string
    /**
     * BRUISER
     */
    BRUISER: string
    /**
     * GRENADIER
     */
    GRENADIER: string
    /**
     * PIGMADILO
     */
    PIGMADILO: string
    /**
     * PORTAL_GUARD
     */
    PORTAL_GUARD: string
    /**
     * LAVA_LAUNCHER
     */
    LAVA_LAUNCHER: string
}

/**
 * GAMEMODE: BASE
 * PIGLIN_BASE_ELEMENTS
 */
declare interface PIGLIN_BASE_ELEMENTS {
    /**
     * RAISED_PLATFORM
     */
    RAISED_PLATFORM: string
}

/**
 * GAMEMODE: campaign
 * Maps the act1 village's slots to the 'camp' placement slots for piglins to spawn.
 */
declare interface PIGLIN_CAMP_PLACEMENT_NAME_MAP {

}

/**
 * GAMEMODE: BASE
 * Crate data for campaign.
 */
declare interface PIGLIN_CRATE_CAMPAIGN_DATA {
    /**
     * globalIndex
     */
    globalIndex: string
    /**
     * messagePrefix
     */
    messagePrefix: string
    /**
     * telemetryType
     */
    telemetryType: string
    /**
     * telemetrySubcategory
     */
    telemetrySubcategory: any
    /**
     * chooseRandom
     */
    chooseRandom: boolean
    /**
     * isWeighted
     */
    isWeighted: boolean
    /**
     * useAvailabilityRestrictions
     */
    useAvailabilityRestrictions: boolean
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 * PIGLIN_CRATE_CAMPAIGN_DATA_HARD
 */
declare interface PIGLIN_CRATE_CAMPAIGN_DATA_HARD {
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 *
 */
declare interface PIGLIN_CRATE_CAMPAIGN_DATA_NORMAL {
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 * PIGLIN_CRATE_CAMPAIGN_DATA_PEACEFUL
 */
declare interface PIGLIN_CRATE_CAMPAIGN_DATA_PEACEFUL {
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 *
 */
declare interface PIGLIN_TAG_LOOKUP {

}

/**
 * GAMEMODE: campaign
 *
 */
declare interface PiglinBaseDamageFXConfig {
    /**
     * daysActive
     */
    daysActive: number
}

/**
 * GAMEMODE: pvp
 *
 */
declare interface PiglinPVPData {
    /**
     * numOutposts
     */
    numOutposts: number
}

/**
 * GAMEMODE: campaign
 * Constants for placement names defined by world-gen
 */
declare interface PLACEMENT_NAME {
    /**
     * FOREST_VILLAGE
     */
    FOREST_VILLAGE: string
    /**
     * FROSTLANDS_VILLAGE
     */
    FROSTLANDS_VILLAGE: string
    /**
     * DRYLANDS_VILLAGE
     */
    DRYLANDS_VILLAGE: string
    /**
     * WETLANDS_VILLAGE
     */
    WETLANDS_VILLAGE: string
    /**
     * GRASSLANDS_VILLAGE
     */
    GRASSLANDS_VILLAGE: string
    /**
     * CREEPER_ALLIANCE
     */
    CREEPER_ALLIANCE: string
    /**
     * SKELETON_ALLIANCE
     */
    SKELETON_ALLIANCE: string
    /**
     * ZOMBIE_ALLIANCE
     */
    ZOMBIE_ALLIANCE: string
}

/**
 * GAMEMODE: campaign
 * PLACEMENT_NAME_MAP
 */
declare interface PLACEMENT_NAME_MAP {

}

/**
 * GAMEMODE: pvp
 *
 */
declare interface PLAYER_TEAMS {

}

/**
 * GAMEMODE: BASE
 * POI_WAYPOINT_ICON_DICTIONARY
 */
declare interface POI_WAYPOINT_ICON_DICTIONARY {

}

/**
 * GAMEMODE: BASE
 * poi waypoint icon state
 */
declare interface POI_WAYPOINT_ICON_STATE {
    /**
     * HIDDEN
     */
    HIDDEN: string
    /**
     * VISIBLE
     */
    VISIBLE: string
    /**
     * REVEALED
     */
    REVEALED: string
}

/**
 * GAMEMODE: BASE
 * RALLY LAUNCH CONTEXT
 */
declare interface RALLY_LAUNCH_CONTEXT {
    /**
     * PLAYER_STRUCTURE
     */
    PLAYER_STRUCTURE: any
    /**
     * PIGLIN_BUILD
     */
    PIGLIN_BUILD: any
    /**
     * PIGLIN_DAMAGE
     */
    PIGLIN_DAMAGE: any
}

/**
 * GAMEMODE: campaign
 * Attack faction sieger barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SiegerBarracksConfig_AttackFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
    /**
     * act1_a
     */
    act1_a: any
    /**
     * act1_c
     */
    act1_c: any
}

/**
 * GAMEMODE: campaign
 * Attack faction sieger barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SiegerBarracksConfig_AttackFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * SiegerBarracksConfig_DBBFaction
 */
declare interface SiegerBarracksConfig_DBBFaction {
    /**
     * name
     */
    name: any
    /**
     * act1_a
     */
    act1_a: any
    /**
     * act1_b
     */
    act1_b: any
    /**
     * act1_c
     */
    act1_c: any
    /**
     * darkBeacon
     */
    darkBeacon: any
    /**
     * piglin_act1_non_portal_attack_base
     */
    piglin_act1_non_portal_attack_base: any
}

/**
 * GAMEMODE: campaign
 * Defend faction sieger barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SiegerBarracksConfig_DefendFaction {
    /**
     * name
     */
    name: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * frontlineA
     */
    frontlineA: any
}

/**
 * GAMEMODE: Demo_Gamescom
 * Defend faction sieger barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SiegerBarracksConfig_DefendFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * Obstacle faction sieger barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SiegerBarracksConfig_ObstacleFaction {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
}

/**
 * GAMEMODE: campaign
 * Obstacle faction sieger barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SiegerBarracksConfig_ObstacleFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: campaign
 * SiegerBarracksConfig_WOFFaction
 */
declare interface SiegerBarracksConfig_WOFFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
}

/**
 * GAMEMODE: BASE
 * Names for World-Gen Slots.
 */
declare interface SLOT {
    /**
     * BASE
     */
    BASE: string
    /**
     * OB_MA_ZOMBIE
     */
    OB_MA_ZOMBIE: string
    /**
     * OB_MA_SKELETON
     */
    OB_MA_SKELETON: string
    /**
     * OB_MA_CREEPER
     */
    OB_MA_CREEPER: string
}

/**
 * GAMEMODE: campaign
 * Attack faction specialist barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SpecialistBarracksConfig_AttackFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
    /**
     * boss
     */
    boss: any
}

/**
 * GAMEMODE: Demo_Gamescom
 * Defend faction specialist barracks config for village variations, used by helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface SpecialistBarracksConfig_DefendFaction_Variations {
    /**
     * name
     */
    name: any
    /**
     * frontlineA
     */
    frontlineA: any
    /**
     * small
     */
    small: any
    /**
     * medium
     */
    medium: any
    /**
     * large
     */
    large: any
}

/**
 * GAMEMODE: BASE
 * Status effect IDs.
 */
declare interface STATUS_EFFECT {
    /**
     * FEARED
     */
    FEARED: string
    /**
     * CLEANSE
     */
    CLEANSE: string
}

/**
 * GAMEMODE: BASE
 * Acceptable values for the `team_outlines` map key.
 */
declare interface TEAM_OUTLINES {
    /**
     * DISABLED
     */
    DISABLED: string
    /**
     * ENABLED
     */
    ENABLED: string
}

/**
 * GAMEMODE: BASE
 * List of telemetry action types for buildings.
 */
declare interface TELEMETRY_ACTION_TYPE {
    /**
     * CONSTRUCT
     */
    CONSTRUCT: string
    /**
     * DECONSTRUCT
     */
    DECONSTRUCT: string
    /**
     * DESTROYED
     */
    DESTROYED: string
}

/**
 * GAMEMODE: BASE
 * TELEMETRY_CAMPAIGN_PROGRESS
 */
declare interface TELEMETRY_CAMPAIGN_PROGRESS {
    /**
     * MOUNT_PROGRESS
     */
    MOUNT_PROGRESS: any
    /**
     * TOWER_PROGRESS
     */
    TOWER_PROGRESS: any
    /**
     * POI_ALLY_PROGRESS
     */
    POI_ALLY_PROGRESS: any
    /**
     * MOB_ALLIANCE_PROGRESS
     */
    MOB_ALLIANCE_PROGRESS: any
    /**
     * PIGLIN_BASE_PROGRESS
     */
    PIGLIN_BASE_PROGRESS: any
    /**
     * PIGLIN_OUTPOST_PROGRESS
     */
    PIGLIN_OUTPOST_PROGRESS: any
    /**
     * WELL_OF_FATE_VISITS_PROGRESS
     */
    WELL_OF_FATE_VISITS_PROGRESS: any
    /**
     * WELL_OF_FATE_UPGRADES_PROGRESS
     */
    WELL_OF_FATE_UPGRADES_PROGRESS: any
    /**
     * VILLAGE_CHEST_OPENS_PROGRESS
     */
    VILLAGE_CHEST_OPENS_PROGRESS: any
    /**
     * FAST_TRAVEL_PROGRESS
     */
    FAST_TRAVEL_PROGRESS: any
    /**
     * DAY_NIGHT_CYCLE_PROGRESS
     */
    DAY_NIGHT_CYCLE_PROGRESS: any
    /**
     * VILLAGE_OCCUPIED_PROGRESS
     */
    VILLAGE_OCCUPIED_PROGRESS: any
    /**
     * VILLAGE_CLEARED_PROGRESS
     */
    VILLAGE_CLEARED_PROGRESS: any
    /**
     * MOB_ALLIANCE_OCCUPIED_PROGRESS
     */
    MOB_ALLIANCE_OCCUPIED_PROGRESS: any
    /**
     * MOB_ALLIANCE_CLEARED_PROGRESS
     */
    MOB_ALLIANCE_CLEARED_PROGRESS: any
    /**
     * SPAWNER_PLACED_PROGRESS
     */
    SPAWNER_PLACED_PROGRESS: any
    /**
     * SPAWNER_INTERACT_SPAWN_PROGRESS
     */
    SPAWNER_INTERACT_SPAWN_PROGRESS: any
    /**
     * SPAWNER_INTERACT_REMOVE_PROGRESS
     */
    SPAWNER_INTERACT_REMOVE_PROGRESS: any
}

/**
 * GAMEMODE: BASE
 * List of telemetry categories. Anyone can freely add/remove categories here.
 */
declare interface TELEMETRY_CATEGORIES {
    /**
     * POI_LOOT
     */
    POI_LOOT: string
    /**
     * POI_TOWER
     */
    POI_TOWER: string
    /**
     * FUNNEL
     */
    FUNNEL: string
    /**
     * KEY_ACTION_COMPLETED
     */
    KEY_ACTION_COMPLETED: string
    /**
     * CAMPAIGN_PROGRESS
     */
    CAMPAIGN_PROGRESS: string
    /**
     * INVASION_BREAK_STARTED
     */
    INVASION_BREAK_STARTED: string
    /**
     * INVASION_BREAK_ENDED
     */
    INVASION_BREAK_ENDED: string
    /**
     * INVASION_ATTACK_CONCLUDED
     */
    INVASION_ATTACK_CONCLUDED: string
}

/**
 * GAMEMODE: BASE
 * Telemetry dictionary specifically for the MountFunnel event.
 */
declare interface TELEMETRY_FUNNEL_STEP {
    /**
     * MOUNT
     */
    MOUNT: any
}

/**
 * GAMEMODE: BASE
 * reusable names for telemetry gameact to keep things consistent
 */
declare interface TELEMETRY_GAMEACT_IDS {
    /**
     * ACT1A
     */
    ACT1A: number
    /**
     * ACT1B
     */
    ACT1B: number
    /**
     * ACT2
     */
    ACT2: number
    /**
     * ACT3A
     */
    ACT3A: number
    /**
     * ACT3B
     */
    ACT3B: number
    /**
     * EPILOGUE
     */
    EPILOGUE: number
}

/**
 * GAMEMODE: BASE
 * Telemetry for invasion.
 */
declare interface TELEMETRY_INVASION {
    /**
     * GV_INVASION_BREAK_ACTIVE
     */
    GV_INVASION_BREAK_ACTIVE: string
}

/**
 * GAMEMODE: BASE
 * TELEMETRY_KEY_ACTION_COMPLETED_CATEGORIES
 */
declare interface TELEMETRY_KEY_ACTION_COMPLETED_CATEGORIES {
    /**
     * POI_ALLY_01
     */
    POI_ALLY_01: string
    /**
     * POI_ALLY_02
     */
    POI_ALLY_02: string
    /**
     * POI_ALLY_04
     */
    POI_ALLY_04: string
    /**
     * POI_ALLY_05
     */
    POI_ALLY_05: string
}

/**
 * GAMEMODE: BASE
 * Names of mob alliances for telemetry use.
 */
declare interface TELEMETRY_MOB_ALLIANCE_NAMES {
    /**
     * creeper
     */
    creeper: string
    /**
     * skeleton
     */
    skeleton: string
    /**
     * zombie
     */
    zombie: string
    /**
     * mount01
     */
    mount01: string
    /**
     * mount01Lure
     */
    mount01Lure: string
    /**
     * mount03
     */
    mount03: string
    /**
     * mount03Lure
     */
    mount03Lure: string
    /**
     * mount04
     */
    mount04: string
    /**
     * mount04Lure
     */
    mount04Lure: string
    /**
     * ally01
     */
    ally01: string
    /**
     * ally01Piece01
     */
    ally01Piece01: string
    /**
     * ally01Piece02
     */
    ally01Piece02: string
    /**
     * ally02
     */
    ally02: string
    /**
     * ally02Piece01
     */
    ally02Piece01: string
    /**
     * ally04
     */
    ally04: string
    /**
     * ally04Piece01
     */
    ally04Piece01: string
    /**
     * ally05
     */
    ally05: string
    /**
     * ally05Piece01
     */
    ally05Piece01: string
    /**
     * tower01
     */
    tower01: string
    /**
     * tower02
     */
    tower02: string
    /**
     * tower04
     */
    tower04: string
}

/**
 * GAMEMODE: BASE
 * Valid onboarding step names for telemetry
 */
declare interface TELEMETRY_ONBOARDING_CATEGORIES {
    /**
     * GATHERING
     */
    GATHERING: string
    /**
     * LEAVE_WELL_OF_FATE
     */
    LEAVE_WELL_OF_FATE: string
    /**
     * FIND_VILLAGE_UNDER_ATTACK
     */
    FIND_VILLAGE_UNDER_ATTACK: string
    /**
     * FIRST_VILLAGE_UNDER_ATTACK
     */
    FIRST_VILLAGE_UNDER_ATTACK: string
    /**
     * REPAIR_FOUNTAIN
     */
    REPAIR_FOUNTAIN: string
    /**
     * FIND_SECOND_VILLAGE
     */
    FIND_SECOND_VILLAGE: string
    /**
     * FREE_SECOND_VILLAGE
     */
    FREE_SECOND_VILLAGE: string
    /**
     * BUILD_DEFENSES_IN_SECOND_VILLAGE
     */
    BUILD_DEFENSES_IN_SECOND_VILLAGE: string
    /**
     * FIRST_SKIRMISH
     */
    FIRST_SKIRMISH: string
    /**
     * THREE_PIGLIN_CAMPS
     */
    THREE_PIGLIN_CAMPS: string
    /**
     * WOF_UPGRADE
     */
    WOF_UPGRADE: string
    /**
     * SECOND_SKIRMISH
     */
    SECOND_SKIRMISH: string
    /**
     * DESTROY_DBB
     */
    DESTROY_DBB: string
    /**
     * MENU
     */
    MENU: string
    /**
     * SPAWN_FIRST_GOLEM
     */
    SPAWN_FIRST_GOLEM: string
    /**
     * SPAWN_SECOND_GOLEM
     */
    SPAWN_SECOND_GOLEM: string
    /**
     * LURE
     */
    LURE: string
    /**
     * UNLURE
     */
    UNLURE: string
    /**
     * DIRECT
     */
    DIRECT: string
    /**
     * WORLDMAP
     */
    WORLDMAP: string
    /**
     * RESOURCE_DROP
     */
    RESOURCE_DROP: string
    /**
     * FIND_FIRST_BASE
     */
    FIND_FIRST_BASE: string
    /**
     * FIND_SECOND_BASE
     */
    FIND_SECOND_BASE: string
    /**
     * FIND_DBB
     */
    FIND_DBB: string
    /**
     * DESTROY_FIRST_BASE
     */
    DESTROY_FIRST_BASE: string
    /**
     * DESTROY_SECOND_BASE
     */
    DESTROY_SECOND_BASE: string
}

/**
 * GAMEMODE: BASE
 * List of telemetry subcategories. Anyone can freely add/remove categories here.
 */
declare interface TELEMETRY_SUBCATEGORIES {
    /**
     * PIGLIN_CRATE
     */
    PIGLIN_CRATE: string
    /**
     * TREASURE_CHEST
     */
    TREASURE_CHEST: string
    /**
     * VILLAGE_CHEST
     */
    VILLAGE_CHEST: string
    /**
     * KNOCKBACK_TOWER
     */
    KNOCKBACK_TOWER: string
    /**
     * FREEZE_TOWER
     */
    FREEZE_TOWER: string
    /**
     * STUN_TOWER
     */
    STUN_TOWER: string
}

/**
 * GAMEMODE: BASE
 * Keys that identify textures on placement slots.
 */
declare interface TEXTURE_KEYS {
    /**
     * PRIMARY
     */
    PRIMARY: string
    /**
     * OB_BIOME
     */
    OB_BIOME: string
}

/**
 * GAMEMODE: challenge_pack_2_TimedDefense
 *
 */
declare interface TimerConfig {
    /**
     * defenseTime
     */
    defenseTime: number
}

/**
 * GAMEMODE: BASE
 * Campaign treasure chest data
 */
declare interface TREASURE_CHEST_CAMPAIGN_DATA {
    /**
     * globalIndex
     */
    globalIndex: string
    /**
     * messagePrefix
     */
    messagePrefix: string
    /**
     * telemetryType
     */
    telemetryType: string
    /**
     * telemetrySubcategory
     */
    telemetrySubcategory: any
    /**
     * chooseRandom
     */
    chooseRandom: boolean
    /**
     * isWeighted
     */
    isWeighted: boolean
    /**
     * useAvailabilityRestrictions
     */
    useAvailabilityRestrictions: boolean
    /**
     * phaseMultiplier
     */
    phaseMultiplier: []
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 * TREASURE_CHEST_CAMPAIGN_DATA_HARD
 */
declare interface TREASURE_CHEST_CAMPAIGN_DATA_HARD {
    /**
     * phaseMultiplier
     */
    phaseMultiplier: []
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 *
 */
declare interface TREASURE_CHEST_CAMPAIGN_DATA_NORMAL {
    /**
     * phaseMultiplier
     */
    phaseMultiplier: []
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 * TREASURE_CHEST_CAMPAIGN_DATA_PEACEFUL
 */
declare interface TREASURE_CHEST_CAMPAIGN_DATA_PEACEFUL {
    /**
     * phaseMultiplier
     */
    phaseMultiplier: []
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: BASE
 * PvP treasure chest data
 */
declare interface TREASURE_CHEST_PVP_DATA {
    /**
     * globalIndex
     */
    globalIndex: string
    /**
     * messagePrefix
     */
    messagePrefix: string
    /**
     * telemetryType
     */
    telemetryType: string
    /**
     * telemetrySubcategory
     */
    telemetrySubcategory: any
    /**
     * chooseRandom
     */
    chooseRandom: boolean
    /**
     * useAvailabilityRestrictions
     */
    useAvailabilityRestrictions: boolean
    /**
     * rewardTable
     */
    rewardTable: []
    /**
     * rewardTableUncapped
     */
    rewardTableUncapped: []
}

/**
 * GAMEMODE: challenge_pack_1_TimedBaseDestruction
 * Trigger volume event. Used for `SetupPiglinBase()`
 */
declare interface TV_EVENT {
    /**
     * ENTER
     */
    ENTER: number
    /**
     * EXIT
     */
    EXIT: number
}

/**
 * GAMEMODE: challenge_pack_1_TimedBaseDestruction
 * Trigger volume type. Used for `SetupPiglinBase()`
 */
declare interface TV_TYPE {
    /**
     * BOUNDS
     */
    BOUNDS: number
    /**
     * AREA
     */
    AREA: number
}

/**
 * GAMEMODE: BASE
 * VILLAGE_BEHAVIOR entities
 */
declare interface VILLAGE_BEHAVIOR {
    /**
     * villager
     */
    villager: any
    /**
     * illager
     */
    illager: any
}

/**
 * GAMEMODE: BASE
 * VILLAGE_TEMP_BEHAVIOR_STATE states
 */
declare interface VILLAGE_TEMP_BEHAVIOR_STATE {
    /**
     * HEAVY_SCARED
     */
    HEAVY_SCARED: string
    /**
     * SCARED
     */
    SCARED: string
    /**
     * GREET
     */
    GREET: string
    /**
     * HEAVY_CHEER
     */
    HEAVY_CHEER: string
    /**
     * CHEER
     */
    CHEER: string
}

/**
 * GAMEMODE: campaign
 * Final faction vindicator barracks config for helper functions in `aaaa_piglin_base_helpers.js`
 */
declare interface VindicatorBarracksConfig_wofFaction {
    /**
     * name
     */
    name: any
    /**
     * wofBase
     */
    wofBase: any
}

// FILE CONTENTS: bsharp_api_filters.gen.d.ts


/**
 * Filters entities by only returning alive entities not in the process of being destroyed
 * @returns The alive entities
 *
 * @param entities The entities to filter.
 */
declare function FILTER_ByAlive(entities: number[]): number[]

/**
 * Filters entities and gets the entities which are closest from a given entity.
 * @returns Entities closest to the target.
 *
 * @param entities The entities to filter.
 * @param closest The singular entity group to check against.
 * @param count How many of the closest entities to keep.
 */
declare function FILTER_ByClosest(entities: number[], closest: number, count: number): number[]

/**
 * Filters entities to only entities that are within a certain distance of
 * another entity.
 * @returns The entities that are within the distance to the center entity.
 *
 * @param entities The entities to filter.
 * @param center The entity to use as the center point for distance checking.
 * @param distance The distance threshold to filter by.
 */
declare function FILTER_ByDistance(entities: number[], center: number, distance: number): number[]

/**
 * Filters entities based on the name of their owning faction.
 * @returns The entities that are owned by the faction.
 *
 * @param entities The entities to filter.
 * @param factionNames The names of the factions to filter on.
 */
declare function FILTER_ByFactionName(entities: number[], factionNames: string[]): number[]

/**
 * Filters entities and gets the entities which are furthest from a given entity.
 * @returns Entities furthest to the target.
 *
 * @param entities The entities to filter.
 * @param anchorEntity The singular entity group to check against.
 * @param count How many of the furthest entities to keep.
 */
declare function FILTER_ByFarthest(entities: number[], anchorEntity: number, count: number): number[]

/**
 * Filters entities that has a creator.
 *
 * @param entities The entities to ilter.
 */
declare function FILTER_ByHasCreator(entities: number[]): number[]

/**
 * Filters entities to only entities that have a specific amount of remaining health. Eg. more than 20, less than 100.
 * @returns The entities that have remaining health above (or below) the given threshold.
 *
 * @param entities The entities to filter.
 * @param threshold Health remaining of the entity.
 * @param aboveThreshold Should the filter be checking if the health is above the threshold or below it.
 */
declare function FILTER_ByHealth(entities: number[], threshold: number, aboveThreshold: boolean): number[]

/**
 * Filters entities to only entities that have a specific amount of remaining health. Eg. more than 20%, less than 100%.
 * @returns The entities that have remaining health above (or below) the given percentage.
 *
 * @param entities The entities to filter.
 * @param threshold Value between 0 and 100 that indicates the percentage of total health remaining that the entity has.
 * @param aboveThreshold Should the filter be checking if the health is above the percentage or below it.
 */
declare function FILTER_ByHealthPercentage(entities: number[], threshold: number, aboveThreshold: boolean): number[]

/**
 * Filters entities to only entities that are children of a specified entity.
 * @returns The entities whose parent is parentEntity.
 *
 * @param entities The entities to filter.
 * @param parent The parent entity to apply the filter with.
 */
declare function FILTER_ByParent(entities: number[], parent: number): number[]

/**
 * Filters entities based off of tags.
 * @returns The entities that satisfy the tag constraints.
 *
 * @param entities The entities to filter.
 * @param includeTags The list of tags the entity must have.
 * @param excludeTags The list of tags the entity must not have.
 */
declare function FILTER_ByTagFilter(entities: number[], includeTags: string[], excludeTags: string[]): number[]

/**
 * Filters entities to only entities that belong to a specific team.
 * @returns The entities that are members of the team.
 *
 * @param entities The entities to filter.
 * @param teamName The name of the team to filter for.
 */
declare function FILTER_ByTeam(entities: number[], teamName: string): number[]

/**
 * Filters an existing entity group to entities that belong to a village.
 * @returns The entities that are owned by the village.
 *
 * @param entities The entities to filter.
 * @param villageId The village ID entities must belong to.
 */
declare function FILTER_ByVillageID(entities: number[], villageId: number): number[]

/**
 * Filters entities based on the size of their owning village.
 *
 * @param entities The entities to filter.
 * @param villageSizes The valid sizes to permit through the filter.
 */
declare function FILTER_ByVillageSize(entities: number[], villageSizes: string[]): number[]

/**
 * Filter village entities to see if they are part of an invasion.
 *
 * @param entities The entities.
 * @param isParticipant Return entities in an invasion or not.
 */
declare function FILTER_InvasionParticipant(entities: number[], isParticipant: boolean): number[]

/**
 * Filters out any entities that are an engineer AND occupied at the moment.
 *
 * @param entities The entities.
 */
declare function FILTER_OutOccupiedEngineers(entities: number[]): number[]

/**
 * Get some randomly selected entities from a set of entities.
 * @returns Randomly selected entities.
 *
 * @param entities The entities to filter.
 * @param count How many entities should be selected. Should be less or equal to the number of provided entities.
 */
declare function FILTER_RandomCount(entities: number[], count: number): number[]

/**
 * Randomly select a percentage of entities from a given set of entities.
 * @returns Randomly selected entities.
 *
 * @param entities The entities to filter.
 * @param percent The percentage of entities to take. Must be between 0 and 100.
 */
declare function FILTER_RandomPercentage(entities: number[], percent: number): number[]


// FILE CONTENTS: bsharp_api_foreach.gen.d.ts


/**
 * Perform the snippet's logic on all entities instantly.
 * @see LISTENFOR_ForEachEntity
 * @see SNIPPET_ForEachEntity
 * @returns FOREACH ID to be used with LISTENFOR_ForEachEntity
 *
 * @param entities All entities that the snippet's logic should be performed on.
 */
declare function FOREACH_AllInstant(entities: number[]): number

/**
 * Perform the snippet's logic on all entities in a ripple out pattern from the center entity.
 * The speed of the ripple is determined by the radius and duration. The ripple originates from the center and reaches the end of the radius when the duration has elapsed.
 * @see LISTENFOR_ForEachEntity
 * @see SNIPPET_ForEachEntity
 * @returns FOREACH ID to be used with LISTENFOR_ForEachEntity
 *
 * @param entities All entities that the snippet's logic should be performed on.
 * @param centerEntity The origin of the ripple.
 * @param radius Determines the circular Area of Effect around the center entity. Entities outside this area are excluded.
 * @param duration Determines the speed of the ripple.
 */
declare function FOREACH_RippleOut(entities: number[], centerEntity: number, radius: number, duration: number): number


// FILE CONTENTS: bsharp_api_functions.gen.d.ts


/**
 * Add Entities to the nearest control group with the specfied tags
 *
 * @param villageId Owning village
 * @param Entities Entities to add to the group
 * @param ControlGroupTags Include tags for which control group entities to retrieve.
 */
declare function AddEntitiesToNearestControlGroup(villageId: number, Entities: number[], ControlGroupTags: string[]): void

/**
 * Spawn a trigger volume and register it to both LISTENFOR_SpatialPartitionEntered and LISTENFOR_SpatialPartitionExited (optional). NOTE: This will stretch the trigger volume on he Z axis
 *
 * @param buildableEg The building entity to add the trigger volume to
 * @param triggerVolumeId The badger id of the trigger volume
 * @param triggerVolumeEnteredSnippetName The spatial partition entered snippet name
 * @param triggerVolumeExiteddSnippetName The spatial partition exited snippet name
 * @param triggerIncludeTags The tags that the entities that trigger the tags must have
 * @param triggerExcludeTags The tags that the entities that trigger the tags must NOT have
 * @param alliance The alliance filter (eg. `ALLIANCE_FRIENDLY`, `ALLIANCE_ANY`)
 * @param payloadString Optional string to give to the listeners.
 */
declare function AddTriggerVolumeToBuildable(buildableEg: number[], triggerVolumeId: string, triggerVolumeEnteredSnippetName: string, triggerVolumeExiteddSnippetName: string, triggerIncludeTags: string[], triggerExcludeTags: string[], alliance: string, payloadString: string): void

/**
 * Displays a custom message to all teams dependent if they are allied or enemies to a reference team.
 *
 * @param messageFriendly The message to show to friendly teams.
 * @param messageEnemy The message to show to enemy teams.
 * @param friendlyteam The reference team.
 */
declare function AnnounceTeamsHelper(messageFriendly: string, messageEnemy: string, friendlyteam: string): void

/**
 * Assigns entities to a specified AI
 *
 * @param villageId Owning village
 * @param Entities Entities to assign to the ai
 * @param AiData Ai config data
 */
declare function AssignEntitiesToAI(villageId: number, Entities: number[], AiData: object): any

/**
 * Assigns entities to a control group
 *
 * @param Entities Entities to assign
 * @param ControlGroup Control group entity
 */
declare function AssignToGroup(Entities: number[], ControlGroup: number): any

/**
 * Assigns entities to a random tagged control group
 *
 * @param villageId Owner Village
 * @param Entities Entities to assign
 * @param ControlGroupTag Tag to filter control group
 */
declare function AssignToRandomTaggedGroup(villageId: numberr, Entities: number[], ControlGroupTag: string): any

/**
 * A village building card.
 * Returns a portal buildable card based on size.
 *
 * @param size The base size.
 */
declare function BuildablePortalCard(size: string): string[]

/**
 * A village building card.
 * Returns a buildable card.
 *
 * @param type The card name.
 * @param count The number of copies.
 */
declare function BuildCard(type: string, count: number): string[]

/**
 * DEPRECATED: Use BuildablePortalCard instead.
 *
 * @param size The base size.
 */
declare function BuildPortalCard(size: string): string[]

/**
 * Checks if village generation is complete (all planned builings finished).
 * Used for testing. Does **NOT** return anything.
 *
 * 
 */
declare function CheckVillageGenerationComplete(): void

/**
 * Choose from an array randomly. (non-deterministic)
 *
 * @param array An array.
 */
declare function ChooseFromArray(array: any[]): any

/**
 * Choose a random element from the given array. Elements with higher weights are chosen more often.
 * All elements must have a 'weight' property or this function simply returns the first element.
 *
 * @param array Array of elements to choose from.
 */
declare function ChooseFromWeightedArray(array: Element[]): Element

/**
 * Clamp a number between two other numbers
 *
 * @param number The number to clamp
 * @param minVal Minimum Value
 * @param maxVal Maximum Value
 */
declare function Clamp(number: number, minVal: number, maxVal: number): number

/**
 * Return the closest entity from an array of entities.
 * To get an array of entities @see FILTER_ByClosest
 *
 * @param entities The array of entities to filter through.
 * @param referenceEntity The reference entity used to get the closest entity.
 */
declare function ClosestEntity(entities: number[], referenceEntity: number): number

/**
 * DEPRECATED
 *
 * @param nameList DEPRECATED
 * @param factionData DEPRECATED
 * @param baseSize DEPRECATED
 */
declare function CreateBaseGenMiniDecks(nameList: string[], factionData: any, baseSize: string): any

/**
 * Makes a build deck.
 * TODO: Please ask Funky S. for details.
 *
 * @param nameList The mini-deck names to use.
 * @param factionData The faction data object.
 * @param baseSize The base size.
 * @param villageId The village to associate this build deck with
 */
declare function CreateBuildableGenMiniDecks(nameList: string[], factionData: any, baseSize: string, villageId: number): any

/**
 * Makes a build deck for a specific base size (No layering)
 *
 * @param nameList The mini-deck names to use.
 * @param factionData The faction data object.
 * @param baseSize The base size.
 * @param villageId The village to associate this build deck with
 */
declare function CreateBuildableGenMinidecksForSize(nameList: string[], factionData: any, baseSize: string, villageId: number): any

/**
 * Creates a new control group entity on the specified position with a specifried tag
 * @returns The newly created control group entity.
 *
 * @param villageId the village that owns the control group
 * @param ControlGroupPositionEntity the position to create the control group on
 * @param ControlGroupTag Optional: Tag to add to this control group entity
 */
declare function CreateControlGroupEntity(villageId: number, ControlGroupPositionEntity: number[], ControlGroupTag: string): number

/**
 * CreatePathFromZoneRequestOnBottomOf
 *
 * @param type
 * @param pathStartArrayOfRules
 * @param destDeck
 */
declare function CreatePathFromZoneRequestOnBottomOf(type: any, pathStartArrayOfRules: any, destDeck: any): any

/**
 * CreatePathRequestOnBottomOf
 *
 * @param type
 * @param pathStartArrayOfRules
 * @param pathEndArrayOfRules
 * @param destDeck
 */
declare function CreatePathRequestOnBottomOf(type: any, pathStartArrayOfRules: any, pathEndArrayOfRules: any, destDeck: any): any

/**
 * DEBUG ONLY.
 * Helper to register a B# slash command. 
 * Becareful of using this in a save file as the internal snippet name may not match.
 *
 * @param eventName The slash command name. eg. `/bsharp event eventName`
 * @param callback The function to execute.
 */
declare function DEBUG_Event(eventName: string, callback: callback): void

/**
 * DEBUG ONLY.
 * Helper to register a recurring loop.
 * Becareful of using this in a save file as the internal snippet name may not match.
 *
 * @param initialDelay If a number is used the initial delay in seconds. If a string is used the slash command name to begin.
 * @param loopDelay The recurring delay in seconds.
 * @param callback The function to execute. Return true to stop, otherwise a return is not necessary.
 */
declare function DEBUG_Loop(initialDelay: any, loopDelay: number, callback: callback): void

/**
 * Like `OUTPUT_DebugLogDeck` but only logs the first n cards.
 * The original deck is not changed.
 *
 * @param deck The deck to log.
 * @param includeSubCards Include subcards in the log?
 * @param count The number of cards to log from the top.
 */
declare function DebugLogDeckCount(deck: number[][][], includeSubCards: boolean, count: number): void

/**
 * Debugs a string (currently using OUTPUT_Announce)
 *
 * @param stringToOutput Debug message to output
 * @param shouldDoOutput Boolean to define if the message will be outputed or not.
 */
declare function DebugOutput(stringToOutput: string, shouldDoOutput: boolean): void

/**
 * Count how many cards the deck have
 *
 * @param deck The deck to be count
 */
declare function DECK_Count(deck: string[]): number

/**
 * Draw cards from the bottom of the deck
 *
 * @param deck The name of the library of cards.
 * @param count Number of cards to draw.
 */
declare function DECK_DrawFromBottom(deck: string[], count: number): string[]

/**
 * Draw cards from the top of the deck
 *
 * @param deck The name of the library of cards.
 * @param count Number of cards to draw.
 */
declare function DECK_DrawFromTop(deck: string[], count: number): string[]

/**
 * Duplicates an existing deck.
 *
 * @param deck The deck to duplicate.
 */
declare function DECK_DuplicateDeck(deck: string[]): string[]

/**
 * Return an empty deck
 *
 * 
 */
declare function DECK_Empty(): string[]

/**
 * Gets the library index. Don't use this unless you know what you're doing.
 *
 * @param library The library name.
 */
declare function DECK_GetLibraryIndexFromName(library: string): number

/**
 * Makes a deck with all cards that have a value greater than a threshold.
 *
 * @param library The library name.
 * @param threshold The threshold for the card score.
 */
declare function DECK_MakeDeckFromLibraryValueGreaterEqual(library: string, threshold: number): string[]

/**
 * Makes a deck with all cards that have a value less than a threshold.
 *
 * @param library The library name.
 * @param threshold The threshold for the card score.
 */
declare function DECK_MakeDeckFromLibraryValueLess(library: string, threshold: number): string[]

/**
 * Makes a deck with all cards that have a value less or equal than a threshold.
 *
 * @param library The library name.
 * @param threshold The threshold for the card score.
 */
declare function DECK_MakeDeckFromLibraryValueLessEqual(library: string, threshold: number): string[]

/**
 * TODO: What does this function do? Please ask Funky S.
 *
 * @param library The library name.
 * @param deck TODO: What does this param do? Please ask Funky S.
 * @param filter A tag the card must have.
 */
declare function DECK_MakeFromDeckFiltered(library: string, deck: string[], filter: string): string[]

/**
 * Make a deck with all the cards from a library
 *
 * @param library The name of the library of cards.
 */
declare function DECK_MakeFromLibrary(library: string): string[]

/**
 * Make a deck with all the cards from a library filtered by a tag
 *
 * @param library The name of the library of cards.
 * @param filter The filter tag.
 */
declare function DECK_MakeFromLibraryFiltered(library: string, filter: string): string[]

/**
 * Make a deck with all the cards from a library filtered by a tag and make multiple copies of it
 *
 * @param library The name of the library of cards.
 * @param filter The filter tag.
 * @param copies The number of copies from the filtered deck you want.
 */
declare function DECK_MakeFromLibraryFilteredWithCopies(library: string, filter: string, copies: number): string[]

/**
 * Make a deck with all the cards from a library that have a have a value greater than the given threshold
 *
 * @param library The name of the library of cards.
 * @param threshold The treshold number the values will be checked against
 */
declare function DECK_MakeFromLibraryValueGreater(library: string, threshold: number): string[]

/**
 * Apply a set of rule cards to each card in the original deck.
 *
 * @param originalDeck The original deck to modify.
 * @param arrayOfRules An array of rule cards.
 */
declare function DECK_MultiplyByMultipleRules(originalDeck: string[], arrayOfRules: string[][]): void

/**
 * Apply a rule card to each card in the orignal deck.
 *
 * @param originalDeck The original deck to modify.
 * @param singleDeck The deck (card) to apply
 */
declare function DECK_MultiplyBySingle(originalDeck: string[], singleDeck: string[]): void

/**
 * Put a deck on the middle of another deck. The moving deck will no longer have any card left
 *
 * @param movingDeck The deck that will be on the middle of the existim deck.
 * @param existingDeck The deck that will receive the moving deck.
 */
declare function DECK_PutInMiddleOf(movingDeck: string[], existingDeck: string[]): void

/**
 * Put a deck on the bottom of another deck. The moving deck will no longer have any card left
 *
 * @param movingDeck The deck that will be on the bottom of the existim deck.
 * @param existingDeck The deck that will receive the moving deck.
 */
declare function DECK_PutOnBottomOf(movingDeck: string[], existingDeck: string[]): void

/**
 * Put a deck on the top of another deck. The moving deck will no longer have any card left
 *
 * @param movingDeck The deck that will be on the top of the existing deck deck.
 * @param existingDeck The deck that will receive the moving deck.
 */
declare function DECK_PutOnTopOf(movingDeck: string[], existingDeck: string[]): void

/**
 * Filters out a deck randomly to ensure the total value is below the budget.
 *
 * @param libraryName The library name.
 * @param deck The deck (not the deck name).
 * @param budget The budget.
 */
declare function DECK_ReduceToBudget(libraryName: string, deck: string[], budget: number): string[]

/**
 * Shuffle the deck
 *
 * @param deck The name of the library of cards.
 */
declare function DECK_Shuffle(deck: string[]): void

/**
 * Split an existing deck into multiple decks and returns an array of smaller decks
 *
 * @param deckToSplit The deck that will be split
 * @param timesToSplit The number of time the deck will be split.
 */
declare function DECK_Split(deckToSplit: string[], timesToSplit: number): string[]

/**
 * Stack two decks and return a new stacked deck
 *
 * @param top The deck that will be on the top of the new deck.
 * @param bottom The deck that will be on the bottom of the new deck.
 */
declare function DECK_Stack(top: string[], bottom: string[]): string[]

/**
 * Get the total value of a deck based on the library values
 *
 * @param libraryName library names that contain the card values
 * @param deck The deck
 */
declare function DECK_TotalValue(libraryName: string, deck: string[]): number

/**
 * Reduces a global variable value by 1 or the optional param decrementValue.
 * @returns The global variable's new value.
 *
 * @param variable The global variable key.
 * @param decrementValue (optional) Defaults to 1, the value to decrement the GV by.
 */
declare function DecrementGlobal(variable: string, decrementValue: number = 1): number

/**
 * Announce a message after a delay.
 *
 * @param message The message to display.
 * @param delay The wait time before displaying the message.
 */
declare function DelayedAnnounce(message: string, delay: number): void

/**
 * Announce a message after a delay, for a specified duration.
 *
 * @param message The message to display.
 * @param delay The wait time before displaying the message.
 */
declare function DelayedAnnounceTimed(message: string, delay: number): void

/**
 * Play a global audio after a delay.
 *
 * @param eventName The audio event name.
 * @param delay The delay in seconds.
 */
declare function DelayedAudio(eventName: string, delay: number): void

/**
 * Despawn entities after a delay.
 *
 * @param entities The entities to despawn.
 * @param delay The delay in seconds.
 * @param villageId The village ID.
 */
declare function DelayedDespawn(entities: number[], delay: number, villageId: number): void

/**
 * Destroy entities after a delay.
 *
 * @param entities The entities to destroy.
 * @param delay The delay in seconds.
 * @param villageId The village ID
 */
declare function DelayedDestroy(entities: number[], delay: number, villageId: number): void

/**
 * Add or minus an amount to a village varible.
 *
 * @param villageId The village ID
 * @param key The global variable key
 * @param delta The amount to change the global variable by. Can be negative.
 */
declare function DeltaVillageVariable(villageId: number, key: string, delta: number): void

/**
 * Despawns roaming piglin spawners near a point of reference.
 *
 * @param pointOfReference Entity used to measure distance to roaming piglin spawners.
 */
declare function DespawnNearbyRoamingSpawners(pointOfReference: number): void

/**
 * Destroys a list of entities within a given duration.
 *
 * @param entities The entities to destroy.
 * @param totalDespawnDuration The duration to destroy everything in.
 * @param initialDelay The initial delay before anything is destroyed. Not included in duration.
 * @param villageId The village ID.
 */
declare function DestroyStaggered(entities: number[], totalDespawnDuration: number, initialDelay: number, villageId: number): void

/**
 * Distributes entities to a list of entity groups according to supplied percentages
 *
 * @param Entities The entities to split up
 * @param Percentages The percentages to split to each group
 */
declare function DistributeEntities(Entities: number[], Percentages: number[]): number[][]

/**
 * Allow a snippet to run every n seconds only. Put this check at the top of your snippet with a unique key.
 * @returns true if not on cooldown, false if on cooldown.
 *
 * @param cooldown The cooldown in seconds.
 * @param globalKey The unique global variable key.
 * @param villageId The village ID of the listener.
 */
declare function DoIfNotOnCooldown(cooldown: number, globalKey: string, villageId: number): boolean

/**
 * Do a code chunk once based off a global key. The global key is automatically set afterwards.
 * @returns true if never executed, false if executed.
 *
 * @param globalKey The global variable key
 */
declare function DoOnce(globalKey: string): boolean

/**
 * Do a code chunk once based off a tutorial flag. The tutorial flag is automatically set afterwards.
 * Please note that the flag must be present in `gameresources.json`
 * @returns true if never executed, false if executed.
 *
 * @param name The tutorial key to check/set
 */
declare function DoTutorialFlagOnce(name: string): boolean

/**
 * Enables fast travel at a village and sets its village variable to 1
 *
 * @param villageId The ID of the village
 */
declare function EnableFastTravelForVillage(villageId: number): void

/**
 * Ends the match if it hasn't already been ended. This will trigger snippets that are listening for
 * @see LISTENFOR_GlobalVariableChanged with the variable @see GAME_MODE_GLOBAL.matchEnded
 * Will also call @see OUTPUT_EndMatch
 *
 * @param winningTeam The team that won the match.
 */
declare function EndMatch(winningTeam: string): void

/**
 * Moves an entity to the destination ignoring all influencers.
 *
 * @param entities The entities to move
 * @param destinationEntity The target entity to follow
 * @param padding The distance from the target destination to stop
 */
declare function ForceMoveEntities(entities: number[], destinationEntity: number, padding: number): void

/**
 * Moves an entity to the destination ignoring all influencers.
 *
 * @param entities The entities to move
 * @param destinationEntity The position entity to go to.
 * @param padding The distance from the target destination to stop
 */
declare function ForceMoveEntitiesPosition(entities: number[], destinationEntity: number, padding: number): void

/**
 * Execute some logic for each alive village entity in the game.
 *
 * @param callback The function to call.
 */
declare function ForEachAliveVillageEntity(callback: callback): void

/**
 * Iterate through control groups that have the specfied tags
 *
 * @param villageId village owning the control groups
 * @param ControlGroupTags Include tags for selecting control group
 * @param Callback callback to execute on each rallygroup
 */
declare function ForEachControlGroupWithTags(villageId: number, ControlGroupTags: string[], Callback: callback): void

/**
 * Iterate through an entity group, avoid doing this when possible
 *
 * @param Entities Entities to iterate through
 * @param Callback callback to execute on each entity
 */
declare function ForEachEntities(Entities: number[], Callback: callback): any

/**
 * Iterates through each rally point in a village
 *
 * @param villageId Village ID
 * @param rallyName Rally Name
 * @param checkOnlyEnabled Check only enabled rally points
 * @param callback The callback function
 */
declare function ForEachRallyPoint(villageId: number, rallyName: string, checkOnlyEnabled: bool, callback: callback): void

/**
 * Usage for 'generate_all_village_factions_sizes_perf' test only!
 * Generates the next village in the sequence
 *
 * 
 */
declare function GenerateNextVillage(): void

/**
 * Gets an ai entity that is owned by a village
 *
 * @param villageId the village that owns the ai entity
 * @param AiData ai entity configuration data
 */
declare function GetAiEntity(villageId: number, AiData: object): any

/**
 * Get's all the alive villages in the game that belong to any faction in 'factions' and of any size in 'sizes'.
 * Set factions or sizes to undefined to ignore filtering.
 *
 * @param factions The factions to include. Set as undefined to accept all factions.
 * @param sizes The village sizes to include. Set as undefined to accept all sizes.
 */
declare function GetAliveVillages(factions: string[], sizes: string[]): number[]

/**
 * Generates all permutations according to provided input
 *
 * @param ...sets Sets for which to generate permutations for.
 */
declare function GetAllPermutations(...sets: object[]): object[]

/**
 * Get all the player entities(dead or alive) in the world. 
 * If dead the player will not have a position.
 *
 * 
 */
declare function GetAllPlayers(): number[]

/**
 * Return all the spawn points of the village portal.
 *
 * @param villageId the id of the village
 */
declare function GetAllVillagePortalSpawnLocation(villageId: number): number[]

/**
 * Get all the village entities (dead or alive) belonging to a faction with a specific size. 
 *
 * @param factions A list of valid factions.
 * @param sizes A list of valid village sizes.
 */
declare function GetAllVillages(factions: string[], sizes: string[]): number[]

/**
 * Gets the closest player to an entity.
 *
 * @param referenceEntity The reference entity
 */
declare function GetClosestPlayer(referenceEntity: number): number

/**
 * Takes a time and returns a time of day that's closest to it.
 *
 * @param time
 */
declare function GetClosestTimeOfDay(time: number): number

/**
 * Get Control group entities with tags
 *
 * @param villageId Owning village
 * @param rallyPointTags Tags that are assigned to the control entities
 */
declare function GetControlGroupEntities(villageId: number, rallyPointTags: string[]): number[]

/**
 * Gets the culture level from a culture value.
 * Note the culture level starts at 0 (no thresholds met).
 *
 * @param cultureValue The culture value (A) of a village.
 */
declare function GetCultureLevelFromValue(cultureValue: number): number

/**
 * Gets the culture level for a village.
 * Note the culture level starts at 0 (no thresholds met).
 *
 * @param villageId The village ID.
 */
declare function GetCultureLevelFromVillage(villageId: number): number

/**
 * Get all the village entities (dead only) belonging to a faction with a specific size. 
 *
 * @param factions A list of valid factions.
 * @param sizes A list of valid village sizes.
 */
declare function GetDeadVillages(factions: string[], sizes: string[]): number[]

/**
 * Returns entities that have the specified tags and belong to the given village.
 *
 * @param tags The list of tags the entity must have.
 * @param villageId The village ID the entity must belong to.
 */
declare function GetEntitiesWithTagsAndVillage(tags: string[], villageId: number): number[]

/**
 * Get a global variable for a game rule.
 *
 * @param ruleName The name of the rule.
 */
declare function GetGameRuleVariable(ruleName: string): number

/**
 * Finds an instance entity by name to create a trigger volume from and returns it.
 *
 * @param instanceName The name of the instance entity to get. Should be unique (only one entity in the game with this instance name).
 * @param team The name of the team to assign the trigger volume to.
 * @param villageId The village that owns this trigger volume. Pass as undefined to not associate the trigger volume with a village.
 * @param stretchVertically Maximally stretch the trigger volume bounds in the up-down direction?
 * @param includeTags The tags of things we want to detect as intruders.
 * @param excludeTags The tags of things we don't want to detect as intruders even if they satisfy includeTags.
 * @param alliance The alliance filter (eg. `ALLIANCE_FRIENDLY`, `ALLIANCE_ANY`)
 */
declare function GetInstanceTriggerVolume(instanceName: string, team: string, villageId: number, stretchVertically: boolean, includeTags: string[], excludeTags: string[], alliance: string): number

/**
 * Finds an instance entity by name to create a trigger volume from and returns it.
 *
 * @param instanceName The name of the instance entity to get. Should be unique (only one entity in the game with this instance name).
 * @param team The name of the team to assign the trigger volume to.
 * @param villageId The village that owns this trigger volume. Pass as undefined to not associate the trigger volume with a village.
 * @param stretchVertically Maximally stretch the trigger volume bounds in the up-down direction?
 * @param triggerTags The tagsets to use to detect intruders. Given as an array of dictionaries of include/exclude tags. eg. [{include: ["player"], exclude: []}, {include: ["mob"], exclude: ["piglin"]}]
 */
declare function GetInstanceTriggerVolumeWithMultipleTagsets(instanceName: string, team: string, villageId: number, stretchVertically: boolean, triggerTags: any[]): number

/**
 * Retrieves the mount data corresponding to the given mount entity.
 *
 * @param mount Mount entity.
 */
declare function GetMountDataFromMountEntity(mount: number[]): object

/**
 * Return a percentage of the netities assigned to a control group
 *
 * @param ControlGroup Control Group Entity
 * @param Percentage Percentage of units to get
 */
declare function GetPercentUnitsFromGroup(ControlGroup: number, Percentage: number): number[]

/**
 * Return a percentage of the netities assigned to a control group using it's tag
 *
 * @param villageId Owning village
 * @param ControlGroupTags control group tag
 * @param Percentage Percentage of units to get
 */
declare function GetPercentUnitsFromGroupTags(villageId: number, ControlGroupTags: string[], Percentage: number): number[]

/**
 * Get all campaign units (players and mobs owned by the players).
 *
 * 
 */
declare function GetPlayerAndMobs(): number[]

/**
 * Get entities owned by the player campaign team with the specified tags.
 *
 * @param includeTags A list of tags the entities must have.
 */
declare function GetPlayerOwned(includeTags: string[]): number[]

/**
 * Returns all alive players in the game - excluding dead ones!
 * Returned players are guaranteed to have a position.
 *
 * 
 */
declare function GetPlayers(): number[]

/**
 * Get all buildables owned by the player campaign team.
 *
 * 
 */
declare function GetPlayerStructures(): number[]

/**
 * Get a save/loaded variable associated to a specific player (user).
 *
 * @param playerId The user ID.
 * @param key The variable key.
 */
declare function GetPlayerVariable(playerId: string, key: string): number

/**
 * Get a player variable key for a given player (user).
 *
 * @param playerId The user ID.
 * @param key The variable key.
 */
declare function GetPlayerVariableKey(playerId: string, key: string): string

/**
 * Helper function that "unpacks" the rest parameter to make sure that whatever uses rest parameter has a list to work with.
 * This practically allows anyone to pass both [], []... or [[], []] into functions that take rest parameter.
 *
 * @param restArg Rest Argument (usually written as ...args)
 */
declare function GetRestParameter(restArg: object[]): object[]

/**
 * Retrieves a texture name based on a base's faction and size.
 *
 * @param faction Faction of the base whose stamp to apply.
 * @param size Size fo the base whose stamp to apply
 */
declare function GetStampTextureForFaction(faction: string, size: string): string

/**
 * Looks up a faction-specific stinger for a given event (see PIGLIN_BASE_STINGERS for a complete list of stinger types)
 * Types include:
 * - factionName
 * - hero
 * - tactic
 * - keepGoing
 * - giveUp
 * - danger
 *
 * @param factionName The name of the faction.
 * @param stingerType The type of stinger to play.
 */
declare function GetStingerForPiglinFaction(factionName: string, stingerType: string): string

/**
 * Get Rallygroups with tags
 *
 * @param villageId Owning Village
 * @param includeTags Tags to include
 * @param excludeTags Tags to exclude
 */
declare function GetTaggedGroups(villageId: number, includeTags: string[], excludeTags: string[]): number[]

/**
 * Get a tutorial flag value. Please note that the flag must be present in `gameresources.json`
 * @returns The value of the tutorial flag
 *
 * @param name The name of the tutorial flag
 */
declare function GetTutorialFlag(name: string): boolean

/**
 * Returns only central/vital structures of the village like fountains.
 *
 * @param villageId Village ID
 */
declare function GetVillageCentralStructures(villageId: number): number[]

/**
 * Gets the village entity from a village ID.
 *
 * @param villageId The village ID.
 */
declare function GetVillageEntityFromID(villageId: number): number

/**
 * Gets the village entity from a faction name.
 * This function only works on **single village factions**.
 * May return nothing if the village has not been planned yet.
 *
 * @param factionName The faction name of the village.
 */
declare function GetVillageEntityFromFaction(factionName: string): number

/**
 * Return the fountain of a given village
 *
 * @param villageId The village id
 */
declare function GetVillageFountain(villageId: string): number[]

/**
 * Get a base's potal entity.
 * Portal must not be destroyed. @see QUERY_IsVillageDestroyed
 *
 * @param villageId The village ID of the base.
 */
declare function GetVillagePortal(villageId: number): number[]

/**
 * Get a portals spawn location.
 *
 * @param villageId The village ID.
 */
declare function GetVillagePortalSpawnLocation(villageId: number): number[]

/**
 * Get a "global" variable for a village.
 *
 * @param villageId The village ID the global is attached to.
 * @param key The global variable name to get.
 */
declare function GetVillageVariable(villageId: number, key: string): number

/**
 * Get the "global" village variable key
 *
 * @param villageId The village ID the global is attached to.
 * @param key The global variable name to get.
 */
declare function GetVillageVariableKey(villageId: number, key: string): srting

/**
 * Returns a locator entity for the world center.
 * This may not be the same location as the WoF as the WoF can be offset.
 * This entity will never suspend.
 *
 * 
 */
declare function GetWorldCenter(): number

/**
 * Grants a reward from a loot table. For piglin crate & POI chests.
 *
 * @param player The player to award.
 * @param lootEntity The loot chest entity.
 * @param lootType Type of the loot (treasure chest/piglin crate campaign/pvp)
 */
declare function GrantRewardFromLootTable(player: number, lootEntity: number, lootType: string): void

/**
 * Check if an array of entities has at least one *valid* entity.
 *
 * @param entities An array of entities.
 */
declare function HasEntities(entities: number[]): boolean

/**
 * Returns true if the match has ended, false otherwise.
 *
 * 
 */
declare function HasMatchEnded(): boolean

/**
 * Returns true if the match has been started, false otherwise.
 *
 * 
 */
declare function HasMatchStarted(): boolean

/**
 * Check if we've skipped act 1
 *
 */
declare function HaveWeSkippedAct1(): boolean

/**
 * A village building card.
 * Makes a buildable a Village Heart (ties a buildable to the village lifecycle).
 *
 * 
 */
declare function HeartCard(): string[]

/**
 * Wrapper to specify the horde by the order of arrival rather than name.
 *
 * @param orderNum Order in which horde arrived. 0 - first, 1 - second, etc.
 */
declare function HordeArrived(orderNum: number): number

/**
 * Increment a global variable by 1 or the optional parameter incrementValue.
 * @returns The global variable's new value.
 *
 * @param variable The global variable name.
 * @param incrementValue (optional) Defaults to 1, the value to increment the GV by.
 */
declare function IncrementGlobal(variable: string, incrementValue: number = 1): number

/**
 * Applies an infection buff to the well of fate (@see UninfectWoF)
 *
 * 
 */
declare function InfectWoF(): void

/**
 * Initializes a base's ai and sets up reinforcement rallypoints, this must be called AFTER a base has finished building
 *
 * @param villageId Owning village
 * @param aiConfig Ai config data
 */
declare function InitializeBaseAIs(villageId: number, aiConfig: object): any

/**
 * Interrupt the onboarding objective message
 *
 * @param isCampaignOnboarding is campaign onboarding or basics onboarding
 */
declare function InterruptOnboardingMessage(isCampaignOnboarding: boolean): void

/**
 * Checks if any entity in a group is near a reference entity.
 *
 * @param groupToCheck The entities that must be near the checkAgainst entity.
 * @param checkAgainst The entity to check against.
 * @param distance The distance from the checkAgainst entity
 */
declare function IsAnyNear(groupToCheck: number[], checkAgainst: number, distance: number): boolean

/**
 * Checks if the game is currently in a specific act.
 * Only works in campaign.
 *
 * @param act The act to check. Use constants in `ACTS`.
 */
declare function IsCurrentAct(act: string): boolean

/**
 * Is it daytime (sun above the horizon).
 *
 * 
 */
declare function IsDayTime(): boolean

/**
 * Checks if entity is the player entity by comparing against the full list of player entities.
 *
 * @param entity Entity to check
 */
declare function IsPlayer(entity: number): boolean

/**
 * Checks if a village fountain is disabled
 *
 * @param villageId Village ID
 */
declare function IsVillageFountainDisabled(villageId: number): boolean

/**
 * Lerp between 2 values
 *
 * @param start 1st value
 * @param end 2nd value
 * @param lerpVal The lerp amount
 */
declare function Lerp(start: number, end: number, lerpVal: number): number

/**
 * Log an error message to console (red text).
 *
 * @param message The message/value to log.
 */
declare function Loge(message: string): void

/**
 * Log an info message to console (white text).
 *
 * @param message The message/value to log.
 */
declare function Logi(message: string): void

/**
 * Log a verbose message to console (grey text).
 *
 * @param message The message/value to log.
 */
declare function Logv(message: string): void

/**
 * Log a warning message to console (yellow text).
 *
 * @param message The message/value to log.
 */
declare function Logw(message: string): void

/**
 * Makes a build deck.
 *
 * @param factionData The faction data object.
 * @param baseSize The base size.
 * @param phase The phase.
 */
declare function MakeAbsolutePhaseBuildDeck(factionData: any, baseSize: string, phase: string): string[]

/**
 * Makes a build deck.
 *
 * @param factionData The faction data object.
 * @param baseSize The base size.
 * @param phase The phase.
 */
declare function MakePhaseBuildDeck(factionData: any, baseSize: string, phase: string): string[]

/**
 * Wrapper to specify the mob alliance by the order of arrival rather than name.
 *
 * @param orderNum number
 */
declare function MobAllianceOccupationStarted(orderNum: number): number

/**
 * Calls Once and returns true if the match has ended. Returns false otherwise.
 *
 * 
 */
declare function OnceIfMatchEnded(): boolean

/**
 * Calls Once and returns true if the match has started. Returns false otherwise.
 *
 * 
 */
declare function OnceIfMatchStarted(): boolean

/**
 * Play a presentation event after a given time
 *
 * @param eventName name of the presentaiton event
 * @param delay time to delay
 */
declare function PlayDelayedPresentationToAll(eventName: string, delay: number): void

/**
 * Play a presentation event after a given time
 *
 * @param eventName name of the presentaiton event
 * @param villageId the village to play the delayed action close to
 * @param delay time to delay
 * @param distance distance from the entity, defaults to 300
 */
declare function PlayDelayedPresentationToClosePlayers(eventName: string, villageId: number, delay: number, distance: number): void

/**
 * Plays a delayed sound effect to everyone.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 * @param delay time to delay
 */
declare function PlayDelayedStingerToAll(eventName: string, delay: number): void

/**
 * Plays an sound effect to everyone.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 */
declare function PlayMusicStingerToAll(eventName: string): void

/**
 * Plays an sound effect to specific players.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 * @param players The player entities.
 */
declare function PlayMusicStingerToPlayers(eventName: string, players: number[]): void

/**
 * Plays an sound effect to a specific team.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 * @param team The team name.
 */
declare function PlayMusicStingerToTeam(eventName: string, team: string): void

/**
 * Plays a presentation action to teams.
 *
 * @param messageFriendly The message for the friendly team.
 * @param messageEnemy The message for the opposing team.
 * @param friendlyteam The friendly team name.
 */
declare function PlayPresentationActionTeamsHelper(messageFriendly: string, messageEnemy: string, friendlyteam: string): void

/**
 * Plays a presentation action to all players.
 *
 * @param eventName The event name.
 */
declare function PlayPresentationActionToAll(eventName: string): void

/**
 * Plays a presentation action for all players nearby a given entity.
 *
 * @param eventName The event name.
 * @param pointOfReference The entity used as a point of reference.
 * @param distance The distance from the entity pointOfReference
 */
declare function PlayPresentationActionToClosePlayers(eventName: string, pointOfReference: number, distance: number): void

/**
 * Plays a presentation action to specific players.
 *
 * @param eventName The event name.
 * @param players The players.
 */
declare function PlayPresentationActionToPlayers(eventName: string, players: number[]): void

/**
 * Plays a presentation action to a specific team.
 *
 * @param eventName The event name.
 * @param team The team.
 */
declare function PlayPresentationActionToTeam(eventName: string, team: string): void

/**
 * Play a stinger close to players
 *
 * @param eventName Event string name
 * @param pointOfReference Reference point to play from
 */
declare function PlayStingerToClosePlayers(eventName: string, pointOfReference: number): void

/**
 * Plays a UI action to teams.
 *
 * @param eventFriendly The event name for the friendly team.
 * @param eventEnemy The event name for the opposing team.
 * @param friendlyTeam The friendly team name.
 */
declare function PlayUIActionTeamsHelper(eventFriendly: string, eventEnemy: string, friendlyTeam: string): void

/**
 * Plays a UI action to all players.
 *
 * @param eventName The event name.
 */
declare function PlayUIActionToAll(eventName: string): void

/**
 * Plays a UI action for all players nearby a given entity.
 *
 * @param eventName The event name.
 * @param pointOfReference The entity used as a point of reference.
 */
declare function PlayUIActionToClosePlayers(eventName: string, pointOfReference: number): void

/**
 * Plays a UI action to specific players.
 *
 * @param eventName The event name.
 * @param players The players.
 */
declare function PlayUIActionToPlayers(eventName: string, players: number[]): void

/**
 * Plays a UI action to a specific team.
 *
 * @param eventName The event name.
 * @param team The team.
 */
declare function PlayUIActionToTeam(eventName: string, team: string): void

/**
 * Displays a custom message to all teams dependent if they are allied or enemies to a reference team.
 *
 * @param messageFriendly Friendly message.
 * @param messageEnemy Enemy message.
 * @param friendlyteam Reference team.
 */
declare function PlayVOTeamsHelper(messageFriendly: string, messageEnemy: string, friendlyteam: string): void

/**
 * Plays an voice over line to everyone.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 */
declare function PlayVOToAll(eventName: string): void

/**
 * Plays an voice over line of sequence to players close to a point of reference
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 * @param pointOfReference An entity to serve as reference to get the players close to it
 */
declare function PlayVOToClosePlayers(eventName: string, pointOfReference: number[]): void

/**
 * Plays an voice over line to specific players.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 * @param players The player entities.
 */
declare function PlayVOToPlayers(eventName: string, players: number[]): void

/**
 * Plays an voice over line to a specific team.
 *
 * @param eventName Audio asset ID. See `sound_definitions.json` in resource packs.
 * @param team The specific team.
 */
declare function PlayVOToTeam(eventName: string, team: string): void

/**
 * Automatically registers buildings as a rally point.
 *
 * @param villageId The village ID.
 * @param tag The building tag.
 * @param name The rally name.
 */
declare function RALLYMAN_AutoRegisterRallyPoints(villageId: number, tag: string, name: string): void

/**
 * Auto-trigger a rally point on unit count.
 * Declared out of a snippet.
 *
 * @param uniqueHandlerName The handler name used in `RALLYMAN_ListenForComponent`
 * @param callback The function to call.
 */
declare function RALLYMAN_DeclareCompositionHandler(uniqueHandlerName: string, callback: callback): void

/**
 * Auto-trigger a rally point on cooldown.
 * Declared out of a snippet.
 *
 * @param uniqueHandlerName The handler name used in `RALLYMAN_ListenForCooldown`
 * @param callback The function to call.
 */
declare function RALLYMAN_DeclareCooldownHandler(uniqueHandlerName: string, callback: callback): void

/**
 * Auto-trigger a rally point on a specific unit composition count.
 * Declared out of a snippet.
 *
 * @param uniqueHandlerName The handler name used in `RALLYMAN_ListenForSpecificComposition`
 * @param compositionInfo An array of objects containing the tag filter and required unit count.
 * @param callback The function to call.
 */
declare function RALLYMAN_DeclareSpecificCompositionHandler(uniqueHandlerName: string, compositionInfo: any, callback: callback): void

/**
 * Disables patrols between rally points of a given name. Piglins currently patrolling between rally points will continue to move toward
 * their destination, but will not patrol again from the destination rally point. Calling this function will remove the timer listeners
 * on the rally points, but this will happen next tick. As such, it is advised to avoid disabling and re-enabling patrols on the same tick.
 *
 * @param villageId Id of the village containing rally points
 * @param rallyPointName The name of the rally points to stop patrolling between.
 */
declare function RALLYMAN_DisablePatrols(villageId: number, rallyPointName: string): void

/**
 * Disables rally points
 *
 * @param villageId Village ID
 * @param rallyName Rally Name
 * @param amount Amount to disable
 */
declare function RALLYMAN_DisableRallyPoints(villageId: number, rallyName: string, amount: number): void

/**
 * Enables patrols between rally points of a given name. Only piglins that are marked to participate in patrols will move between rally points.
 *
 * @param villageId Id of the village containing the rally points.
 * @param rallyPointName Name of the rally points to start patrolling between.
 */
declare function RALLYMAN_EnablePatrols(villageId: number, rallyPointName: string): void

/**
 * Enables rally points
 *
 * @param villageId Village ID
 * @param rallyName Rally Name
 * @param amount Amount to disable
 */
declare function RALLYMAN_EnableRallyPoints(villageId: number, rallyName: string, amount: number): void

/**
 * Get enabled rally points
 *
 * @param villageId Village ID
 * @param rallyName Rally Name
 */
declare function RALLYMAN_GetEnabledRallyPoints(villageId: number, rallyName: string): number[]

/**
 * Gets all the rally point entities for a rally name.
 *
 * @param villageId The village ID.
 * @param name The rally name.
 */
declare function RALLYMAN_GetRallyPoints(villageId: number, name: string): number[]

/**
 * Gets all the units at a rally point.
 *
 * @param villageId The village ID.
 * @param rallyPoint The rally name.
 */
declare function RALLYMAN_GetUnitsFromRallyPoint(villageId: number, rallyPoint: number): number[]

/**
 * Initializes a village to use the rally point system.
 * Required if the village uses any RALLYMAN function.
 *
 * @param villageId The village ID.
 * @param rallyPointsInfo An array of objects containing rally point information. eg. `[ { name: "rallyA", accmulations: 5, count: 2 } ]`
 */
declare function RALLYMAN_Initdata(villageId: number, rallyPointsInfo: any): void

/**
 * Finds the closest rally point with enough units and launches evenly to several targets.
 * Returns an array of the sent units (corresponding to the `targetInfos` array).
 *
 * @param villageId The village ID.
 * @param rallyName The rally name.
 * @param count The number of rally points to send.
 * @param referenceEntity The reference entity for the closest entity check.
 * @param threshold The threshold of units the rally point must contain.
 * @param context Audio context for a rally man response
 * @param targetInfos An array of objects containing target information.
 */
declare function RALLYMAN_LaunchClosestNamedRallyPointsWithThreshold(villageId: number, rallyName: string, count: number, referenceEntity: number, threshold: number, context: object, targetInfos: TargetInfo[]): number[][]

/**
 * Finds the closest rally point with enough units and launches evenly to several targets.
 * Returns an array of the sent units (corresponding to the `targetInfos` array).
 *
 * @param villageId The village ID.
 * @param rallyPoints The rally point entities.
 * @param count The number of rally points to send.
 * @param referenceEntity The reference entity for the closest entity check.
 * @param threshold The threshold of units the rally point must contain.
 * @param context Audio context for a rally man response
 * @param targetInfos An array of objects containing target information.
 */
declare function RALLYMAN_LaunchClosestRallyPointsWithThreshold(villageId: number, rallyPoints: number[], count: number, referenceEntity: number, threshold: number, context: object, targetInfos: TargetInfo[]): number[][]

/**
 * Launches units at a rally point evenly to several targets.
 * Returns an array of the sent units (corresponding to the `targetInfos` array).
 *
 * @param villageId The village ID.
 * @param rallyPoint The rally point entity.
 * @param context Audio context for a rally man response
 * @param targetInfos An array of objects containing target information.
 */
declare function RALLYMAN_LaunchRallyPointAtTargets(villageId: number, rallyPoint: number, context: object, targetInfos: TargetInfo[]): number[][]

/**
 * Auto-trigger a rally point on unit count.
 *
 * @param uniqueHandlerName The handler name used in `RALLYMAN_DeclareCompositionHandler`
 * @param rallyPoint The rally point entity.
 * @param requiredUnitCount Threshold before auto-triggering.
 */
declare function RALLYMAN_ListenForComposition(uniqueHandlerName: string, rallyPoint: number, requiredUnitCount: number): void

/**
 * Auto-trigger a rally point on cooldown.
 *
 * @param uniqueHandlerName The handler name used in `RALLYMAN_DeclareCooldownHandler`
 * @param rallyPoint The rally point entity.
 * @param cooldown Time limit before auto-triggering.
 */
declare function RALLYMAN_ListenForCooldown(uniqueHandlerName: string, rallyPoint: number, cooldown: number): void

/**
 * Auto-trigger a rally point on unit composition.
 *
 * @param uniqueHandlerName The handler name used in `RALLYMAN_DeclareSpecificCompositionHandler`
 * @param rallyPoint The rally point entity.
 */
declare function RALLYMAN_ListenForSpecificComposition(uniqueHandlerName: string, rallyPoint: number): void

/**
 * Marks the given unit entities with a tag which allows them to participate in patrols between rally points.
 *
 * @param unitEntities Unit entities to mark for partrol participation.
 */
declare function RALLYMAN_MarkUnitsForPatrol(unitEntities: number[]): void

/**
 * Assigns entities to rally points evenly under a rally name.
 *
 * @param villageId The village ID.
 * @param name The rally name.
 * @param entities The units to recruit.
 */
declare function RALLYMAN_RecruitSpawnedUnit(villageId: number, name: string, entities: number[]): void

/**
 * Assigns entities spawned by a spawner to rally points evenly under a rally name.
 *
 * @param villageId The village ID.
 * @param name The rally name.
 * @param spawnerEntity The spawner entity.
 */
declare function RALLYMAN_RecruitSpawnerOutput(villageId: number, name: string, spawnerEntity: number): void

/**
 * Assigns entities rally points evenly under a rally name AFTER a time delay (use this to re-rally units once they've left)
 *
 * @param villageId The village ID.
 * @param name The rally name.
 * @param entities The units to recruit.
 * @param delay Time delay
 */
declare function RALLYMAN_RecruitUnitsAfterDelay(villageId: number, name: string, entities: number[], delay: number): void

/**
 * Registers an entity as a rally point.
 * Returns the rally point entity.
 *
 * @param villageId The village ID.
 * @param entity The entity to make a rally point.
 * @param name The rally name.
 */
declare function RALLYMAN_RegisterAsRallyPoint(villageId: number, entity: number, name: string): number

/**
 * Registers an entity as a rally point up to the rally count.
 * Returns the rally point entity or empty entities if unable to.
 *
 * @param villageId The village ID.
 * @param entity The entity to make a rally point.
 * @param name The rally name.
 */
declare function RALLYMAN_TryRegisterAsCappedRallyPoint(villageId: number, entity: number, name: string): number

/**
 * Return a random entity from an array of entities.
 * To get an array of entities @see FILTER_RandomCount or @see FILTER_RandomPercentage
 *
 * @param entities The array of entities to filter through.
 */
declare function RandomEntity(entities: number[]): number

/**
 * Return a random number (int) between the interval
 *
 * @param min The min value that can be returned.
 * @param max The max value that can be returned.
 */
declare function RandomIntFromInterval(min: number, max: number): number

/**
 * Return a random number specific to the worldgen RNG group.
 * 
 * If you're looking for RNG unrelated to worldgen, avoid using this as it may affect reproducibility of various seeds.
 *
 * @param min The minimum range of the RNG number to return.
 * @param max The maxiuminm RNG number to return, inclusive
 */
declare function RandomNumWorldGen(min: number, max: number): number

/**
 * Returns random entities from an entity group up to a count.
 *
 * @param entities The original entity group.
 * @param count The desired count.
 */
declare function RandomUpToCount(entities: number[], count: number): number[]

/**
 * Recruits a spawners output to the ai rally reinforcement system
 *
 * @param villageId Owner village
 * @param ControlGroupTag Tag for the desired control group(s) that will recruit this spawner's output.
 * @param spawnerEntity Spawning structure
 */
declare function RecruitSpawnerOutput(villageId: number, ControlGroupTag: string, spawnerEntity: number): void

/**
 * Binds the lifetime of some entities to another one.
 *
 * @param ownerVillageId The owner village ID.
 * @param lifetimeEntity The lifetime entity.
 * @param destructionEntities The entities to destroy if the lifetime entity is destroyed.
 */
declare function RegisterForCleanup(ownerVillageId: number, lifetimeEntity: number, destructionEntities: number[]): void

/**
 * Remove an entity from a control group
 *
 * @param Entities Entities to remove from the group
 * @param ControlGroup Control group entity
 */
declare function RemoveFromGroup(Entities: number[], ControlGroup: number): any

/**
 * Resets the testing parameters for `GenerateAllVillageFactionSizes.js` test.
 * **DO NOT CALL THIS FUNCTION OUT OF THAT FILE**
 *
 * 
 */
declare function ResetTestingParameters(): void

/**
 * Returns a resource object containing an entry for `.name` and `.amount`
 *
 * @param name The resource ID.
 * @param amount The number of resources.
 */
declare function Resource(name: string, amount: number): object

/**
 * Set the waypoint icon state of the entity
 *
 * @param entity The entity in question
 * @param id The waypoint icon id (POI_WAYPOINT_ICON_DICTIONARY)
 * @param iconState the icon state  (POI_WAYPOINT_ICON_STATE)
 */
declare function SetEntityWaypointIconState(entity: number[], id: string, iconState: string): void

/**
 * Set a global variable for a game rule.
 *
 * @param ruleName The name of the rule.
 * @param value The value to assign.
 */
declare function SetGameRuleVariable(ruleName: string, value: VariantData): void

/**
 * Sets the illager behavior mode.
 *
 * @param illagerEG The villager entity group.
 */
declare function SetIllagerBehavior(illagerEG: number[]): void

/**
 * Set the state of the mount world spawners
 *
 * @param spawnersActive if the world spawner is active or not
 */
declare function SetMountWorldSpawnerState(spawnersActive: boolean): void

/**
 * Set a save/loaded variable associated to a specific player (user).
 *
 * @param playerId The user ID.
 * @param key The variable key.
 * @param value The value to save.
 */
declare function SetPlayerVariable(playerId: string, key: string, value: number): void

/**
 * Helper to set a given team's resource to a specific amount (not additive!)
 *
 * @param team Team name whose resource to adjust.
 * @param resource Name of the resource to manipulate.
 * @param amount The new amount of the resource.
 */
declare function SetResourceForTeam(team: string, resource: string, amount: number): void

/**
 * Resets the testing parameters for `GenerateAllVillageFactionSizes.js` test.
 * **DO NOT CALL THIS FUNCTION OUT OF THAT FILE**
 *
 * 
 */
declare function SetTimerForNextVillage(): void

/**
 * Sets a tutorial flag. Please note that the flag must be present in `gameresources.json`
 *
 * @param name The name of the tutorial flag
 * @param enabled A boolean value to set the tutorial flag to
 */
declare function SetTutorialFlag(name: string, enabled: boolean): void

/**
 * Sets up ai functionality and snippets. This must be called outside of any snippets
 *
 * @param AiRootConfig Ai configuration data
 */
declare function SetupBaseAIs(AiRootConfig: object): any

/**
 * Setup the basic clearing entities on the villages
 *
 * @param mainDeck the main deck of the village
 */
declare function SetupBasicVillageClearingCards(mainDeck: number[]): void

/**
 * Setup a piglin base to automatically fire telemetry events.
 * To be used in conjunction with `SetupDefaultTelemetryForPiglinBaseTriggerVolume`
 * **Must be called in the global scope.**
 * @see TelemetrySendEnemyBasePiglinEnterEvent
 * @see TelemetrySendEnemyBasePiglinExitEvent
 *
 * @param factionName The faction name of the piglin base.
 */
declare function SetupDefaultTelemetryForPiglinBase(factionName: string): void

/**
 * Setup telemetry handlesr for POI towers.
 *
 * @param name The tower telemetry name.
 * @param subCategory The telemetry subcategory.
 * @param timesConstructedGlobalVar The global variable for the number of times this tower has been constructed.
 * @param timesDeconstructedGlobalVar The global variable for the number of times this tower has been deconstructed.
 */
declare function SetupDefaultTelemetryForTowerPOI(name: string, subCategory: string, timesConstructedGlobalVar: string, timesDeconstructedGlobalVar: string): void

/**
 * Setup reinforcement control groups to be used by the ai. This is automatically called by aiInitialize but can be disabled and called manually.
 *
 * @param villageId Owner village
 * @param AiData The data for the ai to assign the reinforcements too
 */
declare function SetupReinforcementControlGroups(villageId: number, AiData: object): any

/**
 * Sets up things that a village needs in order to properly determine its current behavior, i.e. proximity volumes
 *
 * @param fountain The village fountain.
 * @param villageId The village ID.
 */
declare function SetupVillageBehavior(fountain: number, villageId: number): void

/**
 * Sets up the default village audio entity.
 *
 * @param villageId The village ID.
 * @param override An optional emitter state override.
 */
declare function SetVillageAudioDefault(villageId: number, override: string): void

/**
 * Refreshes a village's behavior.
 *
 * @param villageId The village ID.
 */
declare function SetVillageBehavior(villageId: number): void

/**
 * Updates the behaviour of a villager.
 *
 * @param villagerEG The villager entities.
 */
declare function SetVillagerBehavior(villagerEG: number[]): void

/**
 * Sets a temporary behavior for a village. These behaviors are defined in @see VILLAGE_TEMP_BEHAVIOR_STATE
 *
 * @param villageId The village ID.
 * @param behaviorState @see VILLAGE_TEMP_BEHAVIOR_STATE
 * @param duration The duration of the temporary behavior
 */
declare function SetVillageTemporaryBehavior(villageId: number, behaviorState: string, duration: number): void

/**
 * Set a "global" variable for a village.
 *
 * @param villageId The village ID the global is attached to.
 * @param key The global variable name to set.
 * @param value The value to set the variable to.
 */
declare function SetVillageVariable(villageId: number, key: string, value: number): void

/**
 * Show Onboarding Objective message
 *
 * @param message the id of the message to show
 * @param isCampaignOnboarding is campaign onboarding or basics onboarding
 */
declare function ShowOnboardingMessage(message: string, isCampaignOnboarding: boolean): void

/**
 * Shuffles an array randomly (non-deterministic)
 *
 * @param array An array of anything.
 */
declare function ShuffleArray(array: any[]): any[]

/**
 * Spawns one or more of a type of entity at the location of other entities.
 *
 * @param spawnLocationEntities The entities to spawn at. Will spawn at each entity in the group!
 * @param entityArchetype The archetype name of the entities to spawn.
 * @param spawnCount How many entities to spawn. Must be larger than 0.
 * @param team The name of the team to set.
 * @param villageId The id of the village to set the spawned entities to. Pass undefined if you don't want a village and faction to be assigned.
 * @param piglinAppearanceOverride TODO: What does this param do? Ask Daniel S.
 */
declare function SpawnEntitiesAt(spawnLocationEntities: number[], entityArchetype: string, spawnCount: number, team: string, villageId: number, piglinAppearanceOverride: string): number[]

/**
 * Spawns one or more of a type of entity throughout the village.
 *
 * @param entityArchetype The archetype name of the entities to spawn.
 * @param spawnCount How many entities to spawn. Must be larger than 0.
 * @param team The name of the team to set.
 * @param villageId The id of the village to set the spawned entities to. Must be loaded and must be set.
 * @param minRadius Min radius (suggested value: 20)
 * @param maxRadius Max radius (suggested value: 50)
 * @param piglinAppearanceOverride Appearance to set for piglins.
 */
declare function SpawnEntitiesInVillage(entityArchetype: string, spawnCount: number, team: string, villageId: villageId, minRadius: number, maxRadius: number, piglinAppearanceOverride: string): number[]

/**
 * Spawns a standard trigger volume. 
 * Most information is inherited from the position entity.
 *
 * @param positionEntity Where to spawn the trigger volume.
 * @param entityArchetype The trigger volume archetype to spawn.
 * @param includeTags Inclusion tags this trigger volume will filter on.
 * @param excludeTags Exclusion tags this trigger volume will filter on.
 * @param alliance The alliance filter (eg. `ALLIANCE_FRIENDLY`, `ALLIANCE_ANY`)
 */
declare function SpawnStandardTriggerVolume(positionEntity: number, entityArchetype: string, includeTags: string[], excludeTags: string[], alliance: string): void

/**
 * Creates a trigger volume entity and returns it.
 *
 * @param positionEntity The entity to spawn the trigger volume at the position of.
 * @param lifetimeEntity The entity to tie the lifetime of the trigger volume to. Ie. when lifetimeEntity is destroyed, destroy the trigger volume as well.
 * @param entityArchetype The archetype name of the entity to spawn as the trigger volume.
 * @param team The name of the team to assign the trigger volume to.
 * @param villageId The village that owns this trigger volume. Pass as undefined to not associate the trigger volume with a village.
 * @param stretchVertically Maximally stretch the trigger volume bounds in the up-down direction?
 * @param includeTags The tags of things we want to detect as intruders.
 * @param excludeTags The tags of things we don't want to detect as intruders even if they satisfy includeTags.
 * @param alliance The alliance filter (eg. `ALLIANCE_FRIENDLY`, `ALLIANCE_ANY`)
 */
declare function SpawnTriggerVolume(positionEntity: number, lifetimeEntity: number, entityArchetype: string, team: string, villageId: number, stretchVertically: boolean, includeTags: string[], excludeTags: string[], alliance: string): number

/**
 * Creates a trigger volume entity and returns it. Uses multiple tagsets to detect intruders.
 *
 * @param positionEntity The entity to spawn the trigger volume at the position of.
 * @param lifetimeEntity The entity to tie the lifetime of the trigger volume to. Ie. when lifetimeEntity is destroyed, destroy the trigger volume as well.
 * @param entityArchetype The archetype name of the entity to spawn as the trigger volume.
 * @param team The name of the team to assign the trigger volume to.
 * @param villageId The village that owns this trigger volume. Pass as undefined to not associate the trigger volume with a village.
 * @param stretchVertically Maximally stretch the trigger volume bounds in the up-down direction?
 * @param triggerTags The tagsets to use to detect intruders. Given as an array of dictionaries of include/exclude tags. eg. [{include: ["player"], exclude: []}, {include: ["mob"], exclude: ["piglin"]}]
 */
declare function SpawnTriggerVolumeWithMultipleTagsets(positionEntity: number, lifetimeEntity: number, entityArchetype: string, team: string, villageId: number, stretchVertically: boolean, triggerTags: any[]): number

/**
 * Starts the match if it hasn't already been started. This will trigger snippets that are listening for
 * @see LISTENFOR_GlobalVariableChanged with the variable @see GAME_MODE_GLOBAL.matchStarted
 *
 * 
 */
declare function StartMatch(): void

/**
 * Determine which onboarding piglin base has to destroy, and send correct telemetry event for it
 *
 * 
 */
declare function StartPiglinBaseToDestroyOnboarding(): void

/**
 * Start tracking telemetry for a POI tower type.
 *
 * @param name The telemetry name.
 * @param towerTag The tag to uniquely identify this tower type.
 */
declare function StartTrackingTelemetryForTowerPOI(name: string, towerTag: string): void

/**
 * Helper function to swap the mount a player is riding to a new one.
 *
 * @param playerEntity The player entity swapping mounts.
 * @param interactedEntity The mount being interacted with.
 * @param currentMountId Identifier of the player's current mount entity.
 * @param newMountId Identifier of the player's new mount entity.
 * @param swapTeam Team name to assign to the old mount entity.
 */
declare function SwapMounts(playerEntity: number[], interactedEntity: number[], currentMountId: string, newMountId: string, swapTeam: string): void

/**
 * A village building card.
 * Adds a tag to a buildable.
 *
 * @param type The tag card name/tag.
 * @param count The number of copies (should always be 1).
 */
declare function TagCard(type: string, count: number): string[]

/**
 * Send ACT Completed Telemetry
 *
 * @param playerEntity the player
 * @param act the act that was completed
 */
declare function TelemetrySendActCompletedEvent(playerEntity: number[], act: string): void

/**
 * Send ACT Started Telemetry
 *
 * @param playerEntity The player
 * @param act The act that has just started
 */
declare function TelemetrySendActStartedEvent(playerEntity: number[], act: string): void

/**
 * Send Campaign Progress Telemetry
 *
 * @param justCompletedAct The name of the act that was just completed. 'null' if no act was completed.
 */
declare function TelemetrySendCampaignProgressEvent(justCompletedAct: string): void

/**
 * Helper function wrapper for logging a funnel step to telemetry
 *
 * @param playerEntity The player to associate the funnel step
 * @param funnelStepInfo The object data describing the funnel step (see: `FunnelSteps` in `aaaaa_telemetry_helpers.js`)
 */
declare function TelemetrySendFunnelEvent(playerEntity: number, funnelStepInfo: object): void

/**
 * Sends an invasion break started telemetry event.
 *
 * 
 */
declare function TelemetrySendInvasionBreakEndedEvent(): void

/**
 * Sends an invasion break ended telemetry event.
 *
 * 
 */
declare function TelemetrySendInvasionBreakStartedEvent(): void

/**
 * Record a telemetry event when the player completes a key action.
 *
 * @param playerEntity The player entity that completed the action.
 * @param keyActionCompleted The telemetry key.
 */
declare function TelemetrySendKeyActionCompletedEvent(playerEntity: number, keyActionCompleted: string): void

/**
 * Record a telemetry event when the server completes a key action.
 *
 * @param keyActionCompleted The telemetry key.
 */
declare function TelemetrySendKeyActionCompletedServerEvent(keyActionCompleted: string): void

/**
 * Send Mount Funnel Event
 *
 * @param playerEntity the playe entity
 * @param funnelName name of the funnel (e.g.:"mount_01_purple_tiger_A")
 * @param mountName the name of the mount (e.g.:"mount_01_purple_tiger")
 * @param stepName the name of the funnel step (encountered, feeds, unlocked)
 * @param stepCurrentGV global variable with the current funnel step
 * @param maxStep the max number of steps of the funnel (amount needed to feed the mount + encountered + unlocked)
 */
declare function TelemetrySendMountFunnelEvent(playerEntity: number[], funnelName: string, mountName: string, stepName: string, stepCurrentGV: number, maxStep: number): void

/**
 * Send Mount unlocked event.
 *
 * @param playerEntity the player entity.
 * @param mountName the mount name.
 */
declare function TelemetrySendMountUnlockedEvent(playerEntity: number[], mountName: string): void

/**
 * Records a telemetry event when the player collects some loot from a crate/chest.
 *
 * @param playerEntity The player entity.
 * @param name The telemetry name.
 * @param subcategory The telemetry subcategory.
 * @param category The telemetry category.
 */
declare function TelemetrySendPoiLootCollectedEvent(playerEntity: number, name: string, subcategory: string, category: string): void

/**
 * Records a telemetry event when the player interacts with a POI tower.
 *
 * @param playerEntity The player entity.
 * @param interactionType The type of interaction.
 * @param name The telemetry name.
 * @param subcategory The telemetry subcateogry.
 * @param timesConstructed The number of times the tower has been constructed.
 * @param timesDescontructed The number of times the tower has been deconstructd.
 */
declare function TelemetrySendPoiTowerInteractedEvent(playerEntity: number, interactionType: string, name: string, subcategory: string, timesConstructed: number, timesDescontructed: number): void

/**
 * Teleports given entities to the fast travel point of WoF.
 *
 * @param entities Entities to teleport.
 */
declare function TeleportEntitiesToWoF(entities: number[]): void

/**
 * Helper for a test. **DO NOT USE OUT OF TEST ENVIRONMENT**
 *
 * 
 */
declare function TeleportPlayerToNextPosition(): void

/**
 * Initializes flavour test for a particular horde. Must be used ONLY in performance tests in SNIPPET_TestStarted.
 *
 * @param horde Horde name
 * @param testName Name of the flavour test. Must be the same as the one on LISTENFOR_TestStarted
 */
declare function TEST_FlavourTestInit(horde: string, testName: string): void

/**
 * Transfer units from one control group to another
 *
 * @param InitialGroupOwner Initial control group entity
 * @param FinalGroupOwner Final control group entity
 */
declare function TransferGroup(InitialGroupOwner: number, FinalGroupOwner: number): any

/**
 * Transfer Entities to a control group
 *
 * @param InitialGroupEntities Entities to transfer
 * @param FinalGroupOwner Final control group entity
 */
declare function TransferGroupUnits(InitialGroupEntities: number[], FinalGroupOwner: number): any

/**
 * Triggers a celebration.
 *
 * @param entity The central entity.
 * @param celebrationName The celebration name.
 */
declare function TriggerCelebration(entity: number, celebrationName: string): void

/**
 * Trigger a tutorial key for specific players with a delay.
 *
 * @param players The players to trigger the tutorial for
 * @param tutorialKey The tutorial key to use
 * @param delay The delay to apply to the tutorial item
 */
declare function TriggerDelayedTutorialForSpecificPlayersWithDefaultSettings(players: number, tutorialKey: string, delay: number): void

/**
 * Triggers a tutorial key for specific players, with respect to the `gv_do_not_skip_seen_tutorials` global variable.
 *
 * @param players The players to trigger the tutorial for
 * @param tutorialKey The tutorial key to use
 * @param grantRes The resource to grant alongside this item
 * @param bypass Whether to silently mark this tutorial item as complete or not
 * @param skipIfAlreadySeen Whether to skip this tutorial item if we've arleady seen it
 * @param dontMarkCompleted Whether to skip marking this tutorial item as complete
 */
declare function TriggerTutorialForSpecificPlayers(players: number, tutorialKey: string, grantRes: string, bypass: boolean, skipIfAlreadySeen: boolean, dontMarkCompleted: boolean): void

/**
 * Triggers a tutorial key for specific players that are near an entity, with respect to the `gv_do_not_skip_seen_tutorials` global variable.
 *
 * @param entity The entity that the tutorial should trigger near
 * @param tutorialKey The tutorial key to use
 * @param distance The maximum distance from the entity that players will get the tutorial
 * @param grantRes  The resource to grant alongside this item
 * @param bypass Whether to silently mark this tutorial item as complete or not
 * @param skipIfAlreadySeen Whether to skip this tutorial item if we've arleady seen it
 * @param dontMarkCompleted Whether to skip marking this tutorial item as complete
 */
declare function TriggerTutorialForSpecificPlayersNearAnEntity(entity: number, tutorialKey: string, distance: number, grantRes: string, bypass: boolean, skipIfAlreadySeen: boolean, dontMarkCompleted: boolean): void

/**
 * Trigger a tutorial hint and grant the tutorial unlock
 *
 * @param tutorialKey tutorial key
 * @param tutorialHintUnlock unlock resource
 * @param bypassTutorial bypass the tutorial or not
 */
declare function TriggerTutorialHintAndGrantUnlock(tutorialKey: string, tutorialHintUnlock: string, bypassTutorial: boolean): void

/**
 * Removes an infection buff from the Well of Fate (see: @InfectWoF)
 *
 * 
 */
declare function UninfectWoF(): void

/**
 * Unlock a given journal entry
 *
 * @param journalUnlockResource JOURNAL_UNLOCKS Global Variable
 */
declare function UnlockJournalEntry(journalUnlockResource: string): void

/**
 * Used to manually trigger an ai reinforcement wave, usually through unified base response framework.
 *
 * @param villageId Owning village
 * @param AiConfig The main AiConfig
 * @param responseData An object containing: the % of unassigned units to gather, and distribution to each ai
 */
declare function UpdateAiResponseForBase(villageId: number, AiConfig: object, responseData: object): any

/**
* Activates the invasion system (script side).
 *
 * 
 */
declare function ActivateInvasionSystem(): void

/**
* Auto-trigger multiple piglin structures destroyed response as per initialization rules
 * Declared out of a snippet
 *
 * @param snippetName The snippet/handler name
 * @param callback The callback function (param: villageId, last building entity destroyed)
 */
declare function BASE_DeclarePiglinMultipleStructuresDestroyedResponseHandler(snippetName: string, callback: callback): void

/**
* Auto-trigger piglin structure damaged response as per initialization rules
 * Declared out of a snippet
 *
 * @param snippetName The snippet/handler name
 * @param callback The callback function (param: villageId, building entity)
 */
declare function BASE_DeclarePiglinStructureDamagedResponseHandler(snippetName: string, callback: callback): void

/**
* Auto-trigger piglin structure destroyed response as per initialization rules
 * Declared out of a snippet
 *
 * @param snippetName The snippet/handler name
 * @param callback The callback function (param: villageId, building entity)
 */
declare function BASE_DeclarePiglinStructureDestroyedResponseHandler(snippetName: string, callback: callback): void

/**
* Auto-trigger player structure spawned response as per initialization rules
 * Declared out of a snippet
 *
 * @param snippetName The snippet/handler name
 * @param callback The callback function (param: villageId, building entity)
 */
declare function BASE_DeclarePlayerStructureBuiltResponseHandler(snippetName: string, callback: callback): void

/**
* Initialize the piglin multiple structures destroyed response handler
 *
 * @param villageId The village ID
 * @param snippetName The snippet name
 * @param debounceTimer The debounce timer
 * @param structureAmount The amount of structures to be destroyed to trigger this
 * @param structureDataArray An array of objects containing structure data in the format: [ { includeTags (optional): ["a", "b"], excludeTags (optional): ["c"] } ]
 */
declare function BASE_InitPiglinMultipleStructuresDestroyedResponse(villageId: number, snippetName: string, debounceTimer: number, structureAmount: number, structureDataArray: any): void

/**
* Initialize the piglin structure damaged response handler
 *
 * @param villageId The village ID
 * @param structureDataArray An array of objects containing initialization information in the format: [ { snippetName: "snippet", debounceTimer (optional - default 1s): 30, healthThreshold (optional, default 0.99): 0.6, includeTags (optional): ["a", "b"], excludeTags (optional): ["c"] } ]
 */
declare function BASE_InitPiglinStructureDamagedResponse(villageId: number, structureDataArray: any): void

/**
* Initialize the piglin structure damaged response handler
 *
 * @param villageId The village ID
 * @param structureDataArray An array of objects containing initialization information in the format: [ { snippetName: "snippet", debounceTimer (optional - default 1s): 30, includeTags (optional): ["a", "b"], excludeTags (optional): ["c"] } ]
 */
declare function BASE_InitPiglinStructureDestroyedResponse(villageId: number, structureDataArray: any): void

/**
* Initialize the player structure spawned response handler
 *
 * @param villageId The village ID
 * @param structureDataArray An array of objects containing initialization information in the format: [ { snippetName: "snippet", debounceTimer (optional - default 1s): 30, distanceCheck: 200, includeTags (optional): ["a", "b"], excludeTags (optional): ["c"] } ]
 */
declare function BASE_InitPlayerBuiltStructureResponse(villageId: number, structureDataArray: any): void

/**
* Begins Act 1.
 *
 * 
 */
declare function BeginAct1(): void

/**
* Helper function to add the cage buildables to a mob alliance village deck and setup listeners related to them.
 *
 * @param mainDeck Main mob alliance village deck.
 * @param mobId Id of the mob alliance that is caged up.
 * @param villageId Id of the mob alliance village.
 */
declare function BuildMobAllianceCages(mainDeck: string[], mobId: string, villageId: number): void

/**
* Builds a night outpost using the night outpose horde deck
 *
 * 
 */
declare function BuildNightOutpost(): void

/**
* End Campaign Act 2
 *
 * 
 */
declare function CampaignAct2End(): void

/**
* Check and play an invasion action origin point VO (checks if a base is the origin point of an invasion action, then plays associated VO)
 *
 * @param villageId The village ID
 */
declare function CheckAndPlayInvasionActionOriginPointVO(villageId: number): void

/**
* Checks if any horde can enter and does so if conditions are true.
 *
 * @param triggerTime When is this triggered? DAWN, DUSK or IMMEDIATE
 */
declare function CheckAndProgressHordeEntry(triggerTime: string): void

/**
* Checks if any mob alliance occupation can start and does so if conditions are true.
 *
 * @param triggerTime When is this triggered? DAWN, DUSK or IMMEDIATE
 */
declare function CheckAndProgressMobAllianceOccupation(triggerTime: string): void

/**
* Check if act 2 is completely over.
 *
 * 
 */
declare function CheckIfAct2IsOver(): boolean

/**
* Check if a specific base response has been escalated/triggered.
 *
 * @param id The village ID.
 * @param escalationKey The escalation key.
 */
declare function CheckIfVillageIDIsEscalated(id: number, escalationKey: string): boolean

/**
* Places a new claimed area for the given piglin faction.
 * @returns The newly placed claimed area entity -OR- an invalid entity if a new claimed area could not be placed.
 *
 * @param faction Name of the piglin faction claiming the overworld area.
 * @param areaRadius Radius of the area being claimed. Used for placement rules to space this area accordingly.
 */
declare function ClaimInvasionArea(faction: string, areaRadius: number): number

/**
* Create a claimed area for piglins.
 * @returns The claimed area entity.
 *
 * @param horde The piglin horde.
 * @param positionEntity Where to create the claimed area.
 * @param areaRadius The radius of the area.
 */
declare function ClaimPiglinArea(horde: string, positionEntity: number, areaRadius: number): entity

/**
* Claims an initial area on the overworld for a given piglin faction. Also places outposts in the newly claimed area.
 * Used when introducing a new piglin horde to the overworld.
 *
 * @param faction Name of the piglin faction claiming the area.
 */
declare function ClaimPregameAreas(faction: string): void

/**
* Grant any dynamic base loot assigned to a base to the campaign team.
 * @returns Map of rewarded resources for presentation.
 *
 * @param villageId The village ID of the piglin base.
 */
declare function CollectDynamicBaseLoot(villageId: number): object

/**
* Collects village chest rewards from all eligible villages.
 * Returns true if something was collected.
 *
 * @param playerEntity The collecting player entity.
 */
declare function CollectRewardsFromAllVillages(playerEntity: number): boolean

/**
* Debug set a village V2 attack intention.
 *
 * @param horde The piglin horde.
 * @param isMobAllianceAttack If a mob alliance or village village should be targeted.
 */
declare function DAI_DebugSetAttackMobAllianceV2(horde: string, isMobAllianceAttack: boolean): void

/**
* Handled logic for executing village attacks.
 * Version 2: this type of attack does not rely on having a source base planning the attack.
 *
 * @param faction name of the piglin faction attacking the village.
 * @param source village entity being attacked.
 * @param strength Strength of the attack.
 * @param time How long the attack lasts.
 */
declare function DAI_ResolveAttackVillageV2(faction: string, source: number, strength: number, time: number): boolean

/**
* Logic to resolve executing an invasion action for piglins claiming a new area in the overworld.
 * @return 'True' if executing the action was successful. 'False' if not.
 *
 * @param faction Name of the piglin faction executing this action.
 */
declare function DAI_ResolveClaimArea(faction: string): boolean

/**
* Handles logic in response to a delayed 'build_defensive_outpost' action being executed.
 *
 * @param faction Name of the source base's faction.
 */
declare function DAI_ResolveDefensiveOutpost(faction: string): boolean

/**
* Handles logic in response to "establish_horde" action being executed.
 *
 * @param faction Name os the source base's faction.
 */
declare function DAI_ResolveEstablish(faction: string): boolean

/**
* Handles logic in response to a delayed 'build_far_base' action being executed.
 *
 * @param faction Name of the source base's faction.
 */
declare function DAI_ResolveFarBase(faction: string): boolean

/**
* Handles logic in response to a delayed 'build_near_base' action being executed.
 *
 * @param faction Name of the source base's faction.
 */
declare function DAI_ResolveNearBase(faction: string): boolean

/**
* Handles logic in response to a delayed 'build_offensive_outpost' action being executed.
 *
 * @param faction Name of the source base's faction.
 */
declare function DAI_ResolveOffensiveOutpost(faction: string): boolean

/**
* Handles logic in response to a delayed 'oops' action being executed.
 *
 * @param faction Name of the source base's faction.
 * @param target Target base entity
 * @param hidden Whether or not the Oops will only be telegraphed on the map when it occurs.
 */
declare function DAI_ResolveOops(faction: string, target: number, hidden: boolean): boolean

/**
* Handles logic in response to a delayed 'upgrade_base' action being executed.
 *
 * @param faction Name of the source base's faction.
 * @param target Target base entity.
 */
declare function DAI_ResolveUpgradeBase(faction: string, target: number): boolean

/**
* Handles the logic for planning an attack action against a mob alliance village
 * Version 2: This attack will be planned against a village without having a piglin base responsible for the attack.
 *
 * @param faction name of the faction planning the attack.
 */
declare function DAI_SetAttackMobAllianceV2(faction: string): boolean

/**
* Handles the logic for planning an attack action against a villager village
 * Version 2: This attack will be planned against a village without having a piglin base responsible for the attack.
 *
 * @param faction name of the faction planning the attack.
 */
declare function DAI_SetAttackVillageV2(faction: string): boolean

/**
* Handles the logic for planning a boss level attack action against a villager village
 *
 * @param faction name of the horde planning the attack.
 */
declare function DAI_SetAttackVillageV2BossAttack(faction: string): boolean

/**
* Logic for planning invasion action for piglins claiming a new area on the map.
 * @return 'True' if planning the action was successful. 'False' if not.
 *
 * @param faction Name of the piglin faction planning this action.
 * @param selectSource Whether this action should be based from an existing base of the given faction.
 */
declare function DAI_SetClaimArea(faction: string, selectSource: boolean): boolean

/**
* Determines if a 'build_defensive_outpost' invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetDefensiveOutpost(faction: string, selectSource: boolean): boolean

/**
* Determines if an "establish_horde" invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetEstablish(faction: string, selectSource: boolean): boolean

/**
* Determines if a 'build_far_base' invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetFarBase(faction: string, selectSource: boolean): boolean

/**
* Determines if a 'build_near_base' invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetNearBase(faction: string, selectSource: boolean): boolean

/**
* Determines if a 'build_offensive_outpost' invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetOffensiveOutpost(faction: string, selectSource: boolean): boolean

/**
* Determines if an 'oops' invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param hidden If true, this action will not show on the map when being set or thwarted. It will still appear when executed.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetOops(faction: string, hidden: boolean, selectSource: boolean): boolean

/**
* Determines if an 'upgrade_base' invasion action can be planned.
 * If so, sets the action to happen that night.
 *
 * @param faction Name of faction planning the action.
 * @param selectSource Whether or not should generate a base source or be an action with no source (horde-wise action).
 */
declare function DAI_SetUpgradeBase(faction: string, selectSource: boolean): boolean

/**
* Deactivates the invasion system (script side) completely.
 *
 * 
 */
declare function DeactivateInvasionSystem(): void

/**
* Declares the recurring spawner snippets that later will be called on `StartRecurringSpawner`. This function MUST be called outside a snippet at the initialization of the file
 *
 * @param uniqueSpawnerId The unique string id for this recurring spawner
 * @param entityToSpawnId The archetype name of the entity to spawn.. e.g.: `"badger:piglin_runt"`
 * @param recurringTime The time it will take to spawn a new entity after the previous has been killed
 * @param moveLocationTag The tag of the entity the newly spawned entity will move to (can be null). For it to work you have to tag the entity you want this entity to move to with the `moveLocationTag + villageId` tag
 * @param moveToEntityInsteadOfPosition Boolean to define if the entity is going to move to a position (with minimum distance of moveDistanceFromTarget) or to an entity
 * @param moveDistanceFromTarget In the case the move type is to a position the designer can define the distance from the target to stop moving
 * @param recurringSpawnerCallback A callback function called after the entity has been spawned (Optional)
 * @param piglinAppearanceOverride TODO: What does this param do? Ask Daniel S.
 */
declare function DeclareRecurringSpawnerSnippets(uniqueSpawnerId: string, entityToSpawnId: string, recurringTime: number, moveLocationTag: string, moveToEntityInsteadOfPosition: boolean, moveDistanceFromTarget: number, recurringSpawnerCallback: callback, piglinAppearanceOverride: string): void

/**
* Adjust the number of horde cards to draw for planning invasion actions.
 *
 * 
 */
declare function DecrementHordeDraws(): void

/**
* Despawns a base's mob.
 *
 * @param villageId The village ID.
 * @param secondsBetweenDespawns The delay between each despawn.
 */
declare function DespawnPiglinBaseMobs(villageId: number, secondsBetweenDespawns: number): void

/**
* Despawns a base's structures.
 *
 * @param structuresEg The structure entities.
 * @param totalDespawnDuration The total time for everything to be despawned.
 */
declare function DespawnPiglinBaseStructures(structuresEg: number[], totalDespawnDuration: number): void

/**
* Absolutely destroys the given buildings
 *
 * @param entities Buildings to destroy.
 */
declare function DestroyStuffForReal(entities: number[]): void

/**
* Starts the horde arrival sequence after the meet the boss FMV as well as
 * triggers various feedback for the player.
 *
 * @param horde The horde.
 */
declare function DoAfterMeetTheBossActions(horde: string): void

/**
* Draw a single horde card for planning an invasion action. The faction returned in the snippet
 * is indicated by which card was drawn.
 *
 * 
 */
declare function DrawInvasionHordeCard(): void

/**
* Sets up the number of horde cards to draw for planning invasion actions and then starts the drawing process.
 *
 * 
 */
declare function DrawInvasionHordeCards(): void

/**
* Enable WOF nudges
 *
 * @param enabled Whether enabled or not
 */
declare function EnableWofNudges(enabled: boolean): void

/**
* Evaluates all the current known information about invasion and advances the phase.
 *
 * 
 */
declare function EvaluateAndUpdateInvasionPhase(): void

/**
* Cleans up map data and signals the execution of all set invasion actions.
 *
 * 
 */
declare function ExecuteAllInvasionActions(): void

/**
* Removes the occupation state from a village and cleans up the remnents of that state.
 *
 * @param villageId Id of the village under occupation.
 * @param hordeName The occupying horde.
 */
declare function FinishVillageOccupation(villageId: number, hordeName: string): void

/**
* Enforces the specific variation of ONE next base after which returns to normal variation assignment (for the specific type of variation - flavour or objective).
 *
 * @param variationId The id to distinguish which kind of variation to use: @see VARIATION_ID_FLAVOUR and @see VARIATION_ID_OBJECTIVE
 * @param value The specific variation that the next base should feature.
 */
declare function ForceNextBaseVariation(variationId: number, value: string): void

/**
* Gather nearest units and send to specified location
 *
 * @param unitTags The tags that the units must have
 * @param tagsToExclude The tags that the units must not have
 * @param villageId The village ID
 * @param targetEntity The target entity
 * @param percentage Percentage of units to send from filtered units
 * @param tagToAdd Add a tag to selected units
 * @param tagToRemoveFromUnusedGatheredUnits Remove a tag from units that were not selected during percentage choosing
 * @param minUnits Minimum number of units to send
 * @param follow Whether to follow till target is gone
 * @param callback The callback
 */
declare function GatherNearestUnitsAndSendToLocation(unitTags: string[], tagsToExclude: string[], villageId: number, targetEntity: number, percentage: number, tagToAdd: string, tagToRemoveFromUnusedGatheredUnits: string, minUnits: number, follow: boolean, callback: callback): void

/**
* Determines and returns a piglin base that will build a defensive outpost.
 *
 * @param faction Name of the faction attempting to build the outpost.
 */
declare function GenerateDefensiveOutpostSource(faction: string): number

/**
* Determines and returns a piglin base that will build a new base.
 *
 * @param faction Name of the faction attempting to build the new base.
 */
declare function GenerateNewBaseSource(faction: string): number

/**
* Determines and returns a piglin base that will build a new outpost.
 *
 * @param faction Name of the faction attempting to build the new outpost.
 */
declare function GenerateOffensiveOutpostSource(faction: string): number

/**
* Determines and returns a piglin base that will oops.
 *
 * @param faction Name of the faction attempting to oops.
 */
declare function GenerateOopsSource(faction: string): number

/**
* Determines and returns a piglin base that will upgrade.
 *
 * @param faction Name of the faction attempting to upgrade.
 */
declare function GenerateUpgradeBaseSource(faction: string): number

/**
* Used to define a geenric counter given provided variable name, default value and (empty/non-empty) arrays of allowed input.
 * Empty array means input can be anything.
 *
 * @param gvName Global variable name used to count.
 * @param defaultValue Default value assigned from the game start.
 * @param ...allowedInput Any number of [] arrays of allowed input.
 */
declare function GenericCounter(gvName: string, defaultValue: number, ...allowedInput: object[]): number

/**
* Used to defined a snapshot that can record information about the state of counters.
 *
 * @param nameFunc Anonymous function for defining a name for the snapshot.
 */
declare function GenericSnapshot(nameFunc: function): number

/**
* Used to define a trigger that can be used in the staggered entry flow.
 * A trigger consists of expected number when it should trigger, corresponding counter it will check, snapshot to compare against and arrays of extra conditions.
 *
 * @param expectedNum Value of the counter when the trigger should fire.
 * @param counter Corresponding counter to check. Must have same input dimension.
 * @param snapshot Snapshot to compare against. What the expectedNum should be relative to?
 * @param ...input Arays [] of input.
 */
declare function GenericTrigger(expectedNum: number, counter: object, snapshot: object, ...input: object[]): object

/**
* Returns the names of all factions that still have bases.
 *
 * 
 */
declare function GetAliveFactions(): string[]

/**
* Returns all buildings of the given village
 *
 * @param villageId Village ID
 */
declare function GetAllBuildings(villageId: number): number[]

/**
* Returns all the village entities that belong to a friendly faction
 * Currently only considers villager factions.
 *
 * 
 */
declare function GetAllFriendlyVillages(): number[]

/**
* Returns all the village entities that belong to a piglin faction
 * Currently only considers attack, defend, and obstacle factions.
 *
 * 
 */
declare function GetAllInvasionBases(): number[]

/**
* Returns all the mob alliance villages.
 *
 * 
 */
declare function GetAllMobAllianceVillages(): number[]

/**
* Gets the number of attack bases that've been destroyed.
 *
 * 
 */
declare function GetAttackBasesDestroyed(): number

/**
* Gets the Attack Strength based off of values specified in invasion_intentions_attack_village.js
 * Version 2: This version doesn't base the strength off the source base since v2 attacks don't have one.
 *
 * @param horde name of the piglin faction performing the attack.
 */
declare function GetAttackStrengthV2(horde: string): number

/**
* Calculate the attack duration percent for a given strength.
 *
 * @param strength The strength of the attack.
 */
declare function GetAttackTimeV2(strength: number): number

/**
* Retrieves the minimum amount of time (in seconds) for a village attack to last.
 * Can be different between different piglin hordes.
 *
 * @param horde Name of a piglin horde to check min attack time.
 */
declare function GetAttackV2MinSeconds(horde: string): number

/**
* Retrieves the audio entity for a base.
 *
 * @param villageId The village ID of the base.
 * @param overrideTag An optional override tag for specific audio entities.
 */
declare function GetAudioEntityForBase(villageId: number, overrideTag: string[]): number

/**
* Retrieves the flavour deck for given horde and size.
 *
 * @param variationId The id to distinguish which kind of variation to use: @see VARIATION_ID_FLAVOUR and @see VARIATION_ID_OBJECTIVE
 * @param horde Name of the horde
 * @param baseSize Size of the base
 */
declare function GetBaseVariationDefinitionDeck(variationId: number, horde: string, baseSize: string): number[]

/**
* Retrieves the camp slot for act1 piglin spawning based on the village entity based in.
 *
 * @param villageEntity village entity to check for surrounding piglin camp slots.
 */
declare function GetCampPlatementSlotFromVillage(villageEntity: number): StringLiteralLike

/**
* Gets the number of defend bases that've been destroyed.
 *
 * 
 */
declare function GetDefendBasesDestroyed(): number

/**
* Gets the village attack construction & response details for the defend faction.
 *
 * @param baseSize The FOB size.
 */
declare function GetDefendFactionVillageAttackData(baseSize: string): any

/**
* Returns only defensive buildings of the village.
 *
 * @param villageId Village ID
 */
declare function GetDefensiveBuildings(villageId: number): number[]

/**
* Returns the planned invasion action of the piglin base. Empty string if none.
 *
 * @param villageId Piglin base village id.
 */
declare function GetDelayedInvasionAction(villageId: number): string

/**
* Get the initial base configuration for a horde.
 * Affected by difficulty.
 *
 * @param horde The piglin horde.
 */
declare function GetHordeBasesSetupConfig(horde: string): object

/**
* Returns claimed area entities of the given horde.
 *
 * @param hordeName Name of the horde.
 */
declare function GetHordeClaimedAreas(hordeName: string): number[]

/**
* Retrieves the "actual" horde name if the horde order was provided.
 * If the horde hasn't arrived yet, returns null.
 *
 * @param hordeInput Horde order or horde name.
 */
declare function GetHordeName(hordeInput: string): string

/**
* Returns floating point sum of radiuses of all claimed areas.
 *
 * @param hordeName Name of the horde.
 */
declare function GetHordeTotalClaimedAreaSize(hordeName: string): number

/**
* Returns the number of horde cards in the invasion horde deck
 *
 * 
 */
declare function GetInvasionHordeDeckCount(): number

/**
* Returns the stored value in the global var that keeps track of how many horde cards to draw
 * for planning invaison actions.
 *
 * 
 */
declare function GetInvasionHordeDraws(): number

/**
* Gets the current invasion phase
 *
 * 
 */
declare function GetInvasionPhase(): number

/**
* Gets the global variable that tracks when the mob alliance occupation has been built and what Id belongs to that base.
 *
 * @param mobId Id of the mob alliance being occupied.
 */
declare function GetMABaseBuiltVar(mobId: string): string

/**
* Get tag for mob alliance cage
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMACageTag(mobId: string): string

/**
* Get tag for mob alliance central building
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMACenterBuildingTag(mobId: string): string

/**
* Get tag for mob alliance gather points
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAGatherPointsTag(mobId: string): string

/**
* Get tag for mob alliance houses
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAHouseTag(mobId: string): string

/**
* Get tag for mob alliance building hurtbox
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAHurtboxTag(mobId: string): string

/**
* Get tag for mob alliance mobs
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAMobsTag(mobId: string): string

/**
* Get tag for piglins at a mob alliance attacking enemies
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPiglinAttackingEnemyTag(mobId: string): string

/**
* Get tag for piglin portal occupying mob alliance
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPiglinPortalTag(mobId: string): string

/**
* Get tag for piglins attacking mob alliance buildings
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPiglinsAttackingBuildingsTag(mobId: string): string

/**
* Get tag for piglins at a mob alliance village
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPiglinsTag(mobId: string): string

/**
* Get tag for mob alliance's piglin targets
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPiglinsTargetTag(mobId: string): string

/**
* Get tag for player entities in the vicinity of a mob alliance
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPlayerEntitiesInAreaTag(mobId: string): string

/**
* Get tag for player in the vicinity of the mob alliance
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMAPlayerInAreaTag(mobId: string): string

/**
* Gets the global variable that tracks when the mob alliance village has been built and what Id belongs to that village.
 *
 * @param mobId id of the mob alliance that has been built.
 */
declare function GetMAVillageBuiltVar(mobId: string): string

/**
* Finds the center building for a mob alliance village based on a given mob name.
 *
 * @param mobId Name of the mob
 */
declare function GetMobAllianceCenterBuilding(mobId: string): number[]

/**
* Returns a data object containing data for a specific mob alliance.
 *
 * @param mobId Id of the mob alliance
 */
declare function GetMobAllianceData(mobId: string): object

/**
* Retrieves the "actual" mob alliance name if the mob alliance order was provided.
 * If the mob alliance hasn't arrived yet, returns null.
 *
 * @param mobAllianceInput Mob Alliance name or order.
 */
declare function GetMobAllianceName(mobAllianceInput: string): string

/**
* Returns only non-defensive and non-central buildings (does not return fountains, allegiance structures, etc.)
 *
 * @param villageId Village ID
 */
declare function GetNonDefensiveBuildings(villageId: number): number[]

/**
* Gets the number of obstacle bases that've been destroyed.
 *
 * 
 */
declare function GetObstacleBasesDestroyed(): number

/**
* Get Outpost Difficulty from phase/game state (always returns 1/2/3)
 *
 * @param faction the faction of the outposts
 */
declare function GetOutpostDifficultyFromPhase(faction: string): number
/**
 * Increases the outpost difficulty. Tried to horde progression
 *
 * @param faction the faction of the outposts
 */
declare function IncreaseOutpostDifficultyForFaction(faction: string): void
/**
* Get all the placement slot name from a given village
 *
 * @param villageEntity Village entity
 */
declare function GetPlacementSlotFromVillage(villageEntity: number[]): string

/**
* Gets the closest player or mob to a portal entity.
 *
 * @param portal The portal entity.
 */
declare function GetPlayerOrMobCloseToPortal(portal: number): number

/**
* Returns all the village entities that are friendly and have been reserved by the invasion system.
 *
 * 
 */
declare function GetReservedFriendlyVillages(): number[]

/**
* Returns all the village entities that belong to the given faction and have been reserved by the invasion system.
 *
 * @param faction Name of the faction that owns the villages.
 */
declare function GetReservedFactionBases(faction: string): number[]

/**
* Returns staggered entry info according to current game difficulty.
 *
 * 
 */
declare function GetStaggeredEntryInfo(): number

/**
* Returns the number of invasion cards to be drawn at dawn.
 *
 * 
 */
declare function GetTotalIntentionsDrawsAtDawn(): number

/**
* Returns all the village entities that belong to the given faction.
 *
 * @param factionName Name of the faction that owns villages.
 */
declare function GetFactionBases(factionName: string): number[]

/**
* Retrieves an object containing VO and cinematics data for the boss of a given piglin horde.
 *
 * @param factionName Name of the piglin faction.
 */
declare function GetFactionBossData(factionName: string): object

/**
* Returns the number of cards in a given faction's invasion deck.
 *
 * @param faction Name of the faction whose deck should be counted.
 */
declare function GetFactionIntentionDeckCount(faction: string): number

/**
* Returns all the village entities that have participated in invasion actions and are not reserved by the invasion system.
 *
 * 
 */
declare function GetUnreservedAll(): number[]

/**
* Returns all unreserved piglin hordes bases.
 *
 * 
 */
declare function GetUnreservedBasesAll(): number[]

/**
* Returns all the friendly village entities that have participated in invasion actions and are not reserved by the invasion system.
 *
 * 
 */
declare function GetUnreservedFriendlyVillages(): number[]

/**
* Returns all the friendly mob alliance villages that are currently available for invasion gameplay
 *
 * 
 */
declare function GetUnreservedMobAllianceVillages(): number[]

/**
* Returns all villager villages and mob alliance villages that may be targets for the invasion.
 *
 * 
 */
declare function GetUnreservedTargetsAll(): number[]

/**
* Returns all the village entities of a given faction that are not reserved by the invasion system.
 *
 * @param faction Name of the faction to query.
 */
declare function GetUnreservedFactionBases(faction: string): number[]

/**
* Retrieves the variation data for a specific kind of variation (egs. flavour, objective)
 *
 * @param variationId The id to distinguish which kind of variation to use: @see VARIATION_ID_FLAVOUR and @see VARIATION_ID_OBJECTIVE
 */
declare function GetVariationData(variationId: number): object

/**
* Returns the village composition data for a piglin base depending on its size and flavour.
 * The variationData should follow the pattern found in the attackVal.villageComposition object.
 *
 * @param villageId The id of the village.
 * @param variationData The data object containing all the composition data for sizes and flavours.
 */
declare function GetVillageCompositionData(villageId: number, variationData: object): object

/**
* Safe accessor for getting the flavour of a village. If the village is not a base that supports
 * flavour variation, then the default flavour is returned.
 *
 * @param villageId The village ID.
 */
declare function GetVillageFlavour(villageId: number): string

/**
* Safe accessor for getting the objective of a village. If the village is not a base that supports
 * objective variation, then the default objective is returned.
 *
 * @param villageId The village ID.
 */
declare function GetVillageObjective(villageId: number): string

/**
* Handles logic for what actions to thwart based on the village that was destroyed.
 *
 * @param villageId ID of the village that has been destroyed.
 */
declare function HandleThwartingForDestroyedVillage(villageId: number): void

/**
* Returns true/false result in regards to the fact whether or not the given piglin base is planning to do something at night.
 *
 * @param villageId Piglin base village id.
 */
declare function HasDelayedInvasionAction(villageId: number): boolean

/**
* Creates a card from the hordeCards library
 *
 * @param faction The horde card's faction
 * @param count The number of cards to make
 */
declare function HordeCard(faction: string, count: number): string[]

/**
* Sets up rally points for bases attacking another village (invasion attacks and mob alliance occupation bases)
 *
 * @param villageId Id of the base to setup.
 * @param data Data containing the rally point information ('viableRallyBuildingTags' and 'totalRallyPoints' properties)
 */
declare function InitRalliesForVillageAttack(villageId: number, data: object): void

/**
* Returns a deck of invasion cards based on the given parameters
 *
 * @param faction Name of the faction who's cards to create.
 * @param type The type of cards to make.
 * @param count The amount of copies of the card to include.
 */
declare function IntentionCard(faction: string, type: string, count: number): string[]

/**
* Introduces next mob alliance.
 *
 * @param mobAlliance Name of the mob alliance to introduce.
 */
declare function IntroduceNextMobAllianceAct2(mobAlliance: string): void

/**
* Returns true if the invasion system's phase is greater than 0.
 *
 * 
 */
declare function InvasionActive(): boolean

/**
* Helper function to encapsulate calculating a village's defense, the resulting attack damage to apply, and distributing the damage 
 * to the village's buildings. Mainly used in the context of Village Attacks.
 * NOTE: The village MUST be loaded before calling this function. This can be done by creating a damage request and applying damage in a snippet
 * responding to it.
 *
 * @param villageId Id of the village to damage.
 * @param hordeName Name of the piglin faction applying damage.
 * @param strength Strength of the village attack applying the damage.
 * @param percentComplete Percentage to scale the damage.
 */
declare function InvasionAttackV2ApplyDamage(villageId: number, hordeName: string, strength: number, percentComplete: number): void

/**
* Apply period damage to an occupied village.
 *
 * @param villageId The village ID.
 * @param hordeName The occupying horde.
 * @param affectedBuildingCount The number of buildings affected.
 */
declare function InvasionOccupationApplyDamage(villageId: number, hordeName: string, affectedBuildingCount: number): void

/**
* Checks if any horde has arrived yet.
 *
 * 
 */
declare function IsAnyHordeArrived(): boolean

/**
* Check if a village already escalated to an specific escalation.
 *
 * @param entityFromVillage A entity group that belongs to the village.
 * @param escalationKey String that represents the escalation in question.
 */
declare function IsBaseEscalated(entityFromVillage: number, escalationKey: string): void

/**
* Checks if a invasion attack action is a boss level attack.
 *
 * @param faction The attacking horde.
 * @param strength The attack strength.
 */
declare function IsBossAttack(faction: string, strength: number): boolean

/**
* Helper to determine if the village is a boss village.
 *
 * @param villageId The Id of the village.
 */
declare function IsBossVillage(villageId: number): boolean

/**
* Check if the base size is an invasion attack base (forward operating base).
 * Note that this size only makes sense within an invasion context.
 *
 * @param baseSize The base size.
 */
declare function IsFOBSize(baseSize: string): boolean

/**
* Checks whether the given string is a horde input (name or order).
 *
 * @param input String input
 */
declare function IsHordeInput(input: string): boolean

/**
* Check if the base size is equal to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsLarge(baseSize: string): boolean

/**
* Check if the base size is equal or greater to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsLargeOrGreater(baseSize: string): boolean

/**
* Check if the base size is equal to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsMedium(baseSize: string): boolean

/**
* Check if the base size is equal or greater to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsMediumOrGreater(baseSize: string): boolean

/**
* Checks if given string is a mob alliance input (name or order)
 *
 * @param input String input
 */
declare function IsMobAllianceInput(input: string): boolean

/**
* Determines if a given size corresponds to a mob alliance village controlled by piglins.
 *
 * @param size The village's size to check.
 */
declare function IsMobAlliancePiglinSize(size: string): boolean

/**
* Returns a boolean indicating if the mob alliance has been unlocked (players can spawn mobs and build their spawners) or not.
 *
 * @param mobId ID of the mob alliance (e.g. zombie, skeleton, creeper, etc.)
 */
declare function IsMobAllianceUnlocked(mobId: string): boolean

/**
* Is a villageID a mob alliance village
 *
 * @param villageId Village Id
 */
declare function IsMobAllianceVillage(villageId: number): boolean

/**
* Checks whether the mob alliance occupation scenario has been completed, i.e. occupying piglins defeated and mob alliance awarded.
 *
 * @param mobId Name of the mob alliance
 */
declare function IsOccupationBeatOver(mobId: string): boolean

/**
* Check if the base size is equal or greater to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsOutpost(baseSize: string): boolean

/**
* Check if objective type isRaiding Party (check only for outposts)
 *
 * @param villageId The village Id
 */
declare function IsPiglinRaidingParty(villageId: number): boolean

/**
* Check if a piglin faction is defeated (all portal bases destroyed and the boss killed)
 *
 * @param factionName the name of the faction
 */
declare function IsPiglinFactionDefeated(factionName: string): boolean

/**
* Is a village a player outpost.
 *
 * @param villageId The village ID.
 */
declare function IsPlayerOutpost(villageId: number): boolean

/**
* Check if the base size is a roaming base. Ie. an outpost or a vanguard base.
 * Note that this size only makes sense within an invasion context.
 *
 * @param baseSize The base size.
 */
declare function IsRoamingSize(baseSize: string): boolean

/**
* Check if the base size is equal to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsSmall(baseSize: string): boolean

/**
* Check if the base size is equal or greater to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsSmallOrGreater(baseSize: string): boolean

/**
* Checks if base is a Structure Destructiont Base (if flavour is defined)
 *
 * @param villageId The village ID
 */
declare function IsStructureDestructionBase(villageId: number): boolean

/**
* Returns true/false in regards to the fact whether or not a given village will be attacked by piglins in the upcoming night.
 *
 * @param villageId Village Id.
 */
declare function IsTargetOfDelayedInvasionAttack(villageId: number): boolean

/**
* Check if the base size is equal or greater to the specified size.
 *
 * @param baseSize The base size.
 */
declare function IsVanguard(baseSize: string): boolean

/**
* Checks if the village is allive (whether a fountain is still enabled or not)
 *
 * @param villageId Village ID
 */
declare function IsVillageAlive(villageId: number): boolean

/**
* Checks if a village is under an invasion attack action.
 *
 * @param villageId The village to check.
 */
declare function IsVillageUnderInvasionAttack(villageId: number): boolean

/**
* Helper function to debug LFC functionality.
 *
 * @param msg Debug message
 */
declare function LFC_Logi(msg: string): void

/**
* Helper function to encapsulate removing the ability for players to spawn mob and build their spawners.
 *
 * @param mobId ID of the mob alliance (e.g. zombie, skeleton, creeper, etc.)
 */
declare function LockMobAlliance(mobId: string): void

/**
* Changes the properties of a given mob spawner based on the current state of the campaign.
 *
 * @param spawner Spawner entity to configure.
 * @param isCentralBuilding Whether this building is the central mob alliance structure.
 * @param mobId name of the mob alliance this building belongs to.
 */
declare function ManageMobAllianceSpawner(spawner: number, isCentralBuilding: boolean, mobId: string): void

/**
* Mark an escalation of a village as escalated.
 *
 * @param entityFromVillage A entity group that belongs to the village.
 * @param escalationKey String that represents the escalation in question.
 */
declare function MarkBaseAsEscalated(entityFromVillage: number, escalationKey: string): void

/**
* Call this after resetting a village to let the game know that the village has been properly reset.
 *
 * @param villageId The village ID
 */
declare function MarkBaseAsReset(villageId: int): void

/**
* Mark a specific base response as escalated.
 *
 * @param id The village ID
 * @param escalationKey The escalation global variable.
 */
declare function MarkVillageAsEscalatedById(id: number, escalationKey: string): void

/**
* Logic to run for the aquiring the mob alliance once its occupying base is destroyed.
 *
 * @param mobId id of the mob alliance
 */
declare function OccupyingBaseDestroyed(mobId: string): void

/**
* Runs logic that requires both the mob alliance village and occupation base to exist and be fully built.
 *
 * @param mobId ID of the mob alliance.
 */
declare function OnMobAllianceOccupationStarted(mobId: string): void

/**
* Places the first base for a horde.
 *
 * @param horde The piglin horde.
 * @param debugSkipCinematic Should the cinematic be played.
 */
declare function PlaceFirstBase(horde: string, debugSkipCinematic: boolean): void

/**
* Play presentation events for invasion dawn stage.
 *
 * 
 */
declare function PlayAudioUIDawnInvasionStage(): void

/**
* Play common building destroyed VO
 *
 * 
 */
declare function PlayCommonBuildingDestroyedVO(): void

/**
* Play portal destroyed VO from a list
 *
 * 
 */
declare function PlayCommonPortalDestroyedVO(): void

/**
* Play portal Health Group 1 VO from a list
 *
 * 
 */
declare function PlayCommonPortalHealthGroup1VO(): void

/**
* Play portal Health Group 2 VO from a list
 *
 * 
 */
declare function PlayCommonPortalHealthGroup2VO(): void

/**
* Play portal Health Group 3 VO from a list
 *
 * 
 */
declare function PlayCommonPortalHealthGroup3VO(): void

/**
* Returns how many days the player was inactive.
 *
 * 
 */
declare function PlayerActivity_GetInactiveDays(): number

/**
* Increments how many days the player was inactive. Needs to be called once per day.
 *
 * 
 */
declare function PlayerActivity_IncremenentInactiveDays(): void

/**
* Returns whether or not the player is currently inactive.
 *
 * 
 */
declare function PlayerActivity_IsPlayerInactive(): bool

/**
* Ultimately resets an inactivity, meaning that player is becoming active again.
 *
 * 
 */
declare function PlayerActivity_Reset(): void

/**
* Plays a single card from a given faction's invasion deck.
 *
 * @param faction Name of the faction who is playing a card.
 */
declare function PlayFactionIntentionDeck(faction: string): void

/**
* Checks and introduces hordes and mob alliances.
 *
 * @param triggerTime When is this triggered? DAWN, DUSK or IMMEDIATE
 */
declare function ProgressCampaign(triggerTime: string): void

/**
* Refreshed the spawner config for all the mob alliance spawners in the mob alliance village.
 *
 * @param mobId name of the mob alliance to configure
 */
declare function RefreshAllSpawnersConfig(mobId: string): void

/**
* Refreshes the behaviour of all the uncaged mobs for a given mob alliance
 *
 * @param mobId name of the mob alliance
 */
declare function RefreshBehaviourOfAllUncagedMobs(mobId: string): void

/**
* Helper to remove music emitter entities from a village.
 *
 * @param villageId Id of the village removing music entities
 */
declare function RemoveAudioEntityFromBase(villageId: number): void

/**
* Adds horde cards back into the invasion horde deck based on which piglin factions are available to plan invasion actions.
 *
 * 
 */
declare function ReplenishInvasionHordeDeck(): void

/**
* Adds horde cards back into the night outpost horde deck based on which piglin factions are available to build night outposts.
 *
 * 
 */
declare function ReplenishNightOutpostHordeDeck(): void

/**
* Tags the village so that it cannot be selected for invasion actions.
 *
 * @param villageEntity Village entity to tag.
 */
declare function ReserveVillage(villageEntity: number): void

/**
* Resets the boss for a piglin base.
 *
 * @param villageId The id of the village to be reset.
 */
declare function ResetBoss(villageId: number): void

/**
* Resets all the barrack escalation levels and update any built barracks configuration of a given village variation.
 * Also culls any entities in the village that are pop capped.
 *
 * @param villageId The id of the village
 * @param barracks An object containing barracks tags as keys, and corresponding barracks configs as values
 * @param escalationKeys An object containing all the escalation keys to reset as values
 */
declare function ResetEscalationAndBarracksForVillageVariation(villageId: number, barracks: any, escalationKeys: any): void

/**
* Resets Invasion Draw Counter (do this when phase changes)
 *
 * 
 */
declare function ResetInvasionDrawCounter(): void

/**
* (CAMPAIGN ONLY) Select a behaviour action set to the mob based on the current state of the campaign
 *
 * @param mobEG The mob entity that will have the behaviour set changed
 * @param mobId The id of the mob so we can access the behaviour set dictionary
 * @param leftMobAllianceArea Is the mob leaving the mob alliance area?
 */
declare function SelectMobBehaviourSet(mobEG: number[], mobId: string, leftMobAllianceArea: boolean): void

/**
* Resets the invasion faction deck for a given phase for all factions.
 * This clears out any existing cards.
 *
 * @param phase The current invasion phase.
 */
declare function SetAllFactionDecksFromPhase(phase: number): void

/**
* Sets the phase for the audio entity at a base
 *
 * @param villageId The village ID.
 * @param audioPhase The phase string
 * @param overrideMusicEntityTag An optional override tags on specific music entities.
 */
declare function SetAudioPhaseForBase(villageId: number, audioPhase: string, overrideMusicEntityTag: string[]): void

/**
* Set the barracks configuration to the right base size and aggro phase
 *
 * @param barracksEntities The Barracks entities to update the loadout configuration.
 * @param factionBarracksConfig The configuration of the barrack with all phases for that faction.
 */
declare function SetBarracksConfig(barracksEntities: number[], factionBarracksConfig: any): void

/**
* Set the barracks configuration to the right base size, variation and aggro phase (Use this is the size has variations)
 *
 * @param barracksEntities The Barracks entities to update the loadout configuration.
 * @param factionBarracksConfig The configuration of the barrack with all phases for that faction.
 */
declare function SetBarracksConfigForVillageVariation(barracksEntities: number[], factionBarracksConfig: any): void

/**
* Sets all the barrack escalation levels and update any built barracks configuration of a given village.
 *
 * @param villageId The id of the village
 * @param barracks An object containing barracks tags as keys, and corresponding barracks configs as values
 * @param escalationLevel The escalation level, it has to match the number on the barracks configuration dictionary e.g.:in `phase_0` the key is `0`
 */
declare function SetEscalationValueAndUpdateAllBarracksForVillage(villageId: number, barracks: any, escalationLevel: number): void

/**
* Sets all the barrack escalation levels and update any built barracks configuration of a given village variation.
 *
 * @param villageId The id of the village
 * @param barracks An object containing barracks tags as keys, and corresponding barracks configs as values
 * @param escalationLevel The escalation level, it has to match the number on the barracks configuration dictionary e.g.:in `phase_0` the key is `0`
 */
declare function SetEscalationValueAndUpdateAllBarracksForVillageVariation(villageId: number, barracks: any, escalationLevel: number): void

/**
* Set the barrack escalation level for that barrack and update any built barracks configuration of a given village
 * ResetEscalationAndBarracksForVillageVariation.
 *
 * @param villageId The id of the village.
 * @param barrackTag The name of the barracks (Please use the global names created E.g:`BARRACKS_NAME_FIGHTER`)
 * @param factionBarracksConfig the configuration of the barrack with all phases for that faction
 * @param escalationLevel The escalation level, it has to match the number on the barracks configuration dictionary e.g.:in `phase_0` the key is `0`
 * @param forceUpdate Set to true if you want to force barracks escalation to a previous point. If you want to reset a village, consider using
 */
declare function SetEscalationValueAndUpdateBarracksForVillage(villageId: number, barrackTag: string, factionBarracksConfig: any, escalationLevel: number, forceUpdate: boolean): void

/**
* Set the barrack escalation level for that barrack and update any built barracks configuration of a given village, with variation (Use this if the village has variations)
 * ResetEscalationAndBarracksForVillageVariation instead.
 * ResetEscalationAndBarracksForVillageVariation.
 *
 * @param villageId The id of the village.
 * @param barrackTag The name of the barracks (Please use the global names created E.g:`BARRACKS_NAME_FIGHTER`)
 * @param factionBarracksConfig the configuration of the barrack with all phases for that faction
 * @param escalationLevel The escalation level, it has to match the number on the barracks configuration dictionary e.g.:in `phase_0` the key is `0`
 * @param forceUpdate Set to true if you want to force barracks escalation to a previous point. If you want to reset a village, consider using
 */
declare function SetEscalationValueAndUpdateBarracksForVillageVariation(villageId: number, barrackTag: string, factionBarracksConfig: any, escalationLevel: number, forceUpdate: boolean): void

/**
* Sets the number of horde card draws that should be made for planning invasion actions.
 *
 * @param numberOfDraws The number of horde cards to draw.
 */
declare function SetInvasionHordeDraws(numberOfDraws: number): void

/**
* Set the invasion phase
 *
 * @param phaseInt The phase to set the invasion to
 */
declare function SetInvasionPhase(phaseInt: number): void

/**
* Set the state of mob world spawner close to their homesteads
 *
 * @param state the world spawner state
 */
declare function SetMobWorldHomesteadSpawnersState(state: boolean): void

/**
* Set the mob world spawner state
 *
 * @param state the world spawner state
 */
declare function SetMobWorldSpawnersState(state: boolean): void

/**
* Helper function to set a portal invulnerable.
 *
 * @param villageId The village ID of the potal.
 * @param isInvulnerable Should the portal be invulnerable?
 */
declare function SetPortalInvulnerable(villageId: number, isInvulnerable: boolean): void

/**
* Set the state of the all roaming piglin spawners
 *
 * @param spawnersActive true for active false for inactive
 */
declare function SetRoamingInvisibleSpawnersState(spawnersActive: boolean): void

/**
* Resets the invasion faction deck for a given phase.
 * This clears out any existing cards.
 *
 * @param factionName The faction name.
 * @param phase The invasion phase.
 */
declare function SetFactionDeckFromPhase(factionName: string, phase: number): void

/**
* Sets up the audio entity for a base.
 *
 * @param villageId The village ID
 * @param audioEntityData The audio entity data - can be either a string pointing to the entity, or a dict for size/flavours as set up in the files base_response_piglin_attack/defend/obstacle files
 * @param removeOnVillageDestruction Optional: Whether or not the music entity should be removed automatically when the village is destroyed.
 */
declare function SetupAudioEntityForBase(villageId: number, audioEntityData: object, removeOnVillageDestruction: boolean): void

/**
* Setup controllers for base piggo gold behaviour on a faction
 *
 * @param villageId The id of the faction.
 * @param totalNumberOfPiggosPerBase The maximum number of piggos a base can have
 */
declare function SetupBasePiggoGoldController(villageId: number, totalNumberOfPiggosPerBase: number): void

/**
* Forces a DAI for a horde.
 *
 * @param cardType The action name for the card.
 * @param faction The horde.
 */
declare function SetupForcedDAIForFaction(cardType: string, faction: string): void

/**
* Sets up listeners for an invasion boss level attack.
 *
 * 
 */
declare function SetupInvasionAttackBossListeners(): void

/**
* Sets up listeners for invasion system's dawn logic
 *
 * 
 */
declare function SetupInvasionDawnListeners(): void

/**
* Sets up listeners for invasion system's night logic
 *
 * 
 */
declare function SetupInvasionNightListeners(): void

/**
* Sets up listeners for invasion system's night outpost logic
 *
 * 
 */
declare function SetupInvasionNightOutpostListeners(): void

/**
* Sets up listeners for invasion system's noon logic
 *
 * 
 */
declare function SetupInvasionNoonListeners(): void

/**
* Sets up the general listeners for mob cages. Must spawn a cage with the given specific tag for this function to search for.
 *
 * @param villageId id of the village owning the cage.
 * @param cageTag tag of the cage buildable.
 * @param mobArchetype Optional: the mob archetype to spawn in the cage. Will be chosen at random if not set.
 * @param mobAmount Optional: the number of mobs to spawn in the cage. Defaults to 5 if not set.
 */
declare function SetupMobCages(villageId: number, cageTag: string, mobArchetype: string, mobAmount: number): void

/**
* Creates the standard trigger volumes and listeners for a base. Includes the entered trigger volume (smaller, depends on base size) and gameplayer trigger volume (very large).
 * Also sets up a de-escalation cycle, in which all pop-capped units are despawned at dawn if no player is near the base.
 * You can add extra de-escalation logic by checking if @see ShouldBaseReset returns true, but be sure to call @see MarkBaseAsReset if you do.
 *
 * @param villageId The village ID.
 * @param baseData The base setup data object.
 */
declare function SetupPiglinBase(villageId: number, baseData: any): void

/**
* Sets up the trigger for playing the invulnerability VO for a portal in Boss bases.
 *
 * @param villageId The village id of the portal.
 */
declare function SetupPortalInvulnerabilityVO(villageId: number): void

/**
* A fallback helper function to ensure a base always has engineers (to prevent a base from being unable to build).
 * It is preferrable to have a engineer barracks instead as that is visible to the player.
 *
 * @param villageId The village ID for the piglin base.
 * @param count The max number of engineers to manage.
 * @param respawnTime The respawn time of the engineers.
 */
declare function SetupRespawningEngineers(villageId: number, count: number, respawnTime: number): void

/**
* Creates the snippets needed to facilitate wave attacks for a given village.
 *
 * @param attackName Name of the attack context. Used primarily to differentiate snippet names
 * @param waveDataCallback Function to run that will select particular wave data. Parameters are (factionName, baseSize)
 */
declare function SetupSnippetsForWaveAttacks(attackName: string, waveDataCallback: function): void

/**
* SetupStaggeredEntry
 *
 * 
 */
declare function SetupStaggeredEntry(): void

/**
* Sets up the initial occupation state on a village and the listeners that will drive occupation behaviour
 *
 * @param villageId id of the village to become occupied.
 * @param hordeName name oof the piglin horde occupying the village.
 */
declare function SetupVillageOccupation(villageId: number, hordeName: string): void

/**
* Sets a village variable to true (1) for a duration before automatically setting it to false (0).
 * Village variable must not be true when this is called.
 *
 * @param villageId The village ID.
 * @param variableName The global variable key.
 * @param delay The delay in seconds before returning the value to false.
 */
declare function SetVillageVariableForDuration(villageId: number, variableName: string, delay: number): void

/**
* Will return true if the village has been flagged for reset.
 *
 * @param villageId The village ID
 */
declare function ShouldBaseReset(villageId: int): void

/**
* Snapshot that it taken at the start ot Act 2.
 *
 * 
 */
declare function SNAPSHOT_Act2Started(): object

/**
* Chains several snapshots together and takes the smallest value.
 *
 * @param snapshots Array of snapshots to consider.
 */
declare function SNAPSHOT_AND(snapshots: object[]): object

/**
* Snapshot taken once the player leaves the well of fate at the start of act 2.
 *
 * 
 */
declare function SNAPSHOT_FirstPregameConditionsFulfilled(): object

/**
* Snapshot that it taken when the provided horde first builds the base.
 *
 * @param hordeInput Horde name or order.
 */
declare function SNAPSHOT_HordeFirstBaseBuilt(hordeInput: string): object

/**
* Snapshot that it taken when the provided horde enters pre-game.
 *
 * @param hordeInput Horde name or order.
 */
declare function SNAPSHOT_HordePregameStarted(hordeInput: string): object

/**
* Snapshot that it taken when the provided mob alliances occupation starts.
 *
 * @param mobAllianceInput Mob Alliance name or order.
 */
declare function SNAPSHOT_MobAllianceOccupationStarted(mobAllianceInput: string): object

/**
* Chains several snapshots together and takes the largest value.
 *
 * @param snapshots Array of snapshots to consider.
 */
declare function SNAPSHOT_OR(snapshots: object[]): object

/**
 * Spawns an engineer at the portal. Used by defend and obstacle horde to build new structures
 * Portal must not be destroyed. @see QUERY_IsVillageDestroyed
 *
 * @param villageId The village ID of the base to spawn at.
 * @param amount The amount of engineers to spawn
 */
declare function SpawnEngineersIfThereAreNone(villageId: number, amount: number): number[]

/**
* Spawn entities at a base's spawn position. Returns spawned entities.
 * Portal must not be destroyed. @see QUERY_IsVillageDestroyed
 *
 * @param villageId The village ID of the base to spawn at.
 * @param spawnName The archetype name of the entity.
 * @param count The number of entities to spawn.
 * @param piglinAppearanceOverride TODO: What does this param do? Ask Daniel S.
 */
declare function SpawnAtPortal(villageId: number, spawnName: string, count: number, piglinAppearanceOverride: string): number[]

/**
* Spawns a base.
 *
 * @param factionName The horde the base belongs to.
 * @param baseSize The base size.
 * @param isInvasion Spawns via invasion.
 * @param invasionReason The reason for spawning.
 */
declare function SpawnBase(factionName: string, baseSize: string, isInvasion: boolean, invasionReason: string): number

/**
* Spawns an Invasion Base with default rules set in invasion_helpers file
 *
 * @param factionName Name of the faction
 * @param baseSize The base size to spawn.
 * @param useFallback Enable final fallback. When set to true you can assume this function always succeeds (may place in very odd locations though).
 * @param isInvasion Is this to spawn an invasion base?
 * @param isStarterBase Is an Act 2 starter base using starter base rules
 */
declare function SpawnBaseWithRules(factionName: string, baseSize: string, useFallback: boolean, isInvasion: boolean, isStarterBase: boolean): boolean

/**
* Helper to spawn a new piglin base inside a claimed area. Also attempts to spawn outposts with it
 *   If there isn't room for outposts, only the base will spawn.
 *   If there isn't room for the new base, a new area will be claimed and the base + outposts will be built.
 * Returns a boolean indicating if new bases were built.
 *
 * @param factionName Name of the piglin faction building a new base.
 * @param baseSize Size of the new base being built.
 * @param isInvasion If the base is spawned from invasion.
 */
declare function SpawnBaseWithRulesInClaimedArea(factionName: string, baseSize: string, isInvasion: boolean): boolean

/**
* Spawns the first base for a piglin horde being introduced to the game world. Subsequent bases built for a horde
 * are based on the positioning of the base created here.
 *
 * @param horde The piglin horde.
 */
declare function SpawnCentralBase(horde: string): void

/**
* Spawns outposts within an area claimed by piglins.
 *
 * @param horde Name of the piglin horde
 * @param areaEntity Claimed area entity to build inside.
 * @param areaRadius Radius of the claimed area.
 * @param numOutposts Number of outposts to build
 * @param centralBase Optional: Village entity these outposts will build around
 */
declare function SpawnClaimedAreaOutposts(horde: string, areaEntity: number, areaRadius: number, numOutposts: number, centralBase: number): void

/**
* Spawns an Invasion Defensive Outpost with default rules set in invasion_helpers file
 *
 * @param factionName Name of the faction
 * @param isInvasion Is this outpost for invasion?
 * @param isInitialOutpost Is an Act 2 starter outpost
 */
declare function SpawnDefensiveOutpostWithRules(factionName: string, isInvasion: boolean, isInitialOutpost: boolean): boolean

/**
* Helper to spawn a piglin outposts in a claimed area with placement rules configured.
 * Returns a boolean indicating if placement was successful.
 *
 * @param factionName Name of the piglin faction building an outpost.
 * @param claimedArea Claimed Area entity.
 * @param claimedAreaRadius Raduis of the claimed area.
 * @param centralBase Optional: Village entity these outposts will build around
 */
declare function SpawnDefensiveOutpostWithRulesInClaimedArea(factionName: string, claimedArea: number, claimedAreaRadius: number, centralBase: number): boolean

/**
* Spawns a Far Invasion Base with default rules set in invasion_helpers file
 *
 * @param hordeName Name of the horde
 * @param baseSize The base size to spawn.
 * @param useFallback Enable final fallback. When set to true you can assume this function always succeeds (may place in very odd locations though).
 * @param isInvasion Is this to spawn an invasion base?
 */
declare function SpawnFarBaseWithRules(hordeName: string, baseSize: string, useFallback: boolean, isInvasion: boolean): boolean

/**
* Spawns the intial base for a faction.
 *
 * @param factionName Name of the faction.
 * @param baseSize Base size to spawn.
 */
declare function SpawnInitialBaseWithRules(factionName: string, baseSize: string): boolean

/**
* Spawns an Invasion Offensive Outpost with default rules set in invasion_helpers file
 *
 * @param factionName Name of the faction
 * @param isInvasion Is this base for invasion?
 */
declare function SpawnOffensiveOutpostWithRules(factionName: string, isInvasion: boolean): boolean

/**
* Spawns a set of units from a data dict or array of dicts of the form {amount: <number>, unit: <archetype>}.
 *
 * @param villageId The village ID
 * @param unitsToSpawn The data object containing the amount and archetype to be spawned in the form {amount: (number), unit: (unit string)}, could also be an array of such objects.
 * @param location Location to spawn
 */
declare function SpawnVillageUnits(villageId: number, unitsToSpawn: object, location: number): number[]

/**
* Spawns units depending on the village variation based on a data dict
 *
 * @param villageId The village ID
 * @param data Data dict in the form of [{amount: (number), unit: (unit string)}]
 * @param location Location to spawn
 * @param variationOverride Override the variation
 */
declare function SpawnVillageVariationUnits(villageId: number, data: all[], location: number, variationOverride: string): number[]

/**
* StaggeredEntryNextDawn
 *
 * 
 */
declare function StaggeredEntryNextDawn(): void

/**
* Has to run each "system" dusk for staggered entry functionality.
 *
 * 
 */
declare function StaggeredEntryNextDusk(): void

/**
* A helper to define a collection of entities which may slowly arrive over time.
 *
 * @param gvName Global variable name to use
 * @param allowedValues String values of entities to arrive.
 */
declare function StaggeredOrderedCollection(gvName: string, allowedValues: object[]): object

/**
* Start automatic piggo gold spawn on a faction
 *
 * @param villageId The id of the faction.
 * @param piggoSpawnRate The rate on which the piggo golds will be spawned
 */
declare function StartBaseAutomaticPiggoSpawnWithRate(villageId: number, piggoSpawnRate: number): void

/**
* Commences the invasion beat for mob alliances. This includes queuing the occupying base to build, making cages at the mob alliance,
 * and setting up trigger volumes used during occupation. If the mob alliance village is not generated yet, this is queued until such time. 
 *
 * @param mobId Id of the mob alliance being occupied
 */
declare function StartMobAlliancePiglinInvasion(mobId: string): void

/**
* Starts the pregame sequence for a horde.
 *
 * @param horde The horde.
 */
declare function StartPregame(horde: string): void

/**
* Starts the recurring spawner of an entity. When the entity dies a new entity of the same time will spawn after a time defined on the DeclareRecurringSpanwerSnippets.
 *
 * @param uniqueSpawnerId The unique string id for this recurring spawner (Same ID you have put on the DeclareRecurringSpanwerSnippets)
 * @param spawnLocationEntity The location(s) to spawn the entity
 * @param initialTimer Initial delay to spawn the first entity
 */
declare function StartRecurringSpawner(uniqueSpawnerId: string, spawnLocationEntity: number, initialTimer: number): void

/**
* Helper function to despawn mobs belonging to a pigln base.
 *
 * @param villageId The village ID.
 * @param despawnAllAtSameTime If the secondsBetweenDespawns is 0.
 * @param secondsBetweenDespawns The delay between each despawn.
 * @param initialDelay The initial delay before anything is despawned.
 */
declare function StartToDespawnPiglinBaseMobs(villageId: number, despawnAllAtSameTime: boolean, secondsBetweenDespawns: number, initialDelay: number): void

/**
* Start to despawn the piglin base structures (everything but walls)
 * @returns The culture lowest value of that faction
 *
 * @param villageId The id of the faction
 * @param despawnAllAtSameTime Despawn all structures at the same time or over a duration
 * @param totalDespawnDuration In case to spawn over a duration, what is the value of that duration
 */
declare function StartToDespawnPiglinBaseStructures(villageId: number, despawnAllAtSameTime: boolean, totalDespawnDuration: number): number

/**
* Creates the listeners that will initiate and perpetuate wave attacks.
 *
 * @param attackName Name of the attack context. Must match the name provided for `SetupSnippetsForWaveAttacks`
 * @param attackingVillageId id of the attacking village
 * @param targetVillageId id of the village being attacked
 * @param initialDelay Initial delay before starting the attack waves
 */
declare function StartWaveAttacks(attackName: string, attackingVillageId: number, targetVillageId: number, initialDelay: number): void

/**
* Chains several triggers together and eval() returns true only if all child triggers return true.
 *
 * @param triggers Array of triggers
 */
declare function TRIGGER_AND(triggers: object[]): object

/**
* Triggers when certain # of days has passed.
 *
 * @param daysNum Expected # of days.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_DaysSince(daysNum: number, snapshot: object): object

/**
* Triggers when a certain # of bases was constructed - of provided hordes and sizes.
 *
 * @param hordes Hordes that bases must belong to.
 * @param sizes Sizes that bases should have.
 * @param number Expected # of such bases.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_HordeBasesConstructed(hordes: string[], sizes: string[], number: number, snapshot: object): object

/**
* Triggers when a certain # of bases was destroyed - of provided hordes and sizes.
 *
 * @param hordes Hordes that bases must belong to.
 * @param sizes Sizes that bases should have.
 * @param number Expected # of such bases.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_HordeBasesDestroyed(hordes: string[], sizes: string[], number: number, snapshot: object): object

/**
* Triggers when a certain # of bases was upgraded.
 *
 * @param hordes Hordes that upgraded bases must belong to.
 * @param number Expected # of upgrades.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_HordeBasesUpgraded(hordes: string[], number: number, snapshot: object): object

/**
* Triggers when an horde's outpost is destroyed.
 *
 * @param hordes The hordes to check for.
 * @param destroyedNum The threshold count.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_HordeOutpostsDestroyed(hordes: string[], destroyedNum: number, snapshot: object): object

/**
* Chains several triggers together and eval() returns true only if any child trigger returns true.
 *
 * @param triggers Array of triggers.
 */
declare function TRIGGER_OR(triggers: object[]): object

/**
* Triggers when a certain # of victories was made.
 * Victory counts as deflecting village attack or destroying a piglin outpost.
 *
 * @param victoriesNum Expected # of victories.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_VictoriesOverPiglins(victoriesNum: number, snapshot: object): object

/**
* Triggers when players have successfully defended enough villages from piglin attacks.
 *
 * @param defendedNum Number of attacks to successfully defend relative to the snapshot.
 * @param hordes Which piglin attacks to track.
 * @param snapshot Snapshot of when to track successful village defenses.
 */
declare function TRIGGER_VillageAttacksDefended(defendedNum: number, hordes: string[], snapshot: object): object

/**
* Triggers when players fought in a certain # of village attacks.
 * "Fighting" means physically fighting in the attack at the village, with any outcome.
 *
 * @param foughtNum Expected # of fights.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_VillageAttacksFought(foughtNum: number, snapshot: object): object

/**
* Triggers when a certain # of attacks was resolved, with any outcome, whether or not players fought in them.
 *
 * @param resolvedNum Expected # of resolutions.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_VillageAttacksResolved(resolvedNum: number, snapshot: object): object

/**
* Triggers when a certain # of village were entered (and they were not under attack)
 *
 * @param enteredNum Expected # of entries.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_VillageNotUnderAttackEntered(enteredNum: number, snapshot: object): object

/**
* Triggers when a certain # of village were exited (and they were not under attack)
 *
 * @param exitedNum Expected # of exits.
 * @param snapshot Snapshot to compare the value against.
 */
declare function TRIGGER_VillageNotUnderAttackExited(exitedNum: number, snapshot: object): object

/**
* Adds a village rewards token to a village. Nothing is added if the village is not eligible or full on tokens.
 *
 * @param villageId The village ID.
 * @param amount The number of tokens to add.
 */
declare function TryAddRewardsToVillage(villageId: number, amount: number): void

/**
* Helper function to encapsulate awarding the ability for players to spawn mob and build their spawners.
 *
 * @param modId ID of the mob alliance (e.g. zombie, skeleton, creeper, etc.)
 */
declare function UnlockMobAlliance(modId: string): void

/**
* Removes the reserved tag from all alive villages so they can be chosen to particiapte in invasion actions.
 *
 * 
 */
declare function UnreserveAllVillages(): void

/**
* Removes the reserved tag from a given village so they can be chosen to particiapte in invasion actions.
 *
 * @param villageEntity The village entity to unreserve.
 */
declare function UnreserveVillage(villageEntity: number): void

/**
* Creates and returns a deck for a village in an 'O' configuration
 *
 * 
 */
declare function VillageDeckO(): string[]

/**
* Used specifically for village chest rewards.
 * Used to retrieve or set resource rewards for a village.
 *
 * @param villageId The village ID.
 * @param resourceName The resource ID.
 */
declare function VillageResourceStore(villageId: number, resourceName: string): object

/**
* Returns true if the village supports variations (ie. some piglin bases).
 *
 * @param villageId The village ID.
 */
declare function VillageSupportsVariations(villageId: number): boolean

/**
* Returns a target entity from a given village for units to attack.
 *
 * @param targetVillageID Id of the village being attacked.
 * @param prioritizeCentralStructure Whether or not to prioritize the central structure of the village in target selection.
 */
declare function WaveGetAttackTarget(targetVillageID: number, prioritizeCentralStructure: boolean): number


// FILE CONTENTS: bsharp_api_listener.gen.d.ts


/**
 * Listen for iteration with a FOREACH_ function.
 * @see SNIPPET_ForEachEntity
 * @see FOREACH_
 */
declare function LISTENFOR_ForEachEntity(params: ForEachEntityParameters): void

declare interface ForEachEntityParameters {
    /**
     * REQUIRED
     * The value returned by a FOREACH_ function.
     */
    id: number

}

/**
 * Listen for a timer to hit a certain threshold value.
 * @see SNIPPET_Timer
 * @see OUTPUT_SetNamedTimer
 *
 * @param params The parameters of the timer.
 */
declare function LISTENFOR_Timer(params: TimerParameters): void

declare interface TimerParameters {
    /**
     * REQUIRED
     * The name of the timer to check.
     */
    timerName: string

    /**
     * REQUIRED
     * The value in seconds the timer must reach before calling the snippet.
     */
    threshold: number

}

/**
 * Listen for a timer to hit a certain threshold value.
 * @see SNIPPET_LocalTimer
 *
 * @param params The parameters of the timer.
 */
declare function LISTENFOR_LocalTimer(params: LocalTimerParameters): void

declare interface LocalTimerParameters {
    /**
     * REQUIRED
     * The delay in seconds before calling the snippet.
     */
    waitTime: number

}

/**
 * Listen for a timer to hit a certain threshold value.
 * @see SNIPPET_EntityTimer
 * @see OUTPUT_SetEntityTimer
 *
 * @param params The parameters of the timer.
 */
declare function LISTENFOR_EntityTimer(params: EntityTimerParameters): void

declare interface EntityTimerParameters {
    /**
     * Optional
     * The specific entity the timer must be attached to.
     */
    entity: number

    /**
     * REQUIRED
     * The name of the timer to check.
     */
    timerName: string

}

/**
 * Listen for an entity with a `badger:trigger_criteria` attached to have entities nearby.
 */
declare function LISTENFOR_SpatialPartitionEntered(params: SpatialPartitionEnteredParameters): void

declare interface SpatialPartitionEnteredParameters {
    /**
     * REQUIRED
     * The entity with a `badger:trigger_criteria` attached to listen for entering.
     */
    triggerEntity: number

    /**
     * Optional
     * Only include these EGs.
     */
    entities: number[]

    /**
     * Optional
     * The village ID the intruder must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the intruder must belong to.
     */
    factionName: string

}

/**
 * Listen for an entity with a `badger:trigger_criteria` attached to have entities nearby.
 */
declare function LISTENFOR_SpatialPartitionExited(params: SpatialPartitionExitedParameters): void

declare interface SpatialPartitionExitedParameters {
    /**
     * REQUIRED
     * The entity with a `badger:trigger_criteria` attached to listen for exiting.
     */
    triggerEntity: number

    /**
     * Optional
     * Only include these EGs.
     */
    entities: number[]

    /**
     * Optional
     * The specific village ID the intruder must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the intruder must belong to.
     */
    factionName: string

}

/**
 * Listen for the number of entities within the spatial trigger to increase (for any reason).
 * Note this differs from @see LISTENFOR_SpatialPartitionEntered in that it will always be triggered even if
 * an entity unsuspends within the volume.
 */
declare function LISTENFOR_PresenceEntered(params: PresenceEnteredParameters): void

declare interface PresenceEnteredParameters {
    /**
     * REQUIRED
	 * The trigger volume entity.
     */
    triggerEntity: number

    /**
     * Optional
     * The exact number of entities that should be present for this listener to fire.
     */
    threshold: number

}

/**
 * Listen for the number of entities within the spatial trigger to decrease (for any reason).
 * Note this differs from @see LISTENFOR_SpatialPartitionExited in that it will always be triggered even if
 * the entity 'left' due to being destroyed, suspended, logging out of the game, etc.
 */
declare function LISTENFOR_PresenceExited(params: PresenceExitedParameters): void

declare interface PresenceExitedParameters {
    /**
     * REQUIRED
	 * The trigger volume entity.
     */
    triggerEntity: number

    /**
     * Optional
     * The exact number of entities that should be present for this listener to fire.
     */
    threshold: number

}

/**
 * Listen for players to enter a village. This is functionally similar to @see LISTENFOR_PresenceEntered but will fire
 * specifically for player entities entering a village's bounds.
 */
declare function LISTENFOR_PlayerEnteredVillage(params: PlayerEnteredVillageParameters): void

declare interface PlayerEnteredVillageParameters {
    /**
     * Optional
     * The id of the village to listen for.
     */
    villageId: number

    /**
     * Optional
     * The faction of the village to listen for.
     */
    factionName: string

    /**
     * Optional
     * size of village
     */
    villageSize: string

    /**
     * Optional
     * The exact number of players that should be present in the village for this listener to fire.
     */
    threshold: number

}

/**
 * Listen for players to exit a village. This is functionally similar to @see LISTENFOR_PresenceExited but will fire
 * specifically for player entities exiting a village's bounds.
 */
declare function LISTENFOR_PlayerExitedVillage(params: PlayerExitedVillageParameters): void

declare interface PlayerExitedVillageParameters {
    /**
     * Optional
     * The id of the village to listen for.
     */
    villageId: number

    /**
     * Optional
     * The faction of the village to listen for.
     */
    factionName: string

    /**
     * Optional
     * The Size of the village
     */
    villageSize: string

    /**
     * Optional
     * The exact number of players that should be present in the village for this listener to fire.
     */
    threshold: number

}

/**
 * Listen for any card to be played.
 */
declare function LISTENFOR_CardPlayed(params: CardPlayedParameters): void

declare interface CardPlayedParameters {
    /**
     * REQUIRED
     * The card value.
     */
    cardValue: string

}

/**
 * Listen for a horde card being played
 */
declare function LISTENFOR_HordeCardPlayed(params: HordeCardPlayedParameters): void

declare interface HordeCardPlayedParameters {
    /**
     * Optional
     * Faction name specified on the card.
     */
    factionName: string

    /**
     * Optional
     * Name of the deck the faction card is played from.
     */
    deckName: string

}

/**
 * Listen for a invaison card to be played.
 * @see INVASION_DECK_NAME
 */
declare function LISTENFOR_InvasionCardPlayed(params: InvasionCardPlayedParameters): void

declare interface InvasionCardPlayedParameters {
    /**
     * Optional
     * The faction name specified on the card.
     */
    factionName: string

    /**
     * Optional
     * The card name.
     */
    cardAction: string

    /**
     * Optional
     * The fallback card name.
     */
    cardFallbackAction: string

}

/**
 * Listen for when a global variable changes.
 */
declare function LISTENFOR_GlobalVariableChanged(params: GlobalVariableChangedParameters): void

declare interface GlobalVariableChangedParameters {
    /**
     * REQUIRED
     * The name of global variable to follow changes of.
     */
    variableName: string

}

/**
 * The ID of the `badger:buildable_spawner` to check
     */
    buildableSpawner: number

    /**
     * Optional
     * The include tags of the building to listen for. All tags must be present.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the building to listen for. No tags must be present.
     */
    excludeTags: string[]

    /**
     * Optional
     * The village ID the building must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the building must belong to. (ex. "faction.pig.attack")
     */
    factionName: string
}

/**
 * Listen for when a particular building construction is started.
 * Even for instant buildables this will still be triggered.
 */
declare function LISTENFOR_BuildingStart(params: BuildingStartParameters): void

declare interface BuildingStartParameters {
    /**
     * Optional
     * The include tags of the building to listen for. All tags must be present.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the building to listen for. No tags must be present.
     */
    excludeTags: string[]

    /**
     * Optional
     * The village ID the building must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the building must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * Whether the building was created by a player
     */
    hasCreator: boolean

}

/**
 * Listen for when a particular building is complete.
 */
declare function LISTENFOR_BuildingComplete(params: BuildingCompleteParameters): void

declare interface BuildingCompleteParameters {
    /**
     * Optional
     * The include tags of the building to listen for. All tags must be present.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the building to listen for. No tags must be present.
     */
    excludeTags: string[]

    /**
     * Optional
     * The village ID the building must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the building must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * Whether the building was created by a player
     */
    hasCreator: boolean

}

/**
 * Listen for when a particular building fails to place.
 */
declare function LISTENFOR_BuildingFailedToPlace(params: BuildingFailedToPlaceParameters): void

declare interface BuildingFailedToPlaceParameters {
    /**
     * Optional
     * The build card name (buildable card type only!).
     */
    cardValue: string

    /**
     * Optional
     * The village the build card belongs to.
     */
    villageId: number

}

/**
 * Listener for when a particular entity is spawned.
 * Only entities that are marked to have their spawning tracked will be detected by this
 * listener. See template_mob and template_piglin for examples of spawn tracking.
 */
declare function LISTENFOR_EntitySpawned(params: EntitySpawnedParameters): void

declare interface EntitySpawnedParameters {
    /**
     * Optional
     * Required tags for spawned entities.
     */
    includeTags: string[]

    /**
     * Optional
     * Required tags for spawned entities to not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * Required village ID for spawned entities.
     */
    villageId: number

    /**
     * Optional
     * The faction name the entity must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

}

/**
 * Listener for when a particular entity type is refunded through the buildable spawner refund system
 */
declare function LISTENFOR_EntityRefunded(params: EntityRefundedParameters): void

declare interface EntityRefundedParameters {
    /**
     * Optional
     * Required tags for refunded entities.
     */
    includeTags: string[]

    /**
     * Optional
     * Required tags for refunded entities to not have.
     */
    excludeTags: string[]

}

/**
 * Listen for an entity spawned by a spawner (eg. barracks).
 */
declare function LISTENFOR_BuildableSpawnerSpawned(params: BuildableSpawnerSpawnedParameters): void

declare interface BuildableSpawnerSpawnedParameters {
    /**
     * REQUIRED
     * The spawner entity.
     */
    buildableSpawner: number

    /**
     * Optional
     * Tags the spawned entity must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the spawned entity must not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * The owner village ID of the spawner and spawnee.
     */
    villageId: number

    /**
     * Optional
     * The owner faction name of the spawner and spawnee.
     */
    factionName: string

}

/**
 * Listens for a batch of entities spawned by a spawner (eg. barracks).
 */
declare function LISTENFOR_BuildableSpawnerBatchSpawned(params: BuildableSpawnerBatchSpawnedParameters): void

declare interface BuildableSpawnerBatchSpawnedParameters {
    /**
     * Optional
     * The spawner entity
     */
    buildableSpawner: number

    /**
     * Optional
     * Tags the spawner must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the spawner must not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * The owner village ID of the spawner and spawnee.
     */
    villageId: number

    /**
     * Optional
     * The owner faction name of the spawner and spawnee.
     */
    factionName: string

}

/**
 * Listen for when a particular entity is destroyed.
 */
declare function LISTENFOR_NonPopCappedEntityDestroyed(params: NonPopCappedEntityDestroyedParameters): void

declare interface NonPopCappedEntityDestroyedParameters {
    /**
     * Optional
     * Required tags for destroyed entities.
     */
    includeTags: string[]

    /**
     * Optional
     * Required tags for destroyed entities to not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * The entities to only check for.
     */
    entities: number[]

    /**
     * Optional
     * The village ID the entity must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the entity must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * Trigger on despawn (true) or destroy (false). Omitting this rule will trigger in either context.
     */
    despawned: boolean

    /**
     * Optional
     * The team of the entity that destroys the host entity.
     */
    destroyerTeamName: string

}

/**
 * Listen for whether a particular pop-cappable entity is killed
 */
declare function LISTENFOR_PopCappedEntityDestroyed(params: PopCappedEntityDestroyedParameters): void

declare interface PopCappedEntityDestroyedParameters {
    /**
     * Optional
     * Required tags for destroyed entities.
     */
    includeTags: string[]

    /**
     * Optional
     * Required tags for destroyed entities to not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * The entities to only check for.
     */
    entities: number[]

    /**
     * Optional
     * The village ID the entity must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the entity must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * Trigger on despawn (true) or destroy (false). Omitting this rule will trigger in either context.
     */
    despawned: boolean

    /**
     * Optional
     * The team of the entity that destroys the host entity.
     */
    destroyerTeamName: string

}

/**
 * Listen for a specific number of entities in a group to be destroyed.
 */
declare function LISTENFOR_EntitiesAmountDestroyed(params: EntitiesAmountDestroyedParameters): void

declare interface EntitiesAmountDestroyedParameters {
    /**
     * REQUIRED
     * The entities to monitor.
     */
    entities: number[]

    /**
     * Optional
     * The amount of entities that need to be destroyed before triggering the snippet.
     * If no amount is provided, all entities will be required to be destroyed.
     */
    amount: number

}

/**
 * Listen for when an EG changes health.
 */
declare function LISTENFOR_HealthChanged(params: HealthChangedParameters): void

declare interface HealthChangedParameters {
    /**
     * Optional
     * Tags the entities must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the entities must not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * Only listen for these entities.
     */
    entities: number[]

    /**
     * Optional
     * The specific village ID the building must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the building must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * The health threshold to cross to trigger this listener.
     * Range from 0 to 1.
     * absoluteThreshold must **not** be set.
     */
    normalizedThreshold: number

    /**
     * Optional
     * The health threshold to cross to trigger this listener.
     * normalizedThreshold must **not** be set.
     */
    absoluteThreshold: number

    /**
     * Optional
     * When to trigger in relation to the threshold. Must be set if a threshold is used.
     * See `HEALTH_TRIGGER_MODE` for valid options.
     */
    triggerMode: number

    /**
     * Optional
     * Trigger only on damage, healing, or both if unset.
     */
    direction: number

}

/**
 * Listen for when a culture's values increases over a threshold.
 */
declare function LISTENFOR_CultureValueChangedUp(params: CultureValueChangedUpParameters): void

declare interface CultureValueChangedUpParameters {
    /**
     * Optional
     * The *crossing* threshold for the A value. At least one of the thresholds must be set.
     */
    thresholdA: number

    /**
     * Optional
     * The *crossing* threshold for the B value. At least one of the thresholds must be set.
     */
    thresholdB: number

    /**
     * Optional
     * The *crossing* threshold for the C value. At least one of the thresholds must be set.
     */
    thresholdC: number

    /**
     * Optional
     * The id of the village to check for.
     */
    villageId: number

}

/**
 * Listen for when a culture's values decreases below a threshold.
 */
declare function LISTENFOR_CultureValueChangedDown(params: CultureValueChangedDownParameters): void

declare interface CultureValueChangedDownParameters {
    /**
     * Optional
     * The *crossing* threshold for the A value. At least one of the thresholds must be set.
     */
    thresholdA: number

    /**
     * Optional
     * The *crossing* threshold for the B value. At least one of the thresholds must be set.
     */
    thresholdB: number

    /**
     * Optional
     * The *crossing* threshold for the C value. At least one of the thresholds must be set.
     */
    thresholdC: number

    /**
     * Optional
     * The id of the village to check for.
     */
    villageId: number

}

/**
 * Please come talk to the B-Team if you need to use this.
 *
 */
declare function LISTENFOR_TriggerEvent(params: TriggerEventParameters): void

declare interface TriggerEventParameters {
    /**
     * REQUIRED
     * The name of the trigger.
     */
    triggerName: string

    /**
     * Optional
     * Only listen for these entities.
     */
    entities: number[]

}

/**
 * Listen for when a teams resource changes.
 */
declare function LISTENFOR_ResourcesChanged(params: ResourcesChangedParameters): void

declare interface ResourcesChangedParameters {
    /**
     * REQUIRED
     * Only trigger on this resource
     * @example "wood"
     */
    resourceName: string

    /**
     * Optional
     * Only trigger for this team.
     */
    teamName: string

}

/**
 *
 */
declare function LISTENFOR_TetherOverLimit(params: TetherOverLimitParameters): void

declare interface TetherOverLimitParameters {
    /**
     * REQUIRED
     * The entity to host the tether. Should be a single entity with PositionComponent.
     */
    rootEntity: number

    /**
     * REQUIRED
     * The entity that is tethered to the root.
     */
    tetherEntity: number

}

/**
 * Listen for generic events to be triggered.
 */
declare function LISTENFOR_ExternalEvent(params: ExternalEventParameters): void

declare interface ExternalEventParameters {
    /**
     * REQUIRED
     * Only trigger when this event is called.
     * @see "aaa_global_const.js"
     * @example "InterestingEvent"
     */
    eventName: string

}

/**
 * Listen for a base to finish all of its ticketed builds.
 * @see BaseBuildsFinishedParameters
 *
 * @param params The parameters of the timer.
 */
declare function LISTENFOR_BaseBuildsFinished(params: BaseBuildsFinishedParameters): void

declare interface BaseBuildsFinishedParameters {
    /**
     * Optional
     * The faction name the village must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * The specific village ID.
     */
    villageId: number

}

/**
 * Listen for when a POI is generated
 *
   @param params The parameters of the listener.
 */
declare function LISTENFOR_POIGenerated(params: POIGeneratedParameters): void

declare interface POIGeneratedParameters {
    /**
     * REQUIRED
     * The short name of the POI type to listen to for generation.
     */
    poiTypeName: string

}

/**
 * Listen for when a village is generated
 *
   @param params The parameters of the listener.
 */
declare function LISTENFOR_VillageGenerated(params: VillageGeneratedParameters): void

declare interface VillageGeneratedParameters {
    /**
     * REQUIRED
     * The faction name the village must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * The village size. (ex. "medium")
     */
    villageSize: string

}

/**
 * Listen for when a village finished upgrading.
 */
declare function LISTENFOR_VillageUpgraded(params: VillageUpgradedParameters): void

declare interface VillageUpgradedParameters {
    /**
     * Optional
     * The faction name the village must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * The specific village ID.
     */
    villageId: number

    /**
     * Optional
     * The village size of the village being upgraded.
     */
    sourceVillageSize: string

    /**
     * Optional
     * The village size of the upgraded village.
     */
    targetVillageSize: string

}

/**
 * Listen for when the village and all of its instant buildings are generated
 */
declare function LISTENFOR_VillageFinishedBuilding(params: VillageFinishedBuildingParameters): void

declare interface VillageFinishedBuildingParameters {
    /**
     * Optional
     * The specific village ID.
     */
    villageId: number

}

/**
 * Listen for when the village and all of its instant buildings are planned.
 */
declare function LISTENFOR_VillageFinishedPlanning(params: VillageFinishedPlanningParameters): void

declare interface VillageFinishedPlanningParameters {
    /**
     * Optional
     * The faction name the village must belong to. (ex. "faction.pig.attack")
     */
    factionName: string

    /**
     * Optional
     * The specific village ID.
     */
    villageId: number

}

/**
 * Listen for a village to be destroyed. A village can only ever be destroyed once.
 */
declare function LISTENFOR_VillageDestroyed(params: VillageDestroyedParameters): void

declare interface VillageDestroyedParameters {
    /**
     * Optional
     * The faction name of the village(s).
     */
    factionName: string

    /**
     * Optional
     * The village size. (ex. "medium")
     */
    villageSize: string

    /**
     * Optional
     * The specific village ID.
     */
    villageId: number

    /**
     * Optional
     * false: trigger on gameplay destroyed (eg. player destroys a base, `/ad` command, etc.)
     * true: trigger on system despawned (eg. upgrading a base, FOB despawn on auto-resolve)
     * none: both of above
     */
    despawned: boolean

}

/**
 * Listen for a village to be planned. A village may not have all its information at this stage.
 * Triggered before `LISTENFOR_VillageGenerated`
 */
declare function LISTENFOR_VillagePlanned(params: VillagePlannedParameters): void

declare interface VillagePlannedParameters {
    /**
     * Optional
     * The faction name of the village(s).
     */
    factionName: string

    /**
     * Optional
     * The village size. (ex. "medium")
     */
    villageSize: string

}

/**
 * @see FobGeneratedParameters
 */
declare function LISTENFOR_InvasionAttackV2FobGenerated(params: InvasionAttackV2FobGeneratedParameters): void

declare interface InvasionAttackV2FobGeneratedParameters {
    /**
     * Optional
     * The attacking faction name.
     */
    factionName: string

    /**
     * Optional
     * The invasion ID.
     */
    invasionId: number

}

/**
 * Listen for when an event occurs during a cinematic.
 */
declare function LISTENFOR_CinematicEvent(params: CinematicEventParameters): void

declare interface CinematicEventParameters {
    /**
     * REQUIRED
     * Only trigger when this event is called.
     */
    eventName: string

    /**
     * Optional
     * Id of a particular cinematic instance this listener should respond to.
     */
    cinematicId: number

}

/**
 * Listen for when a specific cinematic starts playing.
 */
declare function LISTENFOR_CinematicStarted(params: CinematicStartedParameters): void

declare interface CinematicStartedParameters {
    /**
     * REQUIRED
     * The name of the cinematic being listened for.
     */
    cinematicName: string

}

/**
 * Listen for when a specific cinematic finishes playing.
 */
declare function LISTENFOR_CinematicFinished(params: CinematicFinishedParameters): void

declare interface CinematicFinishedParameters {
    /**
     * REQUIRED
     * The name of the cinematic being listened for.
     */
    cinematicName: string

}

/**
 * Listen for when a client interacts with an entity.
 */
declare function LISTENFOR_PlayerInteracted(params: PlayerInteractedParameters): void

declare interface PlayerInteractedParameters {
    /**
     * Optional
     * Player entity to filter on.
     */
    playerEntity: number

    /**
     * Optional
     * Interactable entities to filter on.
     */
    entities: number[]

    /**
     * Optional
     * The include tags of the interactable to listen for. All tags must be present.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the interactable to listen for. No tags must be present.
     */
    excludeTags: string[]

    /**
     * Optional
     * Team filter for the interacting player.
     */
    teamName: string

    /**
     * Optional
     * The village ID
     */
    villageId: number

    /**
     * Optional
     * The faction of the interactable entity.
     */
    factionName: string

}

/**
 * Listen for when a client player opens/selects a HUD element.
 * Triggers on **any** player. Only triggers when the HUD element is hidden.
 */
declare function LISTENFOR_HudEvent(params: HudEventParameters): void

declare interface HudEventParameters {
    /**
     * REQUIRED
     * The HUD event name.
     */
    eventName: string

}

/**
 * @see InvasionDestroyEntitiesObjectiveParameters
 */
declare function LISTENFOR_InvasionDestroyEntitiesObjective(params: InvasionDestroyEntitiesObjectiveParameters): void

declare interface InvasionDestroyEntitiesObjectiveParameters {
    /**
     * Optional
     * The village ID the objective must belong to.
     */
    villageId: number

    /**
     * Optional
     * The number of objective entities left.
     */
    threshold: number

}

/**
 * Listen to when the intentions can be finally drawn.
 * This may be triggered immediately upon calling the corresponding OUTPUT or with a delay.
 * Time of trigger depends entirely on how many processes from the previous night are still ongoing.
 */
declare function LISTENFOR_InvasionIntentionsDrawn(params: InvasionIntentionsDrawnParameters): void

declare interface InvasionIntentionsDrawnParameters {
}

/**
 * Listen for when invasion actions are executed at night.
 */
declare function LISTENFOR_InvasionActionsExecuted(params: InvasionActionsExecutedParameters): void

declare interface InvasionActionsExecutedParameters {
}

/**
 * Listen to perform any logic related to when the invasion night begins. Triggers when all invasions action for the night are done executing.
 */
declare function LISTENFOR_InvasionNightActionsResolved(params: InvasionNightActionsResolvedParameters): void

declare interface InvasionNightActionsResolvedParameters {
}

/**
 * Listen to apply an oops effect to a base. Triggered when the base is loaded.
 */
declare function LISTENFOR_InvasionOopsApply(params: InvasionOopsApplyParameters): void

declare interface InvasionOopsApplyParameters {
    /**
     * Optional
     * The faction name of the piglins.
     */
    factionName: string

}

/**
 * Listen to when a delayed invasion action is executed.
 * @see `OUTPUT_ExecuteAllDelayedInvasionActions`
 */
declare function LISTENFOR_InvasionDelayedActionExecuted(params: InvasionDelayedActionExecutedParameters): void

declare interface InvasionDelayedActionExecutedParameters {
    /**
     * Optional
     * The action name.
     */
    invasionAction: string

}

/**
 * Listen for when a certain time of day occurs
 */
declare function LISTENFOR_TimeOfDay(params: TimeOfDayParameters): void

declare interface TimeOfDayParameters {
    /**
     * Optional
     * badger time to listen for (number from 0 to 1)
     * Cannot be set if 'timeOfDayName' is set
     */
    timeOfDayNumber: number

    /**
     * Optional
     * Maps to a time defined in the time and weather service.
     * Cannot be set if 'timeOfDayNumber' is set
     */
    timeOfDayName: string

}

/**
 * Listen for when a specific tag is added to entities.
 */
declare function LISTENFOR_TagAdded(params: TagAddedParameters): void

declare interface TagAddedParameters {
    /**
     * Optional
     * Entities to filter by.
     */
    entities: number[]

    /**
     * REQUIRED
     * The tag to listen for being added.
     */
    tag: string

}

/**
 * Listen for when a specific tag is removed to entities.
 */
declare function LISTENFOR_TagRemoved(params: TagRemovedParameters): void

declare interface TagRemovedParameters {
    /**
     * Optional
     * Entities to filter by.
     */
    entities: number[]

    /**
     * REQUIRED
     * The tag to listen for being removed.
     */
    tag: string

}

/**
 * Listen for when an entity is lured or stops being lured.
 */
declare function LISTENFOR_InfluenceLureChanged(params: InfluenceLureChangedParameters): void

declare interface InfluenceLureChangedParameters {
    /**
     * Optional
     * The entities to detect influencing of.
     */
    entities: number[]

    /**
     * Optional
     * The include tags of the entities to listen for. All tags must be present.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the entities to listen for. No tags must be present.
     */
    excludeTags: string[]

    /**
     * Optional
     * The village id of the village that owns the influenced entity.
     */
    villageId: number

    /**
     * Optional
     * The faction that owns the influenced entity.
     */
    factionName: string

    /**
     * Optional
     * The team that the influenced entity is on.
     */
    teamName: string

}

/**
 * Listen for when an entity is directed or stops being directed.
 *
 *
 */
declare function LISTENFOR_InfluenceDirectorChanged(params: InfluenceDirectorChangedParameters): void

declare interface InfluenceDirectorChangedParameters {
    /**
     * Optional
     * The entities to detect influencing of.
     */
    entities: number[]

    /**
     * Optional
     * The include tags of the entities to listen for. All tags must be present.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the entities to listen for. No tags must be present.
     */
    excludeTags: string[]

    /**
     * Optional
     * The village id of the village that owns the influenced entity.
     */
    villageId: number

    /**
     * Optional
     * The faction that owns the influenced entity.
     */
    factionName: string

    /**
     * Optional
     * The team that the influenced entity is on.
     */
    teamName: string

}

/**
 * Listen for the player directing a mob with given orders and filters. Called for every mob being directed
 */
declare function LISTENFOR_PlayerDirectedMob(params: PlayerDirectedMobParameters): void

declare interface PlayerDirectedMobParameters {
    /**
     * Optional
     * the name of the action that the player used to direct the mob
     */
    targetAction: string

    /**
     * Optional
	 * ONE OF - pick either this or restrictedFilterTag
     * Compared against the filters of the direct option being applied. Requires the filters to include this tag 
     * eg. "ranged" to only fire for ranged advanced direct option
     */
    requiredFilterTag: string

    /**
     * Optional
	 * ONE OF - pick either this or requiredFilterTag
     * Compared against the filters of the direct option being applied. The filters cannot use this tag 
     * eg. "mob" to fire for any advanced filter
     */
    restrtictedFilterTag: string

}

/**
 * Listen when a structure has **begun** to deconstruct.
 */
declare function LISTENFOR_DeconstructionStarted(params: DeconstructionStartedParameters): void

declare interface DeconstructionStartedParameters {
    /**
     * Optional
     * The specific structure entities.
     */
    entities: number[]

    /**
     * Optional
     * The specific deconstructor entity (ex. a player).
     */
    deconstructorEntity: number

    /**
     * Optional
     * Tags the structure must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the structure must not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * The village ID the structure must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the structure must belong to.
     */
    factionName: string

    /**
     * Optional
     * The team the structure must belong to.
     */
    teamName: string

}

/**
 * Listens for entity that is supposed to be killed (by damage) but is B# deferred.
 * @see OUTPUT_SetDeferredDeath
 */
declare function LISTENFOR_DeferredDeath(params: DeferredDeathParameters): void

declare interface DeferredDeathParameters {
    /**
     * Optional
     * The specific entities.
     */
    entities: number[]

    /**
     * Optional
     * The village ID the entity must belong to.
     */
    villageId: number

    /**
     * Optional
     * The faction name the entity must belong to.
     */
    factionName: string

    /**
     * Optional
     * The team the entity must belong to.
     */
    teamName: string

    /**
     * Optional
     * Tags the entity must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the entity must not have.
     */
    excludeTags: string[]

}

/**
 * Listen for a specific game rule to change.
 */
declare function LISTENFOR_GameRuleChanged(params: GameRuleChangedParameters): void

declare interface GameRuleChangedParameters {
    /**
     * REQUIRED
     * The name of the rule that was modified.
     */
    ruleName: string

    /**
     * Optional
     * The value that the rule was set to. Could be a string, number, or boolean, depending
     * on the rule that was changed.
     */
    value: any

}

/**
 * Listen for players re/connecting to the game.
 * Note: Currently this can trigger during the loading screen.
 */
declare function LISTENFOR_PlayerConnected(params: PlayerConnectedParameters): void

declare interface PlayerConnectedParameters {
}

/**
 * Listen for players disconnecting from the game.
 * Note: Currently this can trigger during the loading screen.
 * Will not trigger unless the player has triggered LISTENFOR_PlayerConnected first.
 */
declare function LISTENFOR_PlayerDisconnected(params: PlayerDisconnectedParameters): void

declare interface PlayerDisconnectedParameters {
}

/**
 * Listen for a particular test to be started.
 */
declare function LISTENFOR_TestStarted(params: TestStartedParameters): void

declare interface TestStartedParameters {
    /**
     * REQUIRED
     * The name of the test to detect the start of.
     */
    testName: string

}

/**
 * Listen for entities being disabled
 */
declare function LISTENFOR_EntityDisabled(params: EntityDisabledParameters): void

declare interface EntityDisabledParameters {
    /**
     * Optional
     * The particular entity being disabled
     */
    disabledEntity: number

    /**
     * Optional
     * The entity's owner village, or the village entity's id.
     */
    villageId: number

}

/**
 * Listen for entities being enabled
 */
declare function LISTENFOR_EntityEnabled(params: EntityEnabledParameters): void

declare interface EntityEnabledParameters {
    /**
     * Optional
     * The particular entity being enabled
     */
    enabledEntity: number

    /**
     * Optional
     * The entity's owner village, or the village entity's id.
     */
    villageId: number

}

/**
 * Listen for generic card to be played, like a flavour or objective base variation card.
 */
declare function LISTENFOR_GenericCardPlayed(params: GenericCardPlayedParameters): void

declare interface GenericCardPlayedParameters {
    /**
     * REQUIRED
     * The category string for the type of generic card. Eg: "flavour", "objective".
     */
    cardCategory: string

    /**
     * Optional
     * The card being played.
     */
    cardValue: string

}

/**
 * Listen for Advanced Direct being toggled on or off based on the
 */
declare function LISTENFOR_AdvancedDirectToggle(params: AdvancedDirectToggleParameters): void

declare interface AdvancedDirectToggleParameters {
    /**
     * Optional
     * Whether the listener will fire when the player opens (true) or closes (false) advanced direct
     */
    onOpen: boolean

}

/**
 * Listen for when the player is ready
 */
declare function LISTENFOR_PlayersReady(params: PlayersReadyParameters): void

declare interface PlayersReadyParameters {
}

/**
 * Listen for when a player fast travels
 */
declare function LISTENFOR_PlayerFastTravelled(params: PlayerFastTravelledParameters): void

declare interface PlayerFastTravelledParameters {
}

/**
 * Listen for when a player mounts a mount.
 */
declare function LISTENFOR_PlayerMounted(params: PlayerMountedParameters): void

declare interface PlayerMountedParameters {
    /**
     * Optional
     * The name of a specific mount to listen for.
     */
    mountName: string

}

/**
 * Listen for when player action (eg. destroying a base) can be performed
 * during **invasion simulation**. Do not use this in actual gameplay.
 */
declare function LISTENFOR_InvasionPlayerActionsExecuted(params: InvasionPlayerActionsExecutedParameters): void

declare interface InvasionPlayerActionsExecutedParameters {
}

/**
 * Listen for when an entity is within proximity of a player. Requires setting up ab observer via `OUTPUT_CreatePlayerProximityObserver`.
 */
declare function LISTENFOR_EntityEnteredPlayerProximity(params: EntityEnteredPlayerProximityParameters): void

declare interface EntityEnteredPlayerProximityParameters {
    /**
     * REQUIRED
	 * The name of the observer to check (see `OUTPUT_CreatePlayerProximityObserver` for details on authoring one)
     */
    observerName: string

}

/**
 * Listens for when the game difficulty changes
 */
declare function LISTENFOR_DifficultyChanged(params: DifficultyChangedParameters): void

declare interface DifficultyChangedParameters {
}

/**
 * Listen for when entities get recalled by a player.
 * 
 * @param params The param
 */
declare function LISTENFOR_EntityRecalled(params: EntityRecalledParameters): void

declare interface EntityRecalledParameters {
    /**
     * Optional
     * The include tags of the mobs to listen for recall.
     */
    includeTags: string[]

    /**
     * Optional
     * The exclude tags of the mobs to listen for recall.
     */
    excludeTags: string[]

}

/**
 * Listen for when the status effect was applied on some entity.
 */
declare function LISTENFOR_StatusEffectStarted(params: StatusEffectStartedParameters): void

declare interface StatusEffectStartedParameters {
    /**
     * Optional
     * Status effect name e.g. "wet", "burning", etc.
     */
    statusEffectName: string

    /**
     * Optional
     * Tags the entity must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the entity must not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * Village the entity must belong to.
     */
    villageId: number

    /**
     * Optional
     * Horde the entity must belong to.
     */
    factionName: string

}

/**
 * Listen for when the status effect was expired on some entity.
 */
declare function LISTENFOR_StatusEffectExpired(params: StatusEffectExpiredParameters): void

declare interface StatusEffectExpiredParameters {
    /**
     * Optional
     * Status effect name e.g. "wet", "burning", etc.
     */
    statusEffectName: string

    /**
     * Optional
     * Tags the entity must have.
     */
    includeTags: string[]

    /**
     * Optional
     * Tags the entity must not have.
     */
    excludeTags: string[]

    /**
     * Optional
     * Village the entity must belong to.
     */
    villageId: number

    /**
     * Optional
     * Horde the entity must belong to.
     */
    factionName: string

}

/**
 * **`WARNING! WARNING! NO REFUGE!`** Do not use this outside onboarding or flatland game modes. Any logic that depends on this cannot be reliably guarunteed over the network or savegames. If this is used in campaign or PvP, it will likely not be able to ship.
 * 
 * Triggers a listener when a cue from `vo_sequence_definitions.json` finishes on a client.
 * 
 * An example cue looks like the following:
 * ```json
 * {
 *  "type": "cue",
 *  "name": "test_cue"
 * }
 * ```
 */
declare function LISTENFOR_ClientVOCueFinished(params: ClientVOCueFinishedParameters): void

declare interface ClientVOCueFinishedParameters {
    /**
     * REQUIRED
     * The name of the VO sequence cue in `vo_sequence_definitions.json`
     */
    vo_sequence_cue_name: string

}

/**
 * Listener logic for when a player performs a target action.
 */
declare function LISTENFOR_PlayerPerformedTargetAction(params: PlayerPerformedTargetActionParameters): void

declare interface PlayerPerformedTargetActionParameters {
    /**
     * REQUIRED
	 * The target action to listen for.
     */
    targetAction: string

    /**
     * Optional
    * Player entities to filter on. If no entities are provided, this listener will listen for *all* players.
     */
    playerEntities: number[]

}

/**
 * Listener to respond to a village attack damage request. Ensures a village is unsuspended so that entities can be 
 * damaged or destroyed without a player present.
 */
declare function LISTENFOR_InvasionAttackV2DamageRequest(params: InvasionAttackV2DamageRequestParameters): void

declare interface InvasionAttackV2DamageRequestParameters {
    /**
     * Optional
     * The attacking piglin's faction name.
     */
    factionName: string

    /**
     * Optional
     * The village ID of the village under attack.
     */
    villageId: number

}

/**
 * Listener for following up a damage request. Guaranteed to trigger one tick after the original damage request so that damaged entities'
 * damage requests are processed in time to be queried by bsharp.
 */
declare function LISTENFOR_InvasionAttackV2PostDamageRequest(params: InvasionAttackV2PostDamageRequestParameters): void

declare interface InvasionAttackV2PostDamageRequestParameters {
    /**
     * Optional
     * The attacking piglin's faction name.
     */
    factionName: string

    /**
     * Optional
     * The village ID of the village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2StartedParameters
 */
declare function LISTENFOR_InvasionAttackV2Started(params: InvasionAttackV2StartedParameters): void

declare interface InvasionAttackV2StartedParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2ActivatedParameters
 */
declare function LISTENFOR_InvasionAttackV2Activated(params: InvasionAttackV2ActivatedParameters): void

declare interface InvasionAttackV2ActivatedParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2AbandonedParameters
 */
declare function LISTENFOR_InvasionAttackV2Abandoned(params: InvasionAttackV2AbandonedParameters): void

declare interface InvasionAttackV2AbandonedParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2ReactivatedParameters
 */
declare function LISTENFOR_InvasionAttackV2Reactivated(params: InvasionAttackV2ReactivatedParameters): void

declare interface InvasionAttackV2ReactivatedParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2OvertimeParameters
 */
declare function LISTENFOR_InvasionAttackV2Overtime(params: InvasionAttackV2OvertimeParameters): void

declare interface InvasionAttackV2OvertimeParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2ResolveParameters
 */
declare function LISTENFOR_InvasionAttackV2Resolve(params: InvasionAttackV2ResolveParameters): void

declare interface InvasionAttackV2ResolveParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}

/**
 * @see InvasionAttackV2EndedParameters
 */
declare function LISTENFOR_InvasionAttackV2Ended(params: InvasionAttackV2EndedParameters): void

declare interface InvasionAttackV2EndedParameters {
    /**
     * Optional
     * The attacking faction.
     */
    factionName: string

    /**
     * Optional
     * The village under attack.
     */
    villageId: number

}


// FILE CONTENTS: bsharp_api_misc.d.ts

/**
 * Called from within a snippet. Stops the listener that resulted in this snippet from listening.
 * ie. The snippet will only be run once.
 */
declare function Once(): void

/**
 * The target info object for the rally point launch functions.
 */
declare interface TargetInfo {
    /**
     * REQUIRED.
     * The target entity.
     * If an empty entity group is given this target info is ignored.
     * If more than one entity is given one will be selected randomly.
     */
    target: number[]

    /**
     * REQUIRED.
     * The distribution of entities for this target.
     * The higher the number the more entities will be sent to the target.
     */
    weight: number

    /**
     * Optional.
     * If true the units will track the target. If false the units will move to position.
     * If not set it will move to position.
     */
    follow: boolean

    /**
     * Optional.
     * A `MoveCallback` to trigger a `SNIPPET_MoveCallback`.
     * If not set no callback will be triggered.
     */
    callback: number
}


// FILE CONTENTS: bsharp_api_operations.gen.d.ts


/**
 * Combine all entities from two sets that preserves order and ALLOWS duplicates.
 * @see OPER_Union In most cases use OPER_Union to join two sets of entities without duplicates.
 * @returns Entities from first and second, in given order and including duplicates.
 *
 * @param firstGroup The first set of entities. Order DOES matter.
 * @param secondGroup The second set of entities. Order DOES matter.
 */
declare function OPER_Append(firstGroup: number[], secondGroup: number[]): number[]

/**
 * Subtracts a set of entities from another and gets the resulting set.
 * @returns Entities that are in the first set but not in the second set.
 *
 * @param firstGroup The first set of entities. Order DOES matter.
 * @param secondGroup The second set of entities. Order DOES matter.
 */
declare function OPER_Difference(firstGroup: number[], secondGroup: number[]): number[]

/**
 * Gets all the entities from two entity sets which are present in both sets (not just one of them).
 * @returns Entiies that are present in the first set AND the second set.
 *
 * @param firstGroup The first set of entities. Order does NOT matter.
 * @param secondGroup The second set of entities. Order does NOT matter.
 */
declare function OPER_Intersection(firstGroup: number[], secondGroup: number[]): number[]

/**
 * Gets all the entities from two given EGs that are NOT present in both EGs. Ie. an anti-intersection
 * @see OPER_Intersection ; also know as an 'Exclusive OR operation'.
 * @returns Entities that are only present in either first or second. ie. excludes entities that are in both first and second => DIFFERENCE(UNION(A,B), INTERSECTION(A,B)).
 *
 * @param firstGroup The first set of entities. Order does NOT matter.
 * @param secondGroup The second set of entities. Order does NOT matter.
 */
declare function OPER_SymDifference(firstGroup: number[], secondGroup: number[]): number[]

/**
 * Joins two sets of entities together and returns the result.
 * Will not return duplicate entities.
 * @returns All entities from the first and second sets.
 *
 * @param firstGroup The first set of entities. Order does NOT matter.
 * @param secondGroup The second set of entities. Order does NOT matter.
 */
declare function OPER_Union(firstGroup: number[], secondGroup: number[]): number[]


// FILE CONTENTS: bsharp_api_outputs.gen.d.ts


/**
 * Give or take resources to a specific entity. If it is a team resource the resource will automatically be given to the team.
 * The resource must exist (you cannot create new ones!).
 *
 * @param entities The entities to give the resource to.
 * @param resourceName The resource ID (eg. "wood")
 * @param amount The amount. Positive to give, negative to take.
 * @param overcap If adding resources can exceed the inventory cap.
 */
declare function OUTPUT_AddOrRemoveResource(entities: number[], resourceName: string, amount: number, overcap: boolean): void

/**
 * Give or take resources to a team.
 * The resource must exist (you cannot create new ones!).
 *
 * @param team The team to give the resource to.
 * @param resourceName The resource ID (eg. "wood")
 * @param amount The amount. Positive to give, negative to take.
 * @param overcap If adding resources can exceed the inventory cap.
 */
declare function OUTPUT_AddOrRemoveTeamResource(team: string, resourceName: string, amount: number, overcap: boolean): void

/**
 * Adds progress to an objective showing up on the playes map. Needs to be added to objectives_data.json
 *
 * @param objectiveName The name of the objective. This should be the same as the lang file text
 * @param amount The amount to change, postiive or negative
 */
declare function OUTPUT_AddOrSubtractObjectiveProgress(objectiveName: string, amount: number): void

/**
 * Adds a tag to an entity's tag set.
 *
 * @param entities The entiies to add the tag to.
 * @param tag The tag to be added.
 */
declare function OUTPUT_AddTag(entities: number[], tag: string): void

/**
 * Adds a tether between two entities with a certain length.
 *
 * @param rootEntity The entity to host the tether.
 * @param tetherEntities The entities to tether to the root entity.
 * @param distance The maximum distance between the tethered entities before the tether breaks.
 */
declare function OUTPUT_AddTether(rootEntity: number, tetherEntities: number[], distance: number): void

/**
 * Triggers a persistent presentation event from a given entity. (like `OUTPUT_TriggerPresentationEvent`)
 * The targeted entity's data must support the requested presentation effect.
 * Use this output if the entity needs to persist presentation state on save/load (eg. keep a chest open).
 *
 * @param entities Entities to trigger the event on.
 * @param state The name of the event to trigger, as defined in the entity's data.
 */
declare function OUTPUT_AddVisualState(entities: number[], state: string): void

/**
 * Adds a waypoint icon to an entity that doesn't have one. To determine which waypoint icon to add,
 * another entity with a `"badger:waypoint_marker"` is used as a reference.
 *
 * @param archetype The existing entity archetype to reference. (eg: `"badger:onboarding_waypoint_marker"`, `"badger:player_marker_03"`, etc.)
 * @param entity The entity to attach the waypoint marker to.
 */
declare function OUTPUT_AddWaypointIconByExistingEntityArchetype(archetype: string, entity: number): void

/**
 * Announces a message to the HUD.
 *
 * @param messageId The message id associated with message data in hud_text_messages.json
 * @param params The list of message parameters to be localized.
 */
declare function OUTPUT_Announce(messageId: string, params: string[]): void

/**
 * Sends message to interrupt current priority message 
 *
 * @param messagePriority Message type to interrupt
 */
declare function OUTPUT_AnnounceInterrupt(messagePriority: number): void

/**
 * Sends message to interrupt current priority message for a particular player
 *
 * @param messagePriority Message priority to interrupt
 * @param playerEntity The player to interrupt the message for
 */
declare function OUTPUT_AnnounceInterruptPlayer(messagePriority: number, playerEntity: number): void

/**
 * Announce a message to a specific player's HUD.
 *
 * @param messageId The message id associated with message data in hud_text_messages.json
 * @param params The list of message parameters to be localized.
 * @param playerEntity The specific player.
 */
declare function OUTPUT_AnnouncePlayer(messageId: string, params: string[], playerEntity: number): void

/**
 * Queue a hud event sequence to play
 *
 * @param sequenceId The event id associated with the hud event sequence
 */
declare function OUTPUT_AnnounceSequence(sequenceId: string): void

/**
 * Queue a hud event sequence to play for specific player
 *
 * @param sequenceId The event id associated with the hud event sequence
 * @param playerEntity The player id to announce the message to.
 */
declare function OUTPUT_AnnounceSequencePlayer(sequenceId: string, playerEntity: number): void

/**
 * Queue a hud event sequence to play for specific team
 *
 * @param sequenceId The event id associated with the hud event sequence
 * @param teamName The name of the team to announce the message to.
 */
declare function OUTPUT_AnnounceSequenceTeam(sequenceId: string, teamName: string): void

/**
 * Announces a message to the HUD for a specific team.
 *
 * @param messageId The message id associated with message data in hud_text_messages.json
 * @param params The list of message parameters to be localized.
 * @param teamName The name of the team to announce the message to.
 */
declare function OUTPUT_AnnounceTeam(messageId: string, params: string[], teamName: string): void

/**
 * Sets up entities to be tracked by an existing Destroy Entities Objective.
 * This will not change the count required to be destroyed.
 *
 * @param villageId Id of the village with a Destroy Entities Objective set up.
 * @param entities Entities to append to the objective.
 */
declare function OUTPUT_AppendDestroyEntitiesObjective(villageId: number, entities: number[]): void

/**
 * Adds cards to a specific deck.
 *
 * @param deckName The name of the deck to set.
 * @param cards The cards to add to the end of the deck.
 */
declare function OUTPUT_AppendNamedDeck(deckName: string, cards: number[][][]): void

/**
 * Appends a new filter to entities with a `badger:trigger_criteria`.
 * @see `"badger:spatial_trigger_zone"`
 *
 * @param entities The entities to append the criteria to.
 * @param includeTags The include tags.
 * @param excludeTags The exclude tags.
 * @param allianceRuleFilter The alliance rule.
 */
declare function OUTPUT_AppendTriggerCriteriaTags(entities: number[], includeTags: string[], excludeTags: string[], allianceRuleFilter: string): void

/**
 * Applies a buff to entities.
 *
 * @param entities The entities.
 * @param buffName The name of the buff to apply.
 */
declare function OUTPUT_ApplyBuff(entities: number[], buffName: string): void

/**
 * Adds a proximity check to an existing named timer. If it is displaying to the player,
 * they must be radius distance from the passed in entity to actually see th timer
 *
 * @param timerName Global timer name.
 * @param entity the entity that the player must be close to in order to see the timer
 * @param radius The radius to display the timer around the entity
 */
declare function OUTPUT_ApplyProximityToNamedTimer(timerName: string, entity: number, radius: number): void

/**
 * Applies a status effect to entities (like a buff but with duration control).
 *
 * @param entities The entities to receive the status effect.
 * @param statusEffectName The name of the status effect to apply.
 * @param strength A multiplier on the default duration of the status effect.
 */
declare function OUTPUT_ApplyStatusEffect(entities: number[], statusEffectName: string, strength: number): void

/**
 * Applies a status effect to entities (like a buff but with duration control) specifying a source entity for effects that requrie it (like fear).
 *
 * @param entities The entities to receive the status effect.
 * @param sourceEntity The entity to act as the source of the status effect.
 * @param statusEffectName The name of the status effect to apply.
 * @param strength A multiplier on the default duration of the status effect.
 */
declare function OUTPUT_ApplyStatusEffectWithSource(entities: number[], sourceEntity: number, statusEffectName: string, strength: number): void

/**
 * Modify the ticket cap for a named ticket type by an amount. Applies to all entities on the same team as the entity passed through
 *
 * @param playerEntity The player entity toupdate.
 * @param ticketType The type of ticket to modify. @see TICKET_BUILD @see TICKET_GATHER @see TICKET_SPAWN
 * @param amount The amount to modify the ticket type by.
 */
declare function OUTPUT_ApplyTicketModifierToPlayerForTeam(playerEntity: number, ticketType: string, amount: number): void

/**
 * Modify the ticket cap for a named ticket type by an amount
 *
 * @param teamName All players on this team will have their ticket caps modified
 * @param ticketType The type of ticket to modify. @see TICKET_BUILD @see TICKET_GATHER @see TICKET_SPAWN
 * @param amount The amount to modify the ticket type by.
 */
declare function OUTPUT_ApplyTicketModifierToTeam(teamName: string, ticketType: string, amount: number): void

/**
 * Set the home base for entities
 *
 * @param homeBaseEntity Home base entity
 * @param targetEntities Target entities
 * @param threshold Threshold
 */
declare function OUTPUT_AssignHomeBaseToEntities(homeBaseEntity: number, targetEntities: number[], threshold: number): void

/**
 * Try to spend a ticket for a player on one or more entities.
 *
 * @param playerToDeductTicketsFrom The player entity to deduct a ticket from.
 * @param entitiesToAssociateTicketCost The entities to spend the tickets on. One of each ticket will be spent for each entity supplied.
 * @param ticketName The ticket to try to spend (eg: `"spawn"). See `gametickets.json` for what's available.
 */
declare function OUTPUT_AssignTicketsToMobsIfAble(playerToDeductTicketsFrom: number, entitiesToAssociateTicketCost: number[], ticketName: string): void

/**
 * Assigns an entity to a control group entity so it can be referenced later.
 * An entity can only belong to one control group, if it belongs to one already it'll be reassigned.
 *
 * @param sourceEntities The entities to assign.
 * @param controlGroupEntity The owning control group.
 */
declare function OUTPUT_AssignToControlGroup(sourceEntities: number[], controlGroupEntity: number): void

/**
 * Associate an entity with a particular spawner. This is useful in the case of spawner caps and recalling mobs.
 * *NOTE:* Be sure to check that the spawner has a `"badger:lost_entity_recall_point"` with matching tags for the entity you spawn. `OUTPUT_AddTag` might be useful here if you're looking to match something not typically used.
 *
 * @param spawner The `badger:buildable_spawner` entity to associate with.
 * @param entitiesToAssociate The entities to associate the a spawner.  
 */
declare function OUTPUT_AssociateMobWithSpawner(spawner: number, entitiesToAssociate: number[]): void

/**
 * Display the campaign end menu.
 * Currently this returns all players back to the main menu.
 *
 * 
 */
declare function OUTPUT_CampaignEndMenu(): void

/**
 * Cancels the invasion action if it was a horde action - no source but with the target.
 *
 * @param targetVillageEntities Target villages participating in the invasion action.
 */
declare function OUTPUT_CancelHordeDelayedInvasionActions(targetVillageEntities: number[]): void

/**
 * Claims the area in the world. Use placement system to select where.
 *
 * @param horde Name of the horde that claims an area.
 * @param positionEntity The result entity (like placement) to spawn the claimed area on.
 * @param radius The radius of the claimed area.
 */
declare function OUTPUT_ClaimArea(horde: string, positionEntity: number, radius: number): number

/**
 * Clears any override set for compass max range.
 *
 * @param entityToClearOverride compass entity
 */
declare function OUTPUT_ClearOverrideForCompassMaxRange(entityToClearOverride: number): void

/**
 * Collect telemetry info.
 *
 * @param propertyName Name of the property.
 * @param propertyValue Value of the property.
 */
declare function OUTPUT_CollectTelemetryInfo(propertyName: string, propertyValue: string): void

/**
 * Issue a follow order to a control group entity. 
 * All existing entities (and newly assigned ones) will receive this order.
 *
 * @param controlGroupEntity The control group entity.
 * @param targetPositionEntity The entity to follow.
 */
declare function OUTPUT_ControlGroupFollow(controlGroupEntity: number, targetPositionEntity: number): void

/**
 * Makes any entity registered to a control group follow an AI entity.
 *
 * @param controlGroupEntity The control group entity.
 * @param aiEntity The AI entity.
 */
declare function OUTPUT_ControlGroupFollowAI(controlGroupEntity: number, aiEntity: number): void

/**
 * Issue a move to position order to a control group entity.
 * All existing entities (and newly assigned ones) will receive this order.
 *
 * @param controlGroupEntity The control group entity.
 * @param targetPositionEntity The entity position to move to.
 * @param arrivalPadding World distance units to consider the target position was reached successfully.
 */
declare function OUTPUT_ControlGroupMoveToCurrentPosition(controlGroupEntity: number, targetPositionEntity: number, arrivalPadding: number): void

/**
 * Create a persistent world stream request centered on an entity.
 *
 * @param entity The entity with which this request is centered around
 * @param range The size of the area around the entity to request
 * @param requestType The type of request. Request priorities are found in world_stream.json. Grouped requests use the highest priority of all requests in the group.
 * @param group The request group. All level chunks in between entities in the same group will also be requested.
 */
declare function OUTPUT_CreatePersistentWorldRequest(entity: number, range: number, requestType: string, group: string): void

/**
 * Creates a new player proximity observer. Use `LISTENFOR_EntityEnteredPlayerProximity` to register a snippet for it
 *
 * @param observerName The name of a new observer. An error will occur if a name is reused.
 * @param allianceRuleFilter The alliance rule filter to use when finding entities (see: `team_manager.json`)
 * @param includeTags Only proximity-check for entities that have _all_ of these tags
 * @param excludeTags Exlude entities that have _any_ of these tags from the proximity check
 * @param radius The radius of proximity around each player to check (eg: `10.0`)
 */
declare function OUTPUT_CreatePlayerProximityObserver(observerName: string, allianceRuleFilter: string, includeTags: string[], excludeTags: string[], radius: number): void

/**
 * Creates a trigger volume that will be appropriately sized to match the bounds of its associated village.
 *
 * @param villageId The village to create the trigger volume based on.
 * @param padding The extra padding around the village bounds for this trigger volume.
 * @param includeTags The include tags for the trigger criteria filter.
 * @param excludeTags The exclude tags for the trigger criteria filter.
 * @param allianceRuleFilter The alliance rule for the trigger criteria filter.
 */
declare function OUTPUT_CreateVillageTriggerVolume(villageId: number, padding: number, includeTags: string[], excludeTags: string[], allianceRuleFilter: string): number

/**
 * Despawns all pop capped entities in a village, INCLUDING SUSPENDED ONES.
 * Not intended for use outside of B# helper functions.
 *
 * @param villageId The village ID.
 */
declare function OUTPUT_CullPopCappedEntitiesInVillage(villageId: number): void

/**
 * Damages a set of entities by an absolute amount of damage.
 * This applies damage to entities, assuming they all have HealthComponent
 * To destroy an entity, use @see OUTPUT_DestroyEntities
 *
 * @param entities The entities to damage.
 * @param damage The amount of damage to apply.
 */
declare function OUTPUT_DamageEntities(entities: number[], damage: number): void

/**
 * Damages a set of entities by a percentage of their max health.
 * This applies damage to entities, assuming they all have HealthAttribute
 * To destroy an entity, use @see OUTPUT_DestroyEntities
 *
 * @param entities The entities to damage.
 * @param damagePercent The percentage of the entity's max health to apply as damage. Must be a value between 0 and 100.
 */
declare function OUTPUT_DamageEntitiesByPercentage(entities: number[], damagePercent: number): void

/**
 * Log and show a message on the console.
 * To see the message on console ensure you have `dev_areafilter_string:SCRIPTING` set in options.txt
 * Recommended to use helpers `Logv()`, `Logi()`, `Logw()`, `Loge()`
 *
 * @param message The message to log.
 * @param level The log level (0,1,2,3), 0 being the least severe and 3 the most.
 */
declare function OUTPUT_DebugLog(message: string, level: number): void

/**
 * Logs a deck to console.
 *
 * @param deck The deck to log.
 * @param includeSubCards Show or hide subcards.
 */
declare function OUTPUT_DebugLogDeck(deck: number[][][], includeSubCards: boolean): void

/**
 * Logs invasion information to the ImGUI Debug window
 *
 * @param message The message to log
 */
declare function OUTPUT_DebugLogInvasion(message: string): void

/**
 * Logs a named deck to console.
 * @see `OUTPUT_SetNamedDeck`
 *
 * @param deckName The deck name to log.
 * @param includeSubCards Show or hide subcards.
 */
declare function OUTPUT_DebugLogNamedDeck(deckName: string, includeSubCards: boolean): void

/**
 * Ends the debug performance timer and logs the total duration since `OUTPUT_DebugTimeStart` was called.
 *
 * 
 */
declare function OUTPUT_DebugTimeEnd(): void

/**
 * Starts the debug performance timer. End the timer with `OUTPUT_DebugTimeEnd`.
 *
 * 
 */
declare function OUTPUT_DebugTimeStart(): void

/**
 * Deconstructs (immediately) buildings from a village. This will remove the building(s) and refund the cost.
 * Because this is designed to handle suspended villages, you should not make multiple deconstruction requests for the
 * same village on the same frame, as only one active request per village at a time is supported.
 *
 * @param villageEntity The village entity that we want to remove the buildings from.
 * @param tags The tags of buildables to be deconstructed. This is an inclusive list of tags, meaning that any buildable in the village that has any of the tags will be deconstructed.
 */
declare function OUTPUT_DeconstructVillageBuildings(villageEntity: number, tags: string[]): void

/**
 * Deletes a timer attached to an entity.
 *
 * @param entity The entity that owns this timer.
 * @param timerName The name of the timer to delete.
 */
declare function OUTPUT_DeleteEntityTimer(entity: number, timerName: string): void

/**
 * DeleteListenerTriggerVolumes
 *
 * @param snippetName snippet name
 */
declare function OUTPUT_DeleteListenerTriggerVolumes(snippetName: string): void

/**
 * Deletes a global timer.
 *
 * @param timerName The name of the timer to delete.
 */
declare function OUTPUT_DeleteNamedTimer(timerName: string): void

/**
 * Despawns (removes) a set of entities
 * This will not result in animations playing, or points being awarded, etc.
 * For 'normal' destruction, use @see OUTPUT_DestroyEntities
 *
 * @param entities The entities to despawn.
 */
declare function OUTPUT_DespawnEntities(entities: number[]): void

/**
 * Despawns village(s) given the village entity.
 *
 * @param entities The village entities.
 */
declare function OUTPUT_DespawnVillageEntities(entities: number[]): void

/**
 * Destroys (kills) a set of entities.
 * This will run normal destruction behaviour (like animations).
 * To remove an entity without animations, point awarding, and such,
 * use OUTPUT_DespawnEntity
 *
 * @param entities The entity group to destroy.
 */
declare function OUTPUT_DestroyEntities(entities: number[]): void

/**
 * Destroys village(s) given the village entity.
 *
 * @param entities The village entities.
 */
declare function OUTPUT_DestroyVillageEntities(entities: number[]): void

/**
 * Disables the cinematic played for an entity with "badger:cinematic_death".
 * This must be called in SNIPPET_DeferredDeath only.
 *
 * @param dyingEntity The dying entity.
 */
declare function OUTPUT_DisableDeathCinematic(dyingEntity: number): void

/**
 * Disables home base for entities
 *
 * @param homeBaseEntity Home base entity
 * @param targetEntities Target entities
 * @param threshold Threshold
 */
declare function OUTPUT_DisableHomeBaseForEntities(homeBaseEntity: number, targetEntities: number[], threshold: number): void

/**
 * Dismounts given player from the mount.
 *
 * @param playerEntity Player entity.
 */
declare function OUTPUT_DismountPlayer(playerEntity: number): void

/**
 * Dispatches a "player entry" note for the tutorial system. (ask a programmer before using this)
 *
 * @param village The village entity
 * @param player The player entity
 */
declare function OUTPUT_DispatchPlayerEnteredVillageNotice(village: number, player: number): void

/**
 * Displays a global timer on all players screen.
 * Only one timer can be display at a time.
 *
 * @param timerName Global timer name.
 * @param isDisplayed To display or not.
 * @param countsDown Counts down or up.
 */
declare function OUTPUT_DisplayNamedTimer(timerName: string, isDisplayed: boolean, countsDown: boolean): void

/**
 * Start an "oops" action onto a piglin base.
 * This will begin loading in the village which can be listened for in LISTENFOR_InvasionOopsApply
 * @requires BSharpPlacement
 *
 * @param baseId The village ID of the base.
 * @param hidden Whether the oops will be telegraphed on the map only when it succeeds
 */
declare function OUTPUT_DoInvasionOops(baseId: number, hidden: boolean): void

/**
 * Upgrade a piglin base. This function removes a village completely and spawns a new village with the new size.
 * - The new village inherits the same ID as the previous village. Existing B-Sharp payloads will apply to it.
 * - The new village can be any valid size (eg: `small`, `large`, etc.)
 * - Entities are *despawned* and **not destroyed**. Campaign logic will not trigger the same way.
 * @see OUTPUT_SetOwnerVillageById To set ownership. Entities not owned by a village won't be removed.
 * @see QUERY_GetEntitiesOwnedByVillage To review entities owned by a village.
 * @requires BSharpPlacement
 *
 * @param baseId The village ID of the base.
 * @param newArchetype The new village entity archetype.
 * @param newSize The new size of the base defined in villages.json.
 * @param dependOnPlayerProximity Whether or not upgrade should happen only when player is away from the base.
 * @param stampTextureKey Name key to give this texture. Used to identify this texture for future updates.
 * @param stampTextureName Name of the texture to stamp the surrounding area with. Only applies to village placed using slot mode.
 * @param destroyUnmarkedStructures Specifies whether or not we destroy all present structures in the chunks before building a new base. Only structures with badger:chunk_reload_indestructible_flag will remain.
 */
declare function OUTPUT_DoInvasionUpgrade(baseId: number, newArchetype: string, newSize: string, dependOnPlayerProximity: boolean, stampTextureKey: string, stampTextureName: string, destroyUnmarkedStructures: boolean): void

/**
 * Draws the new intentions for factions for next invasion turn.
 * @see SNIPPET_InvasionIntentionsDrawn for handling what actually happens.
 *
 * 
 */
declare function OUTPUT_DrawInvasionIntentions(): void

/**
 * End an invasion attack V2 action. Can be called when an invasion is warded off or auto-resolved.
 *
 * @param invasionId The main invasion ID that contains the attack information.
 * @param isSuccess The reason for ending. true = players won, false = players lost.
 */
declare function OUTPUT_EndInvasionAttackV2(invasionId: number, isSuccess: boolean): void

/**
 * Ends the match if it hasn't already been ended. This will trigger snippets that are listening for
 * @see LISTENFOR_GlobalVariableChanged with the variable @see GAME_MODE_GLOBAL.matchEnded
 * Will also call @see OUTPUT_EndMatch
 *
 * @param winningTeam The team that won the match.
 */
declare function OUTPUT_EndMatch(winningTeam: string): void

/**
 * Executes all (non-thwarted!) delayed invasion actions.
 * This should be called at dusk.
 *
 * 
 */
declare function OUTPUT_ExecuteAllDelayedInvasionActions(): void

/**
 * Marks the finish of Invasion Planning phase. Has to fire only once when all invasion intentions were processed.
 * This exists solely because the Planning phase takes an unknown number of frames and we have to notify the C++ that we are ready to proceed to the Execution phase.
 * Currently this has to fire in invasion_intentions_dawn_logic.js in DrawInvasionHordeCard() when no cards are left to be drawn.
 *
 * 
 */
declare function OUTPUT_ExecuteInvasionActionsReady(): void

/**
 * Manullay moves village attack states ahead toward their conclusions.
 * - Attacks in the 'STARTED' state (haven't been activated by a player) move to 'RESOLVE' state.
 * - Attacks in the 'ACTIVE' or 'ABANDONED' states move to 'OVERTIME' state.
 * NOTE: if no players are present at a village attack in the 'OVERTIME' state, it will naturally
 * proceed to the 'RESOLVE' state.
 *
 * @param villageEntities Entity group of villages that are under attack. Villages in this group that are not being attacked will be ignored.
 */
declare function OUTPUT_FastForwardVillageAttacks(villageEntities: number[]): void

/**
 * Flags entity as visited by adding a flag component. This is useful for
 * Developers on the C++ for ECS systems
 *
 * @param entities The entity to be flagged as visited
 */
declare function OUTPUT_FlagEntityAsVisited(entities: number[]): void

/**
 * Flashes the ui element shown by set lives counter
 *
 * @param team name of the team whose lives count is being set
 * @param flashSeconds How many seconds should the ui element flash
 */
declare function OUTPUT_FlashLivesCounter(team: string, flashSeconds: number): void

/**
 * Causes an existing global timer to flash for a given number of seconds
 *
 * @param timerName The name of the timer to flash.
 * @param flashSeconds The number of seconds that the displayed timer will flash for
 */
declare function OUTPUT_FlashNamedTimer(timerName: string, flashSeconds: number): void

/**
 * @deprecated
 *
 * @param name deprecated
 * @param size deprecated
 * @param faction deprecated
 * @param team deprecated
 * @param location deprecated
 * @param blocksEast deprecated
 */
declare function OUTPUT_HackSpawnVillage(name: string, size: string, faction: string, team: string, location: number, blocksEast: number): void

/**
 * Disconnects any number of players and automatically has them start a new campaign.
 *
 * @param playerEntities The player entities to disconnect.
 */
declare function OUTPUT_HaveClientExitTutorial(playerEntities: number[]): void

/**
 * Requests the engine load village(s) involved in a village attack v2 so scripts can apply damage.
 *
 * @param invasionId Id of the village attack.
 */
declare function OUTPUT_InvasionAttackV2RequestDamage(invasionId: number): void

/**
 * Resolves any active invasion actions (when possible).
 * This should be called at dawn.
 *
 * 
 */
declare function OUTPUT_InvasionResolveActiveActions(): void

/**
 * Removes entities from a control group.
 *
 * @param sourceEntities The entities to remove.
 * @param controlGroupEntity The control group entity.
 */
declare function OUTPUT_LeaveControlGroup(sourceEntities: number[], controlGroupEntity: number): void

/**
 * Stops the sun from rotating aroud the earth (or vice versa, if that is your belief system)
 *
 * @param lock   true to stop, false to resume
 */
declare function OUTPUT_LockDayNightCycle(lock: boolean): void

/**
 * Removes a key/value pair from a map controller.
 *
 * @param entities The map controller entities.
 * @param key The key.
 */
declare function OUTPUT_MapRemoveKey(entities: number[], key: string): void

/**
 * Remove a map team key/value pair from a map controller.
 *
 * @param entities The map controller entities.
 * @param teamName The team.
 * @param key The key.
 */
declare function OUTPUT_MapRemoveTeamKey(entities: number[], teamName: string, key: string): void

/**
 * Edit or add a key/value pair to a map controller.
 *
 * @param entities The map controller entities.
 * @param key The key.
 * @param value The value.
 */
declare function OUTPUT_MapSetKeyValue(entities: number[], key: string, value: string): void

/**
 * Updates the range of a particular player trigger on a village entity (see the `"badger:map_controller"` component)
 *
 * @param villageEntity The map controller entity. (does *not* have to be a village entity)
 * @param rangeLabel The `bsharp_label` for the particular trigger in `player_triggers`
 * @param newRange The new range to trigger (must be greater than or equal to zero)
 */
declare function OUTPUT_MapSetPlayerTriggerRange(villageEntity: number, rangeLabel: string, newRange: number): void

/**
 * Edit or add a team key/value pair to a map controller.
 *
 * @param entities The map controller entities.
 * @param teamName The team.
 * @param key The key.
 * @param value The value.
 */
declare function OUTPUT_MapSetTeamKeyValue(entities: number[], teamName: string, key: string, value: string): void

/**
 * Mounts given player onto a provided mount.
 *
 * @param playerEntity Player entity.
 * @param mountArchetype Mount archetype (e.g. badger:animal_bird) 
 */
declare function OUTPUT_MountPlayer(playerEntity: number, mountArchetype: string): void

/**
 * Tell an entity group (any size) to walk/move to another entity, ignoring all enemies on the way.
 * This follows an entity.
 *
 * @param sourceEntities The entities to move
 * @param destEntity The entity to get the destination position from
 * @param padding The distance from the target destination to stop
 * @param callback "snippet_name" the snippet to call when the destination is reached
 */
declare function OUTPUT_Move(sourceEntities: number[], destEntity: number, padding: number, callback: string): void

/**
 * Tell an entity group (any size) to walk/move to another entity, attacking along the way as necessary
 * This follows an entity
 *
 * @param sourceEntities The entities to move
 * @param destEntity The entity to follow
 * @param callback "snippet_name" the snippet to call when the destination is reached
 */
declare function OUTPUT_MoveAttackEntity(sourceEntities: number[], destEntity: number, callback: string): void

/**
 * Tell an entity group (any size) to walk/move to another entity, attacking along the way as necessary
 * The position of the dest is measured when this function is called. This does not follow an entity.
 *
 * @param sourceEntities The entities to move
 * @param destEntity The entity to get the destination position from
 * @param range The distance from the target destination to stop
 * @param callback "snippet_name" the snippet to call when the destination is reached
 */
declare function OUTPUT_MoveAttackPosition(sourceEntities: number[], destEntity: number, range: number, callback: string): void

/**
 * Tell an entity group (any size) to walk/move to another entity, ignoring all enemies on the way.
 * The position of the dest is measured when this function is called. This does not follow an entity.
 *
 * @param sourceEntities The entities to move
 * @param destEntity The entity to get the destination position from
 * @param padding The distance from the target destination to stop
 * @param callback "snippet_name" the snippet to call when the destination is reached
 */
declare function OUTPUT_MovePosition(sourceEntities: number[], destEntity: number, padding: number, callback: string): void

/**
 * Orients entities to another entity. WARNING: will snap camera if performed on a player entity
 *
 * @param srcEntities The group of entities to orient.
 * @param orientEntity The entity to orient to.
 */
declare function OUTPUT_OrientEntitiesToEntity(srcEntities: number[], orientEntity: number): void

/**
 * Orients entities to another entity. This will only orient the entity in the direction 
 * (will not touch the player camera if teleporting a player)
 *
 * @param srcEntities The group of entities to orient.
 * @param yaw The angle in radians to face.
 */
declare function OUTPUT_OrientEntitiesToYaw(srcEntities: number[], yaw: number): void

/**
 * Overrides the cinematic played for an entity with "badger:cinematic_death".
 * This must be called in SNIPPET_DeferredDeath only.
 *
 * @param cineName The cinematic name.
 * @param dyingEntity The dying entity.
 */
declare function OUTPUT_OverrideDeathCinematic(cineName: string, dyingEntity: number): number

/**
 * Overrides a mob's appearance with a faction specific appearance.
 * **Must be called on the same tick the entities were spawned.**
 *
 * @param entities The entities to update.
 * @param factionOverrideName The faction name (eg. faction.pig.attack).
 */
declare function OUTPUT_OverrideFactionAppearanceByName(entities: number[], factionOverrideName: string): void

/**
 * Sets a tag filter to entities with a `badger:trigger_criteria`.
 * @see `"badger:spatial_trigger_zone"`
 *
 * @param entities The entities to overwrite the criteria to.
 * @param includeTags The include tags.
 * @param excludeTags The exclude tags.
 * @param allianceRuleFilter The alliance rule.
 */
declare function OUTPUT_OverwriteTriggerCriteriaTags(entities: number[], includeTags: string[], excludeTags: string[], allianceRuleFilter: string): void

/**
 * Globally patches all trigger volumes tagset include rule. 
 *
 * @param newExcludeTags Updated include rule.
 * @param forIncludeTagsIncluding Only update tagset with an include rule that includes these tags.
 * @param forIncludeTagsExcluding Only update tagset with an include rule that excludes these tags.
 * @param forExcludeTagsIncluding Only update tagset with an exclude rule that includes these tags. 
 * @param forExcludeTagsExcluding Only update tagset with an exclude rule that excludes these tags. 
 * @param optionalAllianceRule Only update tagset with an alliance rule that matches this. Use ALLIANCE_PATCH_ALL for any.
 */
declare function OUTPUT_PatchTriggerVolumeExcludeFilter(newExcludeTags: string[], forIncludeTagsIncluding: string[], forIncludeTagsExcluding: string[], forExcludeTagsIncluding: string[], forExcludeTagsExcluding: string[], optionalAllianceRule: string): void

/**
 * Globally patches all trigger volumes tagset include and exclude rule. 
 *
 * @param newIncludeTags Updated exclude rule.
 * @param newExcludeTags Updated include rule.
 * @param forIncludeTagsIncluding Only update tagset with an include rule that includes these tags.
 * @param forIncludeTagsExcluding Only update tagset with an include rule that excludes these tags.
 * @param forExcludeTagsIncluding Only update tagset with an exclude rule that includes these tags. 
 * @param forExcludeTagsExcluding Only update tagset with an exclude rule that excludes these tags. 
 * @param optionalAllianceRule Only update tagset with an alliance rule that matches this. Use ALLIANCE_PATCH_ALL for any.
 */
declare function OUTPUT_PatchTriggerVolumeFilter(newIncludeTags: string[], newExcludeTags: string[], forIncludeTagsIncluding: string[], forIncludeTagsExcluding: string[], forExcludeTagsIncluding: string[], forExcludeTagsExcluding: string[], optionalAllianceRule: string): void

/**
 * Globally patches all trigger volumes tagset exclude rule. 
 *
 * @param newIncludeTags Updated exclude rule.
 * @param forIncludeTagsIncluding Only update tagset with an include rule that includes these tags.
 * @param forIncludeTagsExcluding Only update tagset with an include rule that excludes these tags.
 * @param forExcludeTagsIncluding Only update tagset with an exclude rule that includes these tags. 
 * @param forExcludeTagsExcluding Only update tagset with an exclude rule that excludes these tags. 
 * @param optionalAllianceRule Only update tagset with an alliance rule that matches this. Use ALLIANCE_PATCH_ALL for any.
 */
declare function OUTPUT_PatchTriggerVolumeIncludeFilter(newIncludeTags: string[], forIncludeTagsIncluding: string[], forIncludeTagsExcluding: string[], forExcludeTagsIncluding: string[], forExcludeTagsExcluding: string[], optionalAllianceRule: string): void

/**
 * Pauses a global timer.
 *
 * @param timerName The name of the timer to pause.
 */
declare function OUTPUT_PauseNamedTimer(timerName: string): void

/**
 * Spatial rule that attempts to find closest placement to the target group
 *
 * @param originEntities Entities to find the closest position to
 * @param weight Weight of the rule when leveraged against other weighted rules. Can be any number.
 */
declare function OUTPUT_PlacementAddClosestProximityRule(originEntities: number[], weight: number): void

/**
 * Adds a new spatial rule based on distance to claimed areas. The radius is a padding from the edge of each claimed area.
 *
 * @param hordeName Name of the piglin faction.
 * @param radius The padding.
 */
declare function OUTPUT_PlacementAddExcludeClaimedAreasProximityRule(hordeName: string, radius: number): void

/**
 * Spatial rule to avoid areas of the world within a certain distance from the ocean.
 *
 * @param distance Exclusion distance from the ocean.
 */
declare function OUTPUT_PlacementAddExcludeOceanProximityRule(distance: number): void

/**
 * Adds a new spatial rule based on distance to entities. Each origin, combined with the max distance, represents a circular area in the world
 * to check if a position is outside of the area. Only positions outside of the required number of areas will be considered valid.
 * This function can be called repeatedly to add multiple sets of proximity rules with different entities and restrictions.
 *
 * @param originEntities The entities to use the (x,z) coordinates of.
 * @param distance The distance away from a position in the set to consider as valid. Ie. the radius of the circle.
 * @param numRequired The minimum number of positions in this set that must resolve to true for this rule to be satisfied as a whole
 */
declare function OUTPUT_PlacementAddExcludeProximityRule(originEntities: number[], distance: number, numRequired: number): void

/**
 * Spatial rule that attempts to find farthest placement from the target group
 *
 * @param originEntities Entities to find the farthest position from
 * @param weight Weight of the rule when leveraged against other weighted rules. Can be any number.
 */
declare function OUTPUT_PlacementAddFarthestProximityRule(originEntities: number[], weight: number): void

/**
 * Adds a new spatial rule based on distance to claimed areas. The position must be in a claimed area.
 *
 * @param hordeName The horde the claimed area(s) belong to.
 * @param minDistance Minimum distance from the center of a claimed area.
 * @param maxDistance Maximum distance from the center of a claimed area.
 */
declare function OUTPUT_PlacementAddIncludeClaimedAreasProximityRule(hordeName: string, minDistance: number, maxDistance: number): void

/**
 * Adds a new spatial rule based on distance to entities. Each origin, combined with the min and max distance, represent a donut area in the world
 * to check if a position is within the area. Only positions within the required number of areas will be considered valid.
 * This function can be called repeatedly to add multiple sets of proximity rules with different entities and restrictions.
 *
 * @param originEntities The entities to use the (x,z) coordinates of.
 * @param minDistance The minimum distance away from a position in the set to consider as valid. Ie. the inner radius of the donut.
 * @param maxDistance The maximum distance away from a position in the set to consider as valid. Ie. the outer radius of the donut.
 * @param numRequired The minimum number of positions in this set that must resolve to true for this rule to be satisfied as a whole
 */
declare function OUTPUT_PlacementAddIncludeProximityRule(originEntities: number[], minDistance: number, maxDistance: number, numRequired: number): void

/**
 * Spatial rule to find a position inside a claimed area.
 *
 * @param hordeName Horde the claimed area(s) belong to.
 * @param innerCirclePadding The minimum distance away from the center of the claimed area. Ie. the inner radius of the donut.
 * @param outerCirclePadding The maximum distance away from the center of the claimed area. Ie. the inner radius of the donut.
 */
declare function OUTPUT_PlacementAddInsideClaimedAreasProximityRule(hordeName: string, innerCirclePadding: number, outerCirclePadding: number): void

/**
 * Spatial rule to find a position only in a specified slice
 *
 * @param sliceIndex Slice index
 */
declare function OUTPUT_PlacementAddInsideWorldSliceProximityRule(sliceIndex: number): void

/**
 * Adds a new rule to cap the height of the placement area.
 *
 * @param maxHeight max block height.
 */
declare function OUTPUT_PlacementAddMaxElevationRule(maxHeight: number): void

/**
 * Adds a new rule to set a minimum height of the placement area.
 *
 * @param minHeight min block height.
 */
declare function OUTPUT_PlacementAddMinElevationRule(minHeight: number): void

/**
 * Enable debugging for the next usage of BSharpPlacement. Call this after @see OUTPUT_PlacementStart and before calling the output that uses
 * BSharpPlacement. Will run the placement multiple times and log stats to the console about the success rate, average attempts, and which
 * rules are failing the most. Use this ONLY for debugging and testing placements!
 *
 * 
 */
declare function OUTPUT_PlacementEnableDebugLogging(): void

/**
 * Sets the maximum stamp village would ever get so we can properly calculate the max bounds.
 *
 * @param entity Placement entity that can either be a placement result or a village entity
 * @param stampTextureName Maximum texture stamp that a village would receive during its lifecycle.
 */
declare function OUTPUT_PlacementEntitySetMaximumVillageTextureStamp(entity: number, stampTextureName: string): void

/**
 * Placement function for setting texture stamp. Sets the texture stamp a placement entity will use if successfully used.
 * This output can be used to add or replace a texture stamp.
 *
 * @param entity The placement entity to update.
 * @param textureKey Key name to give this texture.
 * @param stampTextureName Name of the texture to stamp with.
 * @param destroyUnmarkedStructures Specifies whether or not we destroy all present structures in the chunks of the new texture stamp. Only structures with badger:chunk_reload_indestructible_flag will remain.
 */
declare function OUTPUT_PlacementEntityUpdateTextureStamp(entity: number, textureKey: string, stampTextureName: string, destroyUnmarkedStructures: boolean): void

/**
 * Executes the current BSharpPlacement rules.
 * View the results with the QUERY functions.
 *
 * 
 */
declare function OUTPUT_PlacementExecute(): boolean

/**
 * Indicates a preference for slots within certain biomes.
 * This function can only be used with slots.
 * The valid biomeNames are:
 * jungle, drylands, forest, close_ocean, mountain_parent_valleys, frostlands, wetlands, fateful_land_campaign, brokenlands_ridge, grasslands, brokenlands
 *
 * @param biomeNames Names of biomes that are preferred.
 * @param weight Weight of the rule when leveraged against other weighted rules. Can be any number.
 */
declare function OUTPUT_PlacementPreferBiomeRule(biomeNames: string[], weight: number): void

/**
 * Removes a texture from a chosen placement slot without providing a replacement.
 *
 * @param textureKey Name key of the texture given when it was set (not the actual name of the texture!)
 */
declare function OUTPUT_PlacementRemoveTextureStamp(textureKey: string): void

/**
 * Sets the texture stamp avoidance rule allowing us to force villages never overlap with their texture stamps.
 * Note that the villages this rule will avoid are ONLY the villages that have a texture stamp in their slot
 * that has `"village_texture_stamp": true` field set.
 * If the village was not placed on a slot or it did but it doesn't have a corresponding texture stamp (like WoF)
 * this rule will skip those villages and you are better off defining the usual exclude rules.
 * This rule will also take into consideration the "maximum" village texture stamp set with OUTPUT_PlacementSetMaximumVillageTextureStamp
 *
 * @param villageEntities Villages to avoid. Only villages placed on a slot with a valid village texture stamp.
 * @param textureStampToEvaluate Texture stamp to evaluate against.
 * @param padding Shrink/expand the texture stamp bounds for comparison.
 * @param avoidSelf Whether or not the slot in question should never be evaluated.
 */
declare function OUTPUT_PlacementSetAvoidVillageTextureStampsRule(villageEntities: number[], textureStampToEvaluate: string, padding: number, avoidSelf: boolean): void

/**
 * Sets the maximum stamp village would ever get so we can properly calculate the max bounds.
 * This sets it automatically for the last placement ran.
 *
 * @param stampTextureName Maximum texture stamp that a village would receive during its lifecycle.
 */
declare function OUTPUT_PlacementSetMaximumVillageTextureStamp(stampTextureName: string): void

/**
 * Sets the main proximity rule for distance to a set of entities. Each entity position, combined with the min and max distance, represent a donut area in the world
 * to check if a position is within the area. For primary areas, only one area must qualify.
 * This function can be called only once per placement.
 *
 * @param entities The entities to use the (x,z) coordinates of.
 * @param minDistance The minimum distance away from a position in the set to consider as valid. Ie. the inner radius of the donut.
 * @param maxDistance The maximum distance away from a position in the set to consider as valid. Ie. the outer radius of the donut.
 */
declare function OUTPUT_PlacementSetPrimaryProximityRule(entities: number[], minDistance: number, maxDistance: number): void

/**
 * Sets the slot name restriction.
 *
 * @param slotTagName The slot name (`placement_name` in world-gen cards).
 */
declare function OUTPUT_PlacementSlotTag(slotTagName: string): void

/**
 * Begins placement. Call this before setting any rules. Rules can only be set within the same listener as where
 * this is function is called. Will fail if called when there is already a placement sequence ongoing.
 *
 * 
 */
declare function OUTPUT_PlacementStart(): void

/**
 * Placement function for setting texture stamp. On successfully executing placement, if placement was run in slot mode,
 * this output can be called to add/replace the provided texture on the chosen slot.
 *
 * @param textureKey Key name to give this texture.
 * @param stampTextureName Name of the texture to stamp with.
 * @param destroyUnmarkedStructures Specifies whether or not we destroy all present structures in the chunks of the new texture stamp. Only structures with badger:chunk_reload_indestructible_flag will remain.
 */
declare function OUTPUT_PlacementUpdateTextureStamp(textureKey: string, stampTextureName: string, destroyUnmarkedStructures: boolean): void

/**
 * A new placement mode that instead of choosing from ALL the slots would only choose from the village slots given.
 *
 * @param villageEntities Villages to get the slots of. If the villages provided were not placed on the slots, those would be skipped.
 */
declare function OUTPUT_PlacementVillageSlots(villageEntities: number[]): void

/**
 * Plays a variation (flavour, objective) card from a specific named deck.
 *
 * @param deck The deck name.
 * @param villageId The village id to tie the variation to.
 */
declare function OUTPUT_PlayGenericCardFromNamedDeck(deck: string, villageId: number): string

/**
 * Plays a global audio clip. Ensure that the clip is 2D, otherwise it will be played at position (0,0,0).
 *
 * @param audioName The name of the audio clip to be played. Must be a 2D clip.
 */
declare function OUTPUT_PlayGlobalAudio(audioName: string): void

/**
 * Plays a horde card from a named deck that has been set.
 *
 * @param deck Name of the deck from which to play card.
 */
declare function OUTPUT_PlayHordeCardFromNamedDeck(deck: string): void

/**
 * Plays an invasion card from a specific named deck.
 *
 * @param deck The deck name.
 */
declare function OUTPUT_PlayInvasionCardFromNamedDeck(deck: string): void

/**
 * Removes any overrides made to the time used by the audio ambience system.
 *
 * 
 */
declare function OUTPUT_RemoveAmbienceTimeOfDayOverride(): void

/**
 * Removes a buff from entities.
 *
 * @param entities The entities.
 * @param buffName The name of the buff to remove.
 */
declare function OUTPUT_RemoveBuff(entities: number[], buffName: string): void

/**
 * Removes a destroy entities objective from a village.
 *
 * @param villageId The village ID.
 */
declare function OUTPUT_RemoveDestroyEntitiesObjective(villageId: number): void

/**
 * Removes the leash off the entities, if they're leashed. If they are not, nothing happens.
 *
 * @param entitiesWithLeash Entitis that have the leash.
 */
declare function OUTPUT_RemoveLeash(entitiesWithLeash: number[]): void

/**
 * Remove all listeners that reference a given snippet name
 *
 * @param snippetName The snippet name which all listeners that reference will be deleted.
 */
declare function OUTPUT_RemoveListeners(snippetName: string): void

/**
 * Remove a persistent world stream request centered on an entity.
 *
 * @param entity The entity associated with the world request to remove
 * @param requestType The request type of the world request to remove
 * @param group The group of the world request to remove
 */
declare function OUTPUT_RemovePersistentWorldRequest(entity: number, requestType: string, group: string): void

/**
 * Removes an existing player proximity observer. See `OUTPUT_CreatePlayerProximityObserver` to create one.
 *
 * @param observerName The name of the observer to remove. An error will occur if no observers with the name exist.
 */
declare function OUTPUT_RemovePlayerProximityObserver(observerName: string): void

/**
 * Removes a tag from an entity's tag set.
 *
 * @param entities The entities to remove the tag from.
 * @param tag The tag to be removed.
 */
declare function OUTPUT_RemoveTag(entities: number[], tag: string): void

/**
 * Removes tethers that exist between two entities.
 *
 * @param rootEntity The entity hosts the tether.
 * @param tetherEntities The entities to untether from the root entity.
 */
declare function OUTPUT_RemoveTether(rootEntity: number, tetherEntities: number[]): void

/**
 * Untriggers a persistent presentation event from a given entity. (like `OUTPUT_TriggerPresentationEvent`)
 * The targeted entity's data must support the requested presentation effect.
 * Use this output if the entity needs to persist presentation state on save/load (eg. keep a chest open).
 *
 * @param entities Entities to trigger the event on.
 * @param state The name of the event to trigger, as defined in the entity's data.
 */
declare function OUTPUT_RemoveVisualState(entities: number[], state: string): void

/**
 * Removes any `badger:waypoint_marker`s from **entities**.
 *
 * @param entity The **entities** to remove waypoint icons from.
 */
declare function OUTPUT_RemoveWaypointIcon(entity: number[]): void

/**
 * Resets the spawn data of a barracks spawner.
 *
 * @param entities The Barracks Spawner entity to reset.
 */
declare function OUTPUT_ResetBarracksSpawnTypes(entities: number[]): void

/**
 * Resets a units behavior back to default.
 *
 * @param entities The entities to update.
 */
declare function OUTPUT_ResetBehavior(entities: number[]): void

/**
 * Resumes a global timer.
 *
 * @param timerName The name of the timer to resume.
 */
declare function OUTPUT_ResumeNamedTimer(timerName: string): void

/**
 * Output to save microprofiler frames for performance tests
 *
 * @param id id of the microprofile to save
 * @param numFrames Number of frames to capture
 */
declare function OUTPUT_SaveProfilerFrames(id: string, numFrames: number): void

/**
 * Sends an announcer audio message.
 *
 * @param messageReceiverTeam The team that will hear the message.
 * @param messageType The type of message.
 * @param messageDescription The message description.
 */
declare function OUTPUT_SendAnnouncerMessage(messageReceiverTeam: string, messageType: string, messageDescription: string): void

/**
 * Sends a Global Event to all of the clients
 *
 * @param eventName The name of the event to send
 * @param eventType The Type of the event to send
 */
declare function OUTPUT_SendGlobalEventToAll(eventName: string, eventType: string): void

/**
 * Sends a Global Event to specific players.
 *
 * @param eventName The name of the event to send
 * @param eventType The Type of the event to send
 * @param players The players to send the event to
 */
declare function OUTPUT_SendGlobalEventToPlayers(eventName: string, eventType: string, players: number[]): void

/**
 * Sends a Global Event to all clients that are on a specified team
 *
 * @param eventName The name of the event to send
 * @param eventType The Type of the event to send
 * @param teamName The Team Name to send events to, only clients with this name will receive it.
 */
declare function OUTPUT_SendGlobalEventToTeam(eventName: string, eventType: string, teamName: string): void

/**
 * Sends a diegetic audio event to all clients at given position entities.
 * The audio name should be a one-shot name (eg. BAE_foobar)
 *
 * @param audioName The sfx name.
 * @param positionEntities The positions to trigger the event at.
 */
declare function OUTPUT_SendPositionalAudio(audioName: string, positionEntities: number[]): void

/**
 * Sents a diegetic audio event to clients on a team at given position entities.
 *
 * @param audioName The sfx name.
 * @param positionEntities The positions to trigger the event at.
 * @param teamName The team the players must belong to.
 */
declare function OUTPUT_SendPositionalAudioToTeam(audioName: string, positionEntities: number[], teamName: string): void

/**
 * Removes the value mapped to a certain key in the server's map state
 *
 * @param key Key mapping to a value that will be removed.
 */
declare function OUTPUT_ServerMapRemoveKey(key: string): void

/**
 * Sets a key/value pair in the server's map state
 *
 * @param key Key for the server's tag map.
 * @param value Value assigned to that key 
 */
declare function OUTPUT_ServerMapSetKeyValue(key: string, value: string): void

/**
 * Overrides the time provided to the audio ambience system.
 *
 * @param timeOfDay The time to set the override to.
 */
declare function OUTPUT_SetAmbienceTimeOfDayOverride(timeOfDay: number): void

/**
 * Enables a target action for all mobs that meet a specific criteria within the aggro range. For more information, see the `badger:target_actions` component.
 * **WARNING: Currently this function will NOT work if called in the same tick as `OUTPUT_SetBehavior`**
 *
 * @param entities The entities to set the attack mode of.
 * @param attackMode The name of the target action to set.
 * @param on Turn the attack mode on?
 */
declare function OUTPUT_SetAttackMode(entities: number[], attackMode: string, on: boolean): void

/**
 * Sets a save/loaded audio variable that is synced to all players in the game.
 * These variables can be used by FMOD.
 *
 * @param variableName The variable name.
 * @param value The decimal float.
 */
declare function OUTPUT_SetAudioVariable(variableName: string, value: number): void

/**
 * Changes a barracks spawner's batch size data.
 *
 * @param entities The Barracks Spawner entity to update.
 * @param batch The new batch size of the barracks.
 */
declare function OUTPUT_SetBarracksBatchSize(entities: number[], batch: number): void

/**
 * Changes a barracks spawner's spawn cap data.
 *
 * @param entities The Barracks Spawner entity to update.
 * @param cap The new spawn cap of the barracks.
 */
declare function OUTPUT_SetBarracksSpawnCap(entities: number[], cap: number): void

/**
 * Changes a barracks spawner's spawn rate data.
 *
 * @param entities The Barracks Spawner entity to update.
 * @param rate The delay in seconds between each spawn for the barracks.
 */
declare function OUTPUT_SetBarracksSpawnRate(entities: number[], rate: number): void

/**
 * Changes a barracks spawner's data.
 *
 * @param entities The Barracks Spawner entities to update.
 * @param spawnTypes The new spawn types of the barracks.
 */
declare function OUTPUT_SetBarracksSpawnTypes(entities: number[], spawnTypes: string[]): void

/**
 * Applies a new behavior to the given entities.
 *
 * @param entities The entities to have the behavior applied to. Should be entities for which the behavior is applicable.
 * @param behavior The name of the behavior to apply. Eg. "badger:behavior_curious"
 */
declare function OUTPUT_SetBehavior(entities: number[], behavior: string): void

/**
 * Sets a global cinematic variable. This can be used for cinematic controls like if a cinematic is skippable.
 *
 * @param variableName The cinematic variable name.
 * @param value True or false.
 */
declare function OUTPUT_SetCinematicVariable(variableName: string, value: boolean): void

/**
 * Sets entities deferred death status. If deferred, death by damage is instead delayed
 * and B# scripts must handle it instead. Note if not handled there is a 60 second failsafe.
 *
 * @param entities The entities to defer.
 * @param isDeferred If the entities should be deferred or not.
 */
declare function OUTPUT_SetDeferredDeath(entities: number[], isDeferred: boolean): void

/**
 * Create a delayed invasion action that can be thwarted or executed in the future.
 *
 * @param sourceVillageEntity The source village **ENTITY** initiating the action.
 * @param invasionAction The action to do.
 * @param targetVillageEntities The target village **ENTITY** receiving the action. Use `[]` if there is no target.
 * @param hidden If true, this action will not be shown on the map both when it's set and when it's thwarted. Will still display when its executed at night.
 * @param factionName Name of the piglin faction responsible for this attack.
 * @param strength strength
 */
declare function OUTPUT_SetDelayedInvasionAction(sourceVillageEntity: number, invasionAction: string, targetVillageEntities: number[], hidden: boolean, factionName: string, strength: number): void

/**
 * OUTPUT_SetDisableByHealthCinematicState
 *
 * @param entities entity to disabled
 * @param isEnabled isEnabled
 */
declare function OUTPUT_SetDisableByHealthCinematicState(entities: number[], isEnabled: boolean): void

/**
 * Changes the currently-playing music on an entity with a music emitter
 * @see `badger:music_emitter_state` in `music_emitter.json`
 *
 * @param entities The entity (or entities) to set
 * @param trackName The name of the state to set to. Should be a member of the array in `badger:music_emitter_state`.
 */
declare function OUTPUT_SetEmitterState(entities: number[], trackName: string): void

/**
 * Emphasize (highlight) a HUD item or all players.
 *
 * @param hudItemId The HUD item ID.
 * @param emphasizedState Is emphasized or not.
 */
declare function OUTPUT_SetEmphasizedHUDItem(hudItemId: string, emphasizedState: boolean): void

/**
 * DEPRECATED.
 * Please use barrack configuration functions.
 *
 * @param villageId The village ID of the piglin base.
 * @param count The desired number of engineers.
 */
declare function OUTPUT_SetEngineerCount(villageId: number, count: number): void

/**
 * DEPRECATED.
 * Please set the `reassignment_delay` on the `badger:engineer_station` component in the village json files.
 *
 * @param villageId The village ID of the piglin base.
 * @param delaySeconds The delay in seconds.
 */
declare function OUTPUT_SetEngineerReassignmentDelay(villageId: number, delaySeconds: number): void

/**
 * Sets a timer attached to an entity.
 *
 * @param entity The entity that owns this timer.
 * @param timerName The name of the timer to start.
 * @param timerValue The value to set the timer to.
 */
declare function OUTPUT_SetEntityTimer(entity: number, timerName: string, timerValue: number): void

/**
 * Set a group of entities to be owned by a faction.
 *
 * @param entities The entities to set as owned by a faction.
 * @param factionName The name of the faction to assign as the owner of the entities.
 */
declare function OUTPUT_SetFactionByName(entities: number[], factionName: string): void

/**
 * Enables or disabled the fast travel state of a village.
 *
 * @param villageId Id of the village
 * @param enable The state of the fast travel. True --> enable, False --> disable
 */
declare function OUTPUT_SetFastTravelEnabled(villageId: number, enable: boolean): void

/**
 * Sets a global variable. Do not use this for things that are local to a particular area. (eg: per village)
 *
 * @param variableName The name of the variable to set.
 * @param variableValue The new value of the variable.
 */
declare function OUTPUT_SetGlobalVariable(variableName: string, variableValue: number): void

/**
 * Sets entities health.
 *
 * @param entities The entities to update.
 * @param healthPercent The percent health. Accepted values 0 - 100.
 */
declare function OUTPUT_SetHealthPercent(entities: number[], healthPercent: number): void

/**
 * Sets an icons maximum viewing distance if the entities have an icon.
 *
 * @param entities The icons to change.
 * @param distance The maximum viewing distance.
 */
declare function OUTPUT_SetIconMaxDistance(entities: number[], distance: number): void

/**
 * Sets an icons minimum viewing distance if the entities have an icon.
 *
 * @param entities The icons to change.
 * @param distance The minimum viewing distance.
 */
declare function OUTPUT_SetIconMinDistance(entities: number[], distance: number): void

/**
 * Toggles an icon off if the entities have one.
 *
 * @param entities The icons to toggle.
 */
declare function OUTPUT_SetIconOff(entities: number[]): void

/**
 * Toggles an icon on if the entities have one.
 *
 * @param entities The icons to toggle.
 */
declare function OUTPUT_SetIconOn(entities: number[]): void

/**
 * Changes a waypoint markers icon.
 *
 * @param entities The icons to update.
 * @param iconPath The URI path to the icon.
 */
declare function OUTPUT_SetIconPath(entities: number[], iconPath: string): void

/**
 * Overrides the priority of an entity's compass icon.
 *
 * @param entities Entities whose compass icons will be overriden.
 * @param priority The new priority for the compass icons.
 */
declare function OUTPUT_SetIconPriority(entities: number[], priority: number): void

/**
 * Sets an entities influenceable state. (eg. if it can be lured or directed).
 * Calling this function will cancel any current move orders or influences.
 *
 * @param entities The entities to update.
 * @param isInfluenceable If it can be influenced.
 */
declare function OUTPUT_SetInfluenceable(entities: number[], isInfluenceable: boolean): void

/**
 * Enable or disable whether or not an interactable entity can be interacted with.
 * The provided entity must be interactable.
 *
 * @param entity The interactable entity to be modified.
 * @param enabled Whether the interaction should be active or not.
 */
declare function OUTPUT_SetInteractionState(entity: number, enabled: boolean): void

/**
 * Sets an entity to be invulnerable.
 * The entity can still be directly destroyed/despawned (eg. OUTPUT_DespawnEntities)
 *
 * @param entities The entities to update.
 * @param isInvulnerable Should the entity be invulnerable?
 */
declare function OUTPUT_SetInvulnerable(entities: number[], isInvulnerable: boolean): void

/**
 * Sets an entity to be invulnerable with the specified render effect.
 *
 * @param entities The entities to update.
 * @param isInvulnerable Should the entity be invulnerable?
 * @param effectIndex The render effect.
 */
declare function OUTPUT_SetInvulnerableWithEffect(entities: number[], isInvulnerable: boolean, effectIndex: number): void

/**
 * Sets the leash of every entity in the entitiesToLeash to be attached to leash target.
 *
 * @param entitiesToLeash Entities that needs to be leashed.
 * @param entityLeashTarget Target for leashing (one entity).
 * @param leashRange Range at which the leashing will trigger and entity will be recalled.
 * @param returnRange Range at which the recall will end. This would usually be smaller than leash range.
 */
declare function OUTPUT_SetLeash(entitiesToLeash: number[], entityLeashTarget: number, leashRange: number, returnRange: number): void

/**
 * Sets the leash of every entity in the entitiesToLeash to be attached to leash target,
 * and these entities will return when not targeting anything
 *
 * @param entitiesToLeash Entities that needs to be leashed.
 * @param entityLeashTarget Target for leashing (one entity).
 * @param leashRange Range at which the leashing will trigger and entity will be recalled.
 * @param returnRange Range at which the recall will end. This would usually be smaller than leash range.
 */
declare function OUTPUT_SetLeashWithReturnWhenNotTargeting(entitiesToLeash: number[], entityLeashTarget: number, leashRange: number, returnRange: number): void

/**
 * Displays a UI for all players that tracks the number of remaining lives
 * Must be manually updated to track remaining lives, whatever that means for each Lost Legend
 * Set to -1 to turn off the counter
 *
 * @param livesCount How many lives should the ui start with
 * @param team name of the team whose lives count is being set
 * @param flashAtOneLife should the ui element flash when 1 life is remaining
 */
declare function OUTPUT_SetLivesCounter(livesCount: number, team: string, flashAtOneLife: boolean): void

/**
 * Sets a loot table override for entities.
 *
 * @param entities The entities to update.
 * @param overrideName The override name on the entity (this is not a loot table ID).
 */
declare function OUTPUT_SetLootTableOverride(entities: number[], overrideName: string): void

/**
 * Returns a loot table override for an entity back to default.
 *
 * @param entities The entities to update.
 */
declare function OUTPUT_SetLootTableToDefault(entities: number[]): void

/**
 * Sets a specfic deck by name.
 *
 * @param deckName The name of the deck to set.
 * @param cards The cards to set the deck to.
 */
declare function OUTPUT_SetNamedDeck(deckName: string, cards: number[][][]): void

/**
 * Sets a global timer. Do not use this for something that could be repeated throughout the game world.
 *
 * @param timerName The name of the timer to start.
 * @param timerValue The new value to set the timer to.
 */
declare function OUTPUT_SetNamedTimer(timerName: string, timerValue: number): void

/**
 * Sets the visual state of the timer when it expires to either a success or failure state.
 * If this function isn't called the timer will have default behaviour: disappearing when the timer expires.
 *
 * @param timerName Global timer name.
 * @param successWhenTimeExpires True sets the timer to succeed when the timer expires. False sets the timer to fail when the timer expires
 */
declare function OUTPUT_SetNamedTimerExpiredState(timerName: string, successWhenTimeExpires: boolean): void

/**
 * Manually sets the visual state of the timer to a success or failure state
 *
 * @param timerName Global timer name.
 * @param didSucceed If true, sets the timer visual state to success. If false, sets the timer visual state to failure
 */
declare function OUTPUT_SetNamedTimerSuccessState(timerName: string, didSucceed: boolean): void

/**
 * Sets the level of global Nether Spores. Nether Spores disable natural precipitation.
 *
 * @param strength Intensity of nether spores. Zero will turn them off.
 */
declare function OUTPUT_SetNetherSporesActiveEverywhere(strength: number): void

/**
 * Sets the objective bar HUD element visibility for an objective bar entity.
 *
 * @param entity The objective bar entity.
 * @param isVisible If the HUD element will be visible or not.
 */
declare function OUTPUT_SetObjectiveHealthBarVisible(entity: number, isVisible: boolean): void

/**
 * toggles the visibility of an objective showing up on the playes map. Needs to be added to objectives_data.json
 *
 * @param objectiveName The name of the objective. This should be the same as the lang file text
 * @param isVisible Whether the objective will show on the map screen or not
 */
declare function OUTPUT_SetObjectiveVisibility(objectiveName: string, isVisible: boolean): void

/**
 * Overrides the max compass range of an entity's waypoint icon
 *
 * @param entityToOverride The entity to override
 * @param distance The new max distance
 */
declare function OUTPUT_SetOverrideForCompassMaxRange(entityToOverride: number, distance: number): void

/**
 * Set a group of entities to be owned by an invasion.
 *
 * @param entities The entities to set as owned by an invasion.
 * @param invasionId The specific invasion ID.
 */
declare function OUTPUT_SetOwnerInvasionAttack(entities: number[], invasionId: number): void

/**
 * Set a group of entities to be owned by a village.
 *
 * @param entities The entities to set as owned by a village.
 * @param villageId The id of the village to assign as the owner of the entities.
 */
declare function OUTPUT_SetOwnerVillageById(entities: number[], villageId: number): void

/**
 * Sets whether an entity should partake in the pop-cap system.
 * **This only works on entities that originally partook of the pop-cap system!**
 *
 * @param entities The entities to update.
 * @param isPopCapped Is this entity part of the pop cap system? (can be despawned)
 */
declare function OUTPUT_SetPopCapped(entities: number[], isPopCapped: boolean): void

/**
 * Sets the cap for a given resource using a player entity as the inventory owner (or their team if a team resource).
 *
 * @param playerEntity The player whose inventory is to be modified.
 * @param resourceName The name of the resource.
 * @param cap The new cap to set for the resource.
 */
declare function OUTPUT_SetResourceCap(playerEntity: number, resourceName: string, cap: number): void

/**
 * Sets the sky state (e.g. Sun-Moon, two Suns, etc.)
 *
 * @param skyState The state to change the sky to.
 */
declare function OUTPUT_SetSkyState(skyState: string): void

/**
 * Sets the spawner to add a loot override to all spawned entities.
 *
 * @param entities The spawner entities.
 * @param overrideName The override name on the spawned entity (this is not a loot table ID).
 */
declare function OUTPUT_SetSpawnerAddLootOverride(entities: number[], overrideName: string): void

/**
 * Sets entities team. Entities need teams to be included in trigger criteria and aggro escalation.
 * @see `team_manager.json`
 *
 * @param entitiesToPlaceAt The entities to set the team of.
 * @param teamname The name of the team to set.
 */
declare function OUTPUT_SetTeam(entitiesToPlaceAt: number[], teamname: string): void

/**
 * Set the baseline ticket cap for a ticket type such as 'build', 'gather', or 'spawn'.
 *
 * @param ticketType The type of ticket to set. @see TICKET_BUILD @see TICKET_GATHER @see TICKET_SPAWN
 * @param cap The new cap to set the ticket type to.
 */
declare function OUTPUT_SetTicketCap(ticketType: string, cap: number): void

/**
 * Despawns a village and all entities owned by the village. Then spawns a new village with a new size in the same location.
 *
 * @param timeOfDay Time of day (0-1) to set
 */
declare function OUTPUT_SetTimeOfDay(timeOfDay: number): void

/**
 * Sets up a destroy entities objective.
 * @see LISTENFOR_InvasionDestroyEntitiesObjective
 *
 * @param villageId The village ID.
 * @param entities The entities to mark as an objective.
 * @param numberToDestroy The number of entities to destroy to end the objective.
 * @param factionName The faction that "owns" this objective.
 */
declare function OUTPUT_SetupDestroyEntitiesObjective(villageId: number, entities: number[], numberToDestroy: number, factionName: string): void

/**
 * Sets up a destroy entities objective, identical to OUTPUT_SetupDestroyEntitiesObjective
 * This method will hide the village healthbar and instead only show the objective UI element
 *
 * @param villageId The village ID.
 * @param entities The entities to mark as an objective.
 * @param numberToDestroy The number of entities to destroy to end the objective.
 * @param factionName The faction that "owns" this objective.
 */
declare function OUTPUT_SetupDestroyEntitiesObjectiveWithHealthbarStomp(villageId: number, entities: number[], numberToDestroy: number, factionName: string): void

/**
 * Sets the flavour for a village. Should only be used in response to cards during village planning.
 *
 * @param flavour The flavour to assign.
 * @param villageId The id of the village to apply the flavour to.
 */
declare function OUTPUT_SetVillageFlavour(flavour: string, villageId: number): void

/**
 * Sets the objective for a village. Should only be used in response to cards during village planning.
 *
 * @param objective The objective to assign.
 * @param villageId The id of the village to apply the objective to.
 */
declare function OUTPUT_SetVillageObjective(objective: string, villageId: number): void

/**
 * Marks a village as occupied (by piglins).
 *
 * @param villageId The village ID.
 * @param isOccupied If the village is occupied or not.
 * @param hordeName name of horde
 */
declare function OUTPUT_SetVillageOccupied(villageId: number, isOccupied: boolean, hordeName: string): void

/**
 * Sets entities to be persistent - they can't be popcapped and will be teleported back to the village if wandered too far
 *
 * @param entities The entities of interest
 * @param villageId The village id where the entities are stationed
 */
declare function OUTPUT_SetVillagePersistentEntities(entities: number[], villageId: number): void

/**
 * Sets whether respawn points in a village are active. This does not override other rules causing the respawn points to be disabled.
 *
 * @param villageId The ID for the village containing the respawn points.
 * @param enabled The desired state of the respawn points.
 */
declare function OUTPUT_SetVillageRespawnPointsEnabled(villageId: number, enabled: boolean): void

/**
 * Create a suspension dependency relationship between two villages. This means that when one suspends/unsuspends, the other will do the same.
 * The villages must be unpaired for this to work. To remove the pairing, use @see OUTPUT_UnsetVillageSuspensionPair
 *
 * @param villageEntityA One of the villages to be paired.
 * @param villageEntityB One of the villages to be paired.
 */
declare function OUTPUT_SetVillageSuspensionPair(villageEntityA: number, villageEntityB: number): void

/**
 * Set the Wave Level in Wave Difficulty
 *
 * @param waveLevel the level of intensity of the wave
 */
declare function OUTPUT_SetWaveLevel(waveLevel: number): void

/**
 * Slices the world in given pieces - to used in combination with OUTPUT_PlacementAddInsideWorldSliceProximityRule
 *
 * @param sliceNum Number of slices
 */
declare function OUTPUT_SliceWorld(sliceNum: number): void

/**
 * Spawns a buildable at another entity and snap it to the ground.
 *
 * @param buildableName The name of the buildable to spawn (eg: `badger:poi_sword_gold`).
 * @param entitiesPosition The entities to spawn this buildable at.
 * @param buildableTeam The team to spawn the structure on (required!).
 * @param facingDirection The orientation that the structre should be facing: (eg: `north`, `south`, `east`, or `west`).
 * @param instantBuild Should we instantly build this structure.
 * @param onGround Snap buildable to the surface.
 * @param callback A call to `SpawnBuildableCallback` with the snippet to call on complete. This can be ignored by passing in an empty string.
 */
declare function OUTPUT_SpawnBuildableAt(buildableName: string, entitiesPosition: number[], buildableTeam: string, facingDirection: string, instantBuild: boolean, onGround: boolean, callback: string): void

/**
 * Spawns a buildable at another entity and snap it to the ground but with an offset from the other EG. (the Y value will still be snapped to the ground)
 *
 * @param buildableName The name of the buildable to spawn (eg: `badger:poi_sword_gold`).
 * @param entitiesPosition The entities to spawn this buildable at.
 * @param buildableTeam The team to spawn the structure on (required!).
 * @param facingDirection The orientation that the structre should be facing: (eg: `north`, `south`, `east`, or `west`).
 * @param instantBuild Should we instantly build this structure.
 * @param onGround Snap buildable to the surface.
 * @param x The X offset the structure should be at.
 * @param y The Y offset the structure should be at.
 * @param z The Z offset the structure should be at.
 * @param callback A call to `SpawnBuildableCallback` with the snippet to call on complete. This can be ignored by passing in an empty string.
 */
declare function OUTPUT_SpawnBuildableAtWithOffset(buildableName: string, entitiesPosition: number[], buildableTeam: string, facingDirection: string, instantBuild: boolean, onGround: boolean, x: number, y: number, z: number, callback: string): void

/**
 * Spawns multiple entities at the location of another entity.
 * @returns The entities of the newly-spawned entities, or an empty array if there's an error.
 *
 * @param entitiesToPlaceAt The entities to spawn at. Will spawn at each entity.
 * @param archetypeName The archetype name of the entities to spawn.
 * @param spawnCount How many entities to spawn. Must be larger than 0. If only spawning 1, then @see OUTPUT_SpawnEntityAt
 */
declare function OUTPUT_SpawnEntitiesAt(entitiesToPlaceAt: number[], archetypeName: string, spawnCount: number): number[]

/**
 * Spawns multiple entities at the location of another entity, but sets the height to the ground height.
 * @returns The entities of the newly-spawned entities, or `0` if there's an error.
 *
 * @param entitiesToPlaceAt The entities to spawn at. Will spawn at each entity.
 * @param archetypeName The archetype name of the entities to spawn.
 * @param spawnCount How many entities to spawn. Must be larger than 0. If only spawning 1, then @see OUTPUT_SpawnEntityAtGroundHeight
 */
declare function OUTPUT_SpawnEntitiesAtGroundHeight(entitiesToPlaceAt: number[], archetypeName: string, spawnCount: number): number[]

/**
 * "Spreads" enitities in the village according to the provided min and max radius. Avoids trees and buildings.
 *
 * @param entityArchetype The archetype name of the entities to spawn.
 * @param spawnCount How many entities to spawn. Must be larger than 0.
 * @param villageId Village at which to spread entities. Must be loaded.
 * @param minRadius Min radius (suggested value: 20)
 * @param maxRadius Max radius (suggested value: 50)
 */
declare function OUTPUT_SpawnEntitiesInVillage(entityArchetype: string, spawnCount: number, villageId: number, minRadius: number, maxRadius: number): number[]

/**
 * Spawns an entity at the location of another entity.
 * @returns The entities of the newly-spawned entities, or an empty array if there's an error.
 *
 * @param entitiesToPlaceAt The entities to spawn near. Will spawn at each entity.
 * @param archetypeName The archetype name of the entity to spawn.
 * @param spawnCount How many entities to spawn. Must be larger than 0.
 */
declare function OUTPUT_SpawnEntitiesNear(entitiesToPlaceAt: number[], archetypeName: string, spawnCount: number): number[]

/**
 * Spawns an entity at the location of another entity.
 * @returns The entities of the newly-spawned entities, or an empty array if there's an error.
 *
 * @param entitiesToPlaceAt The entities to spawn at. Will spawn at each entity.
 * @param archetypeName The archetype name of the entity to spawn.
 */
declare function OUTPUT_SpawnEntityAt(entitiesToPlaceAt: number[], archetypeName: string): number[]

/**
 * Spawns an entity at the location of another entity, but sets the height to the ground height.
 * @returns The entities of the newly-spawned entities, or an empty array if there's an error.
 *
 * @param entitiesToPlaceAt The entities to spawn at. Will spawn at each entity.
 * @param archetypeName The archetype name of the entity to spawn.
 */
declare function OUTPUT_SpawnEntityAtGroundHeight(entitiesToPlaceAt: number[], archetypeName: string): number[]

/**
 * Spawns village attack FOBs evenly around a village at an arbitray distance. Used as an alternative when we don't have slots setup
 * around the village.
 *
 * @param invasionId ID of the village attack.
 * @param villageArchetype Archetype of the village entities to spawn.
 * @param size Size of the new bases
 * @param amount Number of bases to spawn.
 * @param distance Distance from the targeted village.
 */
declare function OUTPUT_SpawnInvasionAttackFobsV2AtDistance(invasionId: number, villageArchetype: string, size: string, amount: number, distance: number): void

/**
 * Spawns a FOB type village used for the invasion attack V2 action.
 * multiple FOB's can be spawned per attack.
 *
 * @param invasionId The specific invasion ID.
 * @param villageArchetype The village archetype to spawn.
 * @param size The size type.
 * @param positionEntity The entity to spawn at.
 */
declare function OUTPUT_SpawnInvasionAttackFobV2(invasionId: number, villageArchetype: string, size: string, positionEntity: number): void

/**
 * Spawns a piglin base (village) for an invasion action. Returns the new village entity.
 * @requires BSharpPlacement
 * @see OUTPUT_SpawnVillage
 *
 * @param positionEntity Where to spawn the base.
 * @param villageArchetype The village archetype to spawn.
 * @param size The new size defined in villages.json.
 * @param factionName The faction **name** (eg. faction.pig.defend)
 * @param teamName The team alias
 * @param action The UI event name. See `invasion_settings.json`
 */
declare function OUTPUT_SpawnInvasionBase(positionEntity: number, villageArchetype: string, size: string, factionName: string, teamName: string, action: string): number

/**
 * Spawns a buildable using BSharpPlacement that belongs to a player and their team.
 * @requires BSharpPlacement
 *
 * @param positionEntity Where to spawn the buildable.
 * @param archetype The buildable archetype to spawn.
 * @param facingDirection The direction to face the building: north, west, east, south
 * @param instant Create the building instantly?
 * @param player The player who will act as the creator of this entity.
 * @param waiveCost Charge the cost of the buildable to the player's team?
 */
declare function OUTPUT_SpawnPlayerBuildable(positionEntity: number, archetype: string, facingDirection: string, instant: boolean, player: number, waiveCost: boolean): void

/**
 * Spawns a village in the world given a set of placement rules. Returns the new village entity.
 * @requires BSharpPlacement
 *
 * @param positionEntity Where to spawn the village.
 * @param villageArchetype The village archetype to spawn.
 * @param size The new size defined in villages.json.
 * @param factionName The faction **name** (eg. faction.pig.defend)
 * @param teamName The team alias
 */
declare function OUTPUT_SpawnVillage(positionEntity: number, villageArchetype: string, size: string, factionName: string, teamName: string): number

/**
 * Spawns a buildable using BSharpPlacement that belongs to a village.
 * @requires BSharpPlacement
 *
 * @param positionEntity Where to spawn the buildable.
 * @param archetype The buildable archetype to spawn.
 * @param facingDirection The direction to face the building: north, west, east, south
 * @param instant Create the building instantly?
 * @param villageId The id of the village that will own this buildable.
 */
declare function OUTPUT_SpawnVillageBuildable(positionEntity: number, archetype: string, facingDirection: string, instant: boolean, villageId: number): void

/**
 * Starts a village attack. The time of the attack is calculated internally using the current time of day (at night) and the total length of night.
 * Late activation of this attack will result in lower attack times.
 *
 * @param villageId The target village ID.
 * @param factionName The attacking piglin faction.
 * @param strength The attack strength.
 * @param time The duration of the activated attack in percent. (0-100)
 * @param minSeconds The minimum duration of the activated attack in seconds.
 */
declare function OUTPUT_StartInvasionAttackV2(villageId: number, factionName: string, strength: number, time: number, minSeconds: number): void

/**
 * Starts a village attack. The time of the attack is specified and will always last just as long. Activating this attack late will not result in
 * any chances in the attack time.
 *
 * @param villageId Id of the village that is being attacked.
 * @param factionName Name of the piglin faction performing the attack.
 * @param strength Strenght of the attack (>= 1).
 * @param timeOverride The exact time for the attack (in seconds).
 */
declare function OUTPUT_StartInvasionAttackV2TimeOverride(villageId: number, factionName: string, strength: number, timeOverride: number): void

/**
 * Add a true or false value to the active telemetry event.
 *
 * @param propertyName The name of the property. (ex. "IsDead")
 * @param value The value of the property (ex. true)
 */
declare function OUTPUT_TelemetryAddBool(propertyName: string, value: boolean): void

/**
 * Telemetry to track cinematic events
 *
 * 
 */
declare function OUTPUT_TelemetryAddCinematicsInfo(): void

/**
 * Adds the total number of times an event was recorded with matching "Category" for a given player.
 * You must call `OUTPUT_TelemetryAddFormattedName` first (to set the category).
 *
 * @param playerEntity The specific player.
 * @param propertyName The property name for the event.
 */
declare function OUTPUT_TelemetryAddCountCategory(playerEntity: number, propertyName: string): void

/**
 * Adds the total number of times an event was recorded with matching "Subcategory" for a given player.
 * You must call `OUTPUT_TelemetryAddFormattedName` first (to set the Subcategory).
 *
 * @param playerEntity The specific player.
 * @param propertyName The property name for the event.
 */
declare function OUTPUT_TelemetryAddCountSubcategory(playerEntity: number, propertyName: string): void

/**
 * Adds an unique enter/exit ID from trigger volumes to the active telemetry event.
 *
 * @param triggerVolumeEntity The trigger volume entity
 * @param intruderEntity The intruder entity
 */
declare function OUTPUT_TelemetryAddEnterExitUID(triggerVolumeEntity: number, intruderEntity: number): void

/**
 * Add a decimal value to the active telemetry event.
 *
 * @param propertyName The name of the property. (ex. "HealthLeft")
 * @param value The value of the property (ex. 0.42)
 */
declare function OUTPUT_TelemetryAddFloat(propertyName: string, value: number): void

/**
 * Add an integer value to the active telemetry event.
 *
 * @param propertyName The name of the property. (ex. "BuildingCount")
 * @param value The value of the property (ex. 42)
 */
declare function OUTPUT_TelemetryAddInt(propertyName: string, value: number): void

/**
 * Adds an integer value for the number of seconds players have spent engaged with a village attack.
 *
 * @param invasionId Id of the village attack.
 */
declare function OUTPUT_TelemetryAddInvasionAttackTimePlayersEngaged(invasionId: number): void

/**
 * An unique GUID for invasion breaks.
 *
 * @param started If the break just started (new GUID) or ended (retrieve last GUID)
 */
declare function OUTPUT_TelemetryAddInvasionBreakGUID(started: boolean): void

/**
 * Adds an unique location ID from certain entities to the active telemetry event.
 * Works on: POIs, Culture Villages, Piglin Villages, Mob Alliance Villages
 * @see `OUTPUT_TelemetryAddLocationUIDWithVillageID(villageId)`
 *
 * @param locationEntity The location entity
 */
declare function OUTPUT_TelemetryAddLocationUID(locationEntity: number): void

/**
 * telemeetry to track when spawners are made
 *
 * 
 */
declare function OUTPUT_TelemetryAddSpawnerInfo(): void

/**
 * Add a string value to the active telemetry event.
 *
 * @param propertyName The name of the property. (ex. "FactionName")
 * @param value The value of the property (ex. "faction.pig.defend")
 */
declare function OUTPUT_TelemetryAddString(propertyName: string, value: string): void

/**
 * Adds the teams balance from a player to the active telemetry event.
 *
 * @param playerEntity The player whose teams balance is to be added
 */
declare function OUTPUT_TelemetryAddTeamBalance(playerEntity: number): void

/**
 * Adds the time since an event was recorded with matching "Category" for a given player.
 * You must call `OUTPUT_TelemetryAddFormattedName` first (to set the Category).
 *
 * @param playerEntity The specific player.
 * @param propertyName The property name for the event.
 */
declare function OUTPUT_TelemetryAddTimeSinceLastCategory(playerEntity: number, propertyName: string): void

/**
 * Adds the time since an event was recorded with matching "Subcategory" for a given player.
 * You must call `OUTPUT_TelemetryAddFormattedName` first (to set the Subcategory).
 *
 * @param playerEntity The specific player.
 * @param propertyName The property name for the event.
 */
declare function OUTPUT_TelemetryAddTimeSinceLastSubcategory(playerEntity: number, propertyName: string): void

/**
 * Adds info for all `OUTPUT_AddOrRemoveResource` performed in the current snippet.
 * Specifically this captures the **intended delta** and final result after giving the resources.
 *
 * @param playerEntity The player that received/lost the resources.
 */
declare function OUTPUT_TelemetryAddTransactionPlayer(playerEntity: number): void

/**
 * Create a named telemetry event for a specific player.
 * Add information to the event with `OUTPUT_TelemetryAddXXX` and record the event with `OUTPUT_TelemetryRecordEvent`
 *
 * @param playerEntity The player
 * @param eventName The event name.
 * @param isPlayFab If this event will be used for PlayFab as well or only our systems (like achievements).
 */
declare function OUTPUT_TelemetryCreateEvent(playerEntity: number, eventName: string, isPlayFab: boolean): void

/**
 * Create a named telemetry event for a general event that does not relate to one specific player.
 * Add information to the event with `OUTPUT_TelemetryAddXXX` and record the event with `OUTPUT_TelemetryRecordEvent`
 *
 * @param eventName The event name
 * @param isPlayFab If this event will be used for PlayFab as well or only our systems (like achievements).
 */
declare function OUTPUT_TelemetryCreateServerEvent(eventName: string, isPlayFab: boolean): void

/**
 * Called when player completes certain Onboarding step
 *
 * @param onboardingName name of onboarding step
 */
declare function OUTPUT_TelemetryOnboardingComplete(onboardingName: string): void

/**
 * Create an OnboardingTip telemetry event
 *
 * @param onboardingName name of onboarding step
 */
declare function OUTPUT_TelemetryOnboardingStart(onboardingName: string): void

/**
 * tells the game to fire a CampaignBehaviourUpdate event
 *
 * @param actChanged bool to let us know if the act changed
 * @param newAct if the act did change, what is the new act?
 * @param interval The time when the telemetry event is created
 */
declare function OUTPUT_TelemetryRecordCampaignBehaviourProgressEvent(actChanged: boolean, newAct: string, interval: number): void

/**
 * Records the active telemetry event.
 *
 * 
 */
declare function OUTPUT_TelemetryRecordEvent(): void

/**
 * Records a telemetry funnel event for all the given players.
 *
 * @param playerEntities Player entities.
 * @param funnelStepName Name of the event.
 * @param stepNumCurrent Current step number
 * @param stepNumMax Maximum step number.
 * @param funnelCategory the category of the funnel
 * @param funnelName name of funnel
 */
declare function OUTPUT_TelemetryRecordFunnelEvent(playerEntities: number[], funnelStepName: string, stepNumCurrent: number, stepNumMax: number, funnelCategory: string, funnelName: string): void

/**
 * Force change all Player's gamee zone to a specific value
 *
 * @param playerEntities list of all active players 
 * @param gameZoneIndex numberical ID of the gamezone
 * @param gameZoneDescription name of gamezone
 */
declare function OUTPUT_TelemetryRecordGameZoneData(playerEntities: number[], gameZoneIndex: number, gameZoneDescription: string): void

/**
 * Records the active telemetry event. Uses an identifier string to check if the identifier has already been recorded.
 * If already recorded, the event will not be recorded and will be discarded gracefully.
 *
 * @param identifier The unique identifier for the event recording that will be used to check if this event has been recorded already.
 */
declare function OUTPUT_TelemetryRecordOnceEvent(identifier: string): void

/**
 * Records a telemetry event related to changing the state of the well of fate.
 *
 * @param upgradeType The upgrade type indended to record
 * @param fateBank The transaction type to specify (eg: `0` indicating removal of a structure, `1` representing adding a structure)
 */
declare function OUTPUT_TelemetryWellOfFateStateChange(upgradeType: string, fateBank: number): void

/**
 * Teleports entities to another entity.
 *
 * @param srcEntities The group of entities to teleport.
 * @param dstEntity The destination entity to teleport to.
 */
declare function OUTPUT_Teleport(srcEntities: number[], dstEntity: number): void

/**
 * Teleports entities to dstEntity and orients it in a towards orientEntity.
 *
 * @param srcEntities The group of entities to teleport.
 * @param dstEntity The destination entity to teleport to.
 * @param orientEntity The entity to orient to.
 */
declare function OUTPUT_TeleportAndOrientToEntity(srcEntities: number[], dstEntity: number, orientEntity: number): void

/**
 * Teleports entities to another entity and orients it in a specific yaw direction. This will only orient the entity in the direction 
 * (will not touch the player camera if teleporting a player)
 *
 * @param srcEntities The group of entities to teleport.
 * @param dstEntity The destination entity to teleport to.
 * @param yaw The angle in radians to face.
 */
declare function OUTPUT_TeleportAndOrientToYaw(srcEntities: number[], dstEntity: number, yaw: number): void

/**
 * Teleports entities to the fast-travel point for a village.
 *
 * @param srcEntities The group of entities to teleport.
 * @param dstEntity The destination village (that has a fast-travel point).
 */
declare function OUTPUT_TeleportFastTravel(srcEntities: number[], dstEntity: number): void

/**
 * Teleports entities to another entity with an offset.
 * **WARNING: You should not being using this function, instead setup a proper locator entity and teleport to that. (this function may be removed down in the future)**
 *
 * @param srcEntities The group of entities to teleport.
 * @param dstEntity The destination entity to teleport to.
 * @param x The x offset.
 * @param y The y offset.
 * @param z The z offset.
 */
declare function OUTPUT_TeleportWithOffset(srcEntities: number[], dstEntity: number, x: number, y: number, z: number): void

/**
 * For testing spatial rules without requiring the use of entities. This should not be called!
 * @see OUTPUT_PlacementAddProximityRule is the correct function to add proximity requirements.
 *
 * @param originPositions Set of int pairs that correspond to (x,z) coordinates instead of a set of entities.
 * @param minDistance @see OUTPUT_PlacementAddProximityRule
 * @param maxDistance @see OUTPUT_PlacementAddProximityRule
 * @param numRequired @see OUTPUT_PlacementAddProximityRule
 * @param isInclusive @see OUTPUT_PlacementAddProximityRule
 */
declare function OUTPUT_TEST_PlacementAddProximityRule(originPositions: number[][], minDistance: number, maxDistance: number, numRequired: number, isInclusive: boolean): void

/**
 * For testing use only. Runs a placement test on active rules.
 *
 * 
 */
declare function OUTPUT_TEST_PlacementRun(): void

/**
 * Notify relevant systems that a functional test has finished and provide the test result.
 *
 * @param testId The name of the test that was completed.
 * @param result Whether the test passed or failed, or potentially some other outcome indication if needed.
 */
declare function OUTPUT_TestFinished(testId: string, result: number): void

/**
 * Thwarts all delayed invasion actions.
 *
 * @param reason The reason why (used in WM3).
 */
declare function OUTPUT_ThwartAllDelayedInvasionActions(reason: string): void

/**
 * Thwarts delayed invasion actions belonging to the given villages.
 *
 * @param sourceVillageEntities The village entities to thwart.
 * @param reason The reason why (used in WM3).
 */
declare function OUTPUT_ThwartDelayedInvasionActions(sourceVillageEntities: number[], reason: string): void

/**
 * Triggers a cinematic.
 *
 * @param cineName The name of the cinematic.
 * @param candidatesEntitiesList The candidate actor entities for the cinematic.
 */
declare function OUTPUT_TriggerCinematic(cineName: string, candidatesEntitiesList: number[]): number

/**
 * Triggers a presentation event from a given entity.
 * The targeted entity's data must support the requested presentation effect.
 * Use this output for one-shot events. If you need to persist the effect on save/load see `OUTPUT_AddVisualState`.
 *
 * @param entities Entities to trigger the event on.
 * @param eventName The name of the event to trigger, as defined in the entity's data.
 */
declare function OUTPUT_TriggerPresentationEvent(entities: number[], eventName: string): void

/**
 * Triggers a presentation event from a given entity for a specific team.
 * The targeted entity's data must support the requested presentation effect.
 * Use this output for one-shot events. If you need to persist the effect on save/load see `OUTPUT_AddVisualState`.
 *
 * @param entities Entities to trigger the event on.
 * @param eventName The name of the event to trigger, as defined in the entity's data.
 * @param teamName The name of the team to trigger the event for.
 */
declare function OUTPUT_TriggerPresentationEventForTeam(entities: number[], eventName: string, teamName: string): void

/**
 * Triggers slash command, using a random player as the origin
 *
 * @param slashCommand Full slash command (e.g.: "/sm badger:mob_zombie")
 * @param isServerCommand Whether or not command has been registered in BadgerServerCommands or BadgerClientCommands
 */
declare function OUTPUT_TriggerSlashCommand(slashCommand: string, isServerCommand: boolean): void

/**
 * Bypasses a tutorial item on all connected clients.
 *
 * @param tutorialKeyToBypass The tutorial key
 */
declare function OUTPUT_TriggerTutorialBypass(tutorialKeyToBypass: string): void

/**
 * Triggers a tutorial hint for a bunch of specific players with various properties.
 *
 * @param tutorialKeyToBypass The tutorial key
 * @param bypass Whether or not to bypass the tutorial on the client (see: `OUTPUT_TriggerTutorialBypass`)
 * @param skipIfAlreadySeen Whether or not the client should skip the notification if they've already completed the item (default to true in `OUTPUT_TriggerTutorialHint`)
 * @param dontMarkCompleted If set to true, clients wont mark the tutorial item as completed.
 */
declare function OUTPUT_TriggerTutorialForAllPlayers(tutorialKeyToBypass: string, bypass: boolean, skipIfAlreadySeen: boolean, dontMarkCompleted: boolean): void

/**
 * Triggers a tutorial hint for a bunch of specific players with various properties.
 *
 * @param tutorialKeyToBypass The tutorial key
 * @param bypass Whether or not to bypass the tutorial on the client (see: `OUTPUT_TriggerTutorialBypass`)
 * @param skipIfAlreadySeen Whether or not the client should skip the notification if they've already completed the item (default to true in `OUTPUT_TriggerTutorialHint`)
 * @param dontMarkCompleted If set to true, clients wont mark the tutorial item as completed.
 * @param players The player entities to send the hint to. (eg: `GetPlayers()`)
 */
declare function OUTPUT_TriggerTutorialForSpecificPlayers(tutorialKeyToBypass: string, bypass: boolean, skipIfAlreadySeen: boolean, dontMarkCompleted: boolean, players: number[]): void

/**
 * Triggers a tutorial hint on all connected clients.
 *
 * @param tutorialKeyToHint The tutorial key
 */
declare function OUTPUT_TriggerTutorialHint(tutorialKeyToHint: string): void

/**
 * Unassigns home base for entities.
 *
 * @param targetEntities Target entities
 */
declare function OUTPUT_UnassignHomeBaseForEntities(targetEntities: number[]): void

/**
 * Remove the suspension dependency relationship between two villages. The villages must be paired together via a previous
 * call to @see OUTPUT_SetVillageSuspensionPair
 *
 * @param villageEntityA One of the villages to be unpaired.
 * @param villageEntityB One of the villages to be unpaired.
 */
declare function OUTPUT_UnsetVillageSuspensionPair(villageEntityA: number, villageEntityB: number): void

/**
 * Toggle a hud element to be visible or hidden.
 *
 * @param hudKey The key mapped to the hud element to show or hide.
 * @param visible The flag that determines if the element will be shown or hidden
 */
declare function OUTPUT_UpdateHUDVisibility(hudKey: string, visible: boolean): void

/**
 * Stretches the `badger:aabb` of an entity to a very tall prism. Useful for ignoring height on trigger volumes.
 *
 * @param aabbEntities The entities to stretch AABBs for.
 */
declare function OUTPUT_VerticallyStretchAABBToMax(aabbEntities: number[]): void


// FILE CONTENTS: bsharp_api_queries.gen.d.ts


/**
 * Gets the count of a speific type of card for a named deck.
 *
 * @param deckName The deck name.
 * @param libraryIndex The library index (card type).
 */
declare function QUERY_CountCardTypeInDeck(deckName: string, libraryIndex: number): number

/**
 * Get the current health of all the given entities and sums it together.
 *
 * @param entities The entities to check.
 */
declare function QUERY_CurrentHealth(entities: number[]): number

/**
 * Get the team of the entity that destroyed the victim entity. Must be called in DestroyedEntity snippet.
 *
 * @param entity Victim entity
 */
declare function QUERY_DestroyerEntityTeam(entity: number): string

/**
 * Returns `true` if an entity has an onscreen waypoint icon. See `OUTPUT_AddWaypointIconByExistingEntityArchetype`.
 *
 * @param entity entity
 */
declare function QUERY_DoesEntityHaveAwaypointIcon(entity: number): boolean

/**
 * Checks if a player proximity observer with name exists.
 * @see OUTPUT_CreatePlayerProximityObserver
 *
 * @param observerName The observer ID.
 */
declare function QUERY_DoesPlayerProximityObserverExist(observerName: string): boolean

/**
 * Get the elevation (height) of an entity. Useful for setting @see OUTPUT_PlacementSetElevationRule
 *
 * @param entity The entity to get the elevation of. Must have a position (ie. must exist in the world somewhere).
 */
declare function QUERY_Elevation(entity: number): number

/**
 * Gets the aggregated defense multiplier for an entity group.
 * @see `badger:invasion_defense_value`
 *
 * @param entities The entities to query.
 */
declare function QUERY_EntitiesInvasionDefenseMultiplier(entities: number[]): number

/**
 * Returns the sum invasion defense of all the entities.
 *
 * @param entities The entities to check.
 */
declare function QUERY_EntitiesInvasionDefenseValue(entities: number[]): number

/**
 * Returns the current game difficulty.
 *
 * 
 */
declare function QUERY_GameDifficulty(): string

/**
 * Returns all alive players in the game - excluding dead ones!
 * Returned players are guaranteed to have a position.
 *
 * 
 */
declare function QUERY_GetAlivePlayers(): number[]

/**
 * Get all the non-destroyed village entities in the world. 
 * INTENDED FOR USE WITH THE BSHARP PLACEMENT SYSTEM.
 *
 * 
 */
declare function QUERY_GetAllAliveVillages(): number[]

/**
 * Returns all claimed area entities in the game. One can filter them by FILTER_ByFactionName for example.
 *
 * 
 */
declare function QUERY_GetAllClaimedAreas(): number[]

/**
 * Returns all the players in the game - including dead ones!
 * Dead players will NOT have a position.
 *
 * 
 */
declare function QUERY_GetAllPlayers(): number[]

/**
 * Get all the village entities in the world. 
 * INTENDED FOR USE WITH THE BSHARP PLACEMENT SYSTEM.
 *
 * 
 */
declare function QUERY_GetAllVillages(): number[]

/**
 * Get the current amount of a resource for the campaign team.
 *
 * @param resourceName The name of the resource. Must be a campaign (team) resource.
 */
declare function QUERY_GetCampaignResource(resourceName: string): number

/**
 * Get the maximum amount of a resource for the campaign team.
 *
 * @param resourceName The name of the resource. Must be a campaign (team) resource.
 */
declare function QUERY_GetCampaignResourceMax(resourceName: string): number

/**
 * Get child entities that have a specific instance name from a set of parent entities.
 *
 * @param parentEntities The parent entities whose children should be checked.
 * @param instanceName The instance name of a specific entity. You can edit this in the *Structure Editor*.
 */
declare function QUERY_GetChildEntitiesWithInstanceName(parentEntities: number[], instanceName: string): number[]

/**
 * Returns the sum of radiuses of all provided claimed areas.
 *
 * @param claimedAreas Claimed areas to get the radius of.
 */
declare function QUERY_GetClaimedAreaRadius(claimedAreas: number[]): number

/**
 * Gets all entities currently assigned to the control groups.
 *
 * @param entities The control group entities.
 */
declare function QUERY_GetControlGroupEntities(entities: number[]): number[]

/**
 * Gets the associated creator for a given entity such as a building (usually the player entity).
 *
 * @param entity The entity to check.
 */
declare function QUERY_GetCreator(entity: number): number

/**
 * Get the cultural value for a specfic culture.
 * @returns The culture value
 *
 * @param villageId The village to evaluate the culture of.
 * @param scoreType "A", "B" or "C"
 */
declare function QUERY_GetCultureValue(villageId: number, scoreType: string): number

/**
 * Get the wave level in wave difficulty
 *
 * 
 */
declare function QUERY_GetCurrentWaveLevel(): number

/**
 * Returns the invasion action string if the base is planning something. Empty string if none.
 *
 * @param entity Base village entity.
 */
declare function QUERY_GetDelayedInvasionAction(entity: number): string

/**
 * Returns the target of the delayed invasion action of the given source base, if any.
 *
 * @param entity Source base entity (the one that starts the action).
 */
declare function QUERY_GetDelayedInvasionActionTarget(entity: number): number

/**
 * Gets a list of all archetypes and their counts from an entity group.
 * Should only be used for telemetry.
 *
 * @param entities The entities to query.
 */
declare function QUERY_GetEntitiesArchetypeCountList(entities: number[]): string

/**
 * Get the number of entities in an EG.
 * @returns Count of all entities in the EG.
 *
 * @param entities The EG to query.
 */
declare function QUERY_GetEntitiesCount(entities: number[]): number

/**
 * Gets all entities owned by a village (piglin base, culture villages, etc.). Includes mobs and structures.
 *
 * @param villageId The village ID to retrieve from.
 */
declare function QUERY_GetEntitiesOwnedByVillage(villageId: number): number[]

/**
 * Get entities with a specific instance name.
 * @returns EG of all entities with the instance name.
 *
 * @param name The instance name of a specific entity. You can edit this in the *Structure Editor*.
 */
declare function QUERY_GetEntitiesWithInstanceName(name: string): number[]

/**
 * Get entities with a tag filter.
 * @returns EG of all entities that fulfill the tag filter.
 *
 * @param includeTags The list of tags the entity must have. A white-list.
 * @param excludeTags The list of tags the entity must not have. A deny-list.
 */
declare function QUERY_GetEntitiesWithTagFilter(includeTags: string[], excludeTags: string[]): number[]

/**
 * Get entities that have a set of tags.
 * Entities may have additional tags.
 * @returns EG of all entities with the tags.
 *
 * @param tags The list of tags the entity must have.
 */
declare function QUERY_GetEntitiesWithTags(tags: string[]): number[]

/**
 * Get the faction name from a entity that belongs to a faction.
 *
 * @param entity The entity owned by a faction (or the faction itself!).
 */
declare function QUERY_GetFactionNameFromEntity(entity: number): string

/**
 * Get the faction name from a village.
 * @returns The name of the faction. (ex. "Faction of Unending Attack")
 *
 * @param villageId The Village ID to query.
 */
declare function QUERY_GetFactionNameFromVillageID(villageId: number): string

/**
 * Get the size for a village.
 * @returns The string size. (ex. "small", "medium", or "large")
 *
 * @param villageId The Village ID to query.
 */
declare function QUERY_GetFactionSizeFromVillageID(villageId: number): string

/**
 * Gets the current game mode.
 * @see GAMEMODE_CAMPAIGN , @see GAMEMODE_PVP , @see GAMEMODE_CREATIVE
 * @returns The gamemode string.
 *
 * 
 */
declare function QUERY_GetGameMode(): string

/**
 * Get the value of a global variable.
 * If the variable has not been set, will set it to and return 0.
 * @returns The value of the variable.
 *
 * @param variableName The variable to get.
 */
declare function QUERY_GetGlobalVariable(variableName: string): number

/**
 * Gets all the intruders inside of a spatial partition.
 * This is *only* entites that fulfill the tag requirements of the spatial partition.
 *
 * @param triggerEntity The spatial partition entity.
 */
declare function QUERY_GetIntruders(triggerEntity: number): number[]

/**
 * Returns all the FOB's associated with a given invasion attack V2.
 *
 * @param invasionId The ID of the invasion instance.
 */
declare function QUERY_GetInvasionAttackV2AttackingBases(invasionId: number): number[]

/**
 * Returns the attacking horde of a invasion attack V2 action.
 *
 * @param invasionId The ID of the invasion instance.
 */
declare function QUERY_GetInvasionAttackV2FactionName(invasionId: number): string

/**
 * Queries the engine to see if the given village is the target of an active invasion action.
 * Returns the invasion entity's Id if the village is the target of an action,
 * otherwise returns an invalid id.
 *
 * @param villageEntity The village entity that may or may not be under attack.
 */
declare function QUERY_GetInvasionAttackV2IdFromVillage(villageEntity: number): number

/**
 * Returns how much of the village attack time has completed, between [0 - 1]
 * Note: This will always return 0 if the attack has been started, but not activated.
 *
 * @param invasionId Id of the village attack v2.
 */
declare function QUERY_GetInvasionAttackV2PercentComplete(invasionId: number): number

/**
 * Returns the strength of a invasion attack V2 action.
 *
 * @param invasionId The ID of the invasion instance.
 */
declare function QUERY_GetInvasionAttackV2Strength(invasionId: number): number

/**
 * Returns the village under attack of a invasion attack V2 action.
 *
 * @param invasionId The ID of the invasion instance.
 */
declare function QUERY_GetInvasionAttackV2VillageId(invasionId: number): number

/**
 * Get current shown ui number of lives remaining set by OUTPUT_SetLivesCounter()
 *
 * 
 */
declare function QUERY_GetLivesCounter(): number

/**
 * Returns the deck size of a named deck. This ignores all sub-cards.
 *
 * @param deck The deck name
 */
declare function QUERY_GetNamedDeckCardCount(deck: string): number

/**
 * Returns the number of remaining seconds in a named timer. (@see OUTPUT_SetNamedTimer)
 *
 * @param timerName The name of the timer to check (ensure this has been set before calling!)
 */
declare function QUERY_GetNamedTimerSecondsElapsed(timerName: string): number

/**
 * Returns the entity archetype of the mount currently used by the player
 *
 * @param entity The player entity to check
 */
declare function QUERY_GetPlayerMountName(entity: number): string

/**
 * Returns the player entities that are within the bounds of the requested village.
 * NOTE: This will return players that are queued for destruction, so be very careful calling this in response to a player destruction event.
 *
 * @param villageId The id of the village to check for players in.
 */
declare function QUERY_GetPlayersInVillage(villageId: number): number[]

/**
 * Get the number of resources for an entity. Automatically retrieves the team count if it is a team resource.
 *
 * @param entity The player entity to check.
 * @param resourceName The resource identifier. (ex. "wood")
 */
declare function QUERY_GetResource(entity: number, resourceName: string): number

/**
 * Get the maximum amount of a resource for an entity. Automatically retrieves the team count if it is a team resource.
 *
 * @param entity The player entity to query for the resource from.
 * @param resourceName The resource identifier. (ex. "wood")
 */
declare function QUERY_GetResourceMax(entity: number, resourceName: string): number

/**
 * Gets the name of the team that an entity belongs to.
 *
 * @param entity The entity to get the team of.
 */
declare function QUERY_GetTeamName(entity: number): string

/**
 * Get the current amount of a resource for a team.
 *
 * @param teamName The name of the team.
 * @param resourceName The name of the resource. Must be a team resource.
 */
declare function QUERY_GetTeamResource(teamName: string, resourceName: string): number

/**
 * Get the maximum amount of a resource for a team.
 *
 * @param teamName The name of the team.
 * @param resourceName The name of the resource. Must be a team resource.
 */
declare function QUERY_GetTeamResourceMax(teamName: string, resourceName: string): number

/**
 * Get the player's ticket cap or their team's ticket cap given the ticket type
 *
 * @param player The player entity to check
 * @param ticketName The name of the ticket type to check
 */
declare function QUERY_GetTicketCap(player: number, ticketName: string): number

/**
 * Get the player's amount of tickets being used or their team's amount of tickets being used given the ticket type
 *
 * @param player The player entity to check
 * @param ticketName The name of the ticket type to check
 */
declare function QUERY_GetNumTicketsUsed(player: number, ticketName: string): number

/**
 * Returns a number (0-1) based on the current time of day
 *
 * 
 */
declare function QUERY_GetTimeOfDay(): number

/**
 * Gets the user ID for a given player entity.
 *
 * @param playerEntity The player entity.
 */
declare function QUERY_GetUserId(playerEntity: number): string

/**
 * Returns the number of online matches (public or private, practice mode excluded) the player has completed.
 *
 * @param playerEntity The player entity.
 */
declare function QUERY_GetUserMatchesPlayed(playerEntity: number): number

/**
 * fetches list of all villages claimed
 *
 * @param villages list of villages
 */
declare function QUERY_GetVillageClaimedAreas(villages: number[]): number[]

/**
 * Get the assigned flavour of a village.
 *
 * @param villageId The id of the village to query.
 */
declare function QUERY_GetVillageFlavour(villageId: number): string

/**
 * Gets all the village heart buildables for a village.
 *
 * @param villageId The village ID to query.
 */
declare function QUERY_GetVillageHearts(villageId: number): number[]

/**
 * Get a Village ID from an entity if the entity is associated with a village.
 * @returns Village ID the entity belongs to.
 *
 * @param entity A singular entity that is owned by a village.
 */
declare function QUERY_GetVillageIDFromEntity(entity: number): number

/**
 * Get the assigned objective of a village.
 *
 * @param villageId The id of the village to query.
 */
declare function QUERY_GetVillageObjective(villageId: number): string

/**
 * Return the name of the placement slot for a given entity.
 *
 * @param entity The entity to query
 */
declare function QUERY_GetWorldPlacementName(entity: number): string

/**
 * Returns whether a building was created by a player.
 *
 * @param entity The entity to query
 */
declare function QUERY_HasCreator(entity: number): boolean

/**
 * Returns `true` if an entity has an entity timer associated (@see OUTPUT_SetEntityTimer)
 *
 * @param entity The entity to associate a timer with.
 * @param timerName The name of the timer to associate
 */
declare function QUERY_HasEntityTimer(entity: number, timerName: string): boolean

/**
 * Returns whether or not entity is leashed.
 *
 * @param entityWithLeash Entity to check if leashed or not.
 */
declare function QUERY_HasLeash(entityWithLeash: number): boolean

/**
 * Returns whether or not a compass entity has a max range override.
 *
 * @param entityToPoll The compass entity.
 */
declare function QUERY_HasOverrideForCompassMaxRange(entityToPoll: number): boolean

/**
 * Returns true if the entity has the requested tags. False otherwise.
 *
 * @param entity The entity to check the tags of. Must be a single entity.
 * @param tags The tags to check.
 */
declare function QUERY_HasTags(entity: number, tags: string[]): boolean

/**
 * Check if the given entity has a placement slot name
 *
 * @param entity Entity to check
 */
declare function QUERY_HasWorldPlacementName(entity: number): boolean

/**
 * Returns true if the delayed action is hidden (no WM updates will be shown).
 *
 * @param entity Source base
 */
declare function QUERY_IsDelayedInvasionActionHidden(entity: number): boolean

/**
 * Returns true if the entity is disabled (eg. by health)
 *
 * @param entity Entity to check
 */
declare function QUERY_IsEntityDisabled(entity: number): boolean

/**
 * Check if a variable exists (has been set).
 * @returns True if variable exists and has been set, false otherwise.
 *
 * @param variableName The variable to check.
 */
declare function QUERY_IsGlobalVariableSet(variableName: string): boolean

/**
 * Check if the host is in the special campaign onboarding flow.
 *
 * 
 */
declare function QUERY_IsHostInCampaignOnboardingFlow(): boolean

/**
 * Checks if a specific invasion action is over.
 *
 * @param invasionId The invasion ID.
 */
declare function QUERY_IsInvasionOver(invasionId: number): boolean

/**
 * Checks if a named timer exists. Do not confuse it with the "paused" timer state.
 *
 * @param timerName The timer to check.
 */
declare function QUERY_IsNamedTimerActive(timerName: string): boolean

/**
 * Checks to see if a player entity is mounted or not.
 *
 * @param entity The player entity to check
 */
declare function QUERY_IsPlayerMounted(entity: number): boolean

/**
 * Returns true/false according to the fact whether or not the village will be a target of attack the upcoming night.
 *
 * @param entity Village entity.
 */
declare function QUERY_IsTargetOfDelayedInvasionAction(entity: number): boolean

/**
 * Checks if a village has been destroyed.
 * @returns True if the village has been destroyed.
 *
 * @param villageId The village ID to check.
 */
declare function QUERY_IsVillageDestroyed(villageId: number): boolean

/**
 * Checks if a village is occupied (by piglins).
 *
 * @param villageId The village ID to check.
 */
declare function QUERY_IsVillageOccupied(villageId: number): boolean

/**
 * Get the maximum health of all the given entities and sums it together.
 *
 * @param entities The entities to check.
 */
declare function QUERY_MaxHealth(entities: number[]): number

/**
 * Returns an entity that has the calculated position from BSharpPlacement.
 * Only usable if BSharpPlacement execution was successful.
 *
 * 
 */
declare function QUERY_PlacementResultPosition(): number

/**
 * Returns the selected primary entity from BSharpPlacement.
 * Only usable if BSharpPlacement execution was successful.
 *
 * 
 */
declare function QUERY_PlacementResultPrimary(): number

/**
 * Check if BSharpPlacement execution was successful.
 * `OUTPUT_PlacementExecute` also returns if it was successful.
 *
 * 
 */
declare function QUERY_PlacementSuccess(): boolean

/**
 * Get a deterministic random number based on level seed.
 *
 * @param min The minimum value - inclusive.
 * @param max The maximum value - inclusive.
 */
declare function QUERY_RandomNumber(min: number, max: number): number

/**
 * Get a deterministic random number based on level seed from a group.
 * Will automatically create a new group if it doesn't exist.
 * Note: The initial state is purely initialized from the seed (the group name does not impact it).
 *
 * @param min The minimum value - inclusive.
 * @param max The maximum value - inclusive.
 * @param group The group name.
 */
declare function QUERY_RandomNumberGroup(min: number, max: number, group: string): number

/**
 * Get frame count. For use with testing infrastructure.
 * @returns Total number of frames seen since game was started, or 0 if unsupported configuration
 *
 * 
 */
declare function QUERY_TEST_GetFrameCount(): number

/**
 * Get the number of players currently within the bounds of a village.
 *
 * @param villageId The village to check for player presence of.
 */
declare function QUERY_VillagePlayerPresenceCount(villageId: number): number


// FILE CONTENTS: bsharp_api_snippet.gen.d.ts


/**
 * Logic to perform when an entity is a part of FOREACH_ iteration.
 * This snippet is called individually on ALL entities associated with the Listener.
 * @see LISTENFOR_ForEachEntity
 */
declare function SNIPPET_ForEachEntity(snippetName: string, callback: ForEachEntityCallback): void
declare type ForEachEntityCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a global timer has reached a predefined threshold.
 * @see LISTENFOR_Timer
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_Timer(snippetName: string, callback: TimerCallback): void
declare type TimerCallback = (timeLeft: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a local timer has reached a predefined threshold.
 * @see LISTENFOR_LocalTimer
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_LocalTimer(snippetName: string, callback: LocalTimerCallback): void
declare type LocalTimerCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when an entity timer has reached 0.
 * @see LISTENFOR_EntityTimer
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_EntityTimer(snippetName: string, callback: EntityTimerCallback): void
declare type EntityTimerCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity enters a spatial trigger
 * @see `"badger:aabb"` and `"badger:trigger_criteria"`
 * @see LISTENFOR_SpatialPartitionEntered
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_SpatialPartitionEntered(snippetName: string, callback: SpatialPartitionEnteredCallback): void
declare type SpatialPartitionEnteredCallback = (triggerEntity: number, enteringEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity exits a spatial trigger
 * @see `"badger:aabb"` and `"badger:trigger_criteria"`
 * @see LISTENFOR_SpatialPartitionExited
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_SpatialPartitionExited(snippetName: string, callback: SpatialPartitionExitedCallback): void
declare type SpatialPartitionExitedCallback = (triggerEntity: number, exitingEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a spatial trigger detects an entity within it for any reason.
 * Note this differs from @see SNIPPET_SpatialPartitionEntered in that it will always be triggered even if
 * an entity unsuspends within the volume.
 */
declare function SNIPPET_PresenceEntered(snippetName: string, callback: PresenceEnteredCallback): void
declare type PresenceEnteredCallback = (triggerEntity: number, count: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a spatial trigger detects an entity has left it for any reason.
 * Note this differs from @see SNIPPET_SpatialPartitionExited in that it will always be triggered even if
 * the entity 'left' due to being destroyed, suspended, logging out of the game, etc.
 */
declare function SNIPPET_PresenceExited(snippetName: string, callback: PresenceExitedCallback): void
declare type PresenceExitedCallback = (triggerEntity: number, count: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a player enters a village's bounds.
 */
declare function SNIPPET_PlayerEnteredVillage(snippetName: string, callback: PlayerEnteredVillageCallback): void
declare type PlayerEnteredVillageCallback = (villageId: number, playerCount: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a player exits a village's bounds.
 */
declare function SNIPPET_PlayerExitedVillage(snippetName: string, callback: PlayerExitedVillageCallback): void
declare type PlayerExitedVillageCallback = (villageId: number, playerCount: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a card is played.
 */
declare function SNIPPET_CardPlayed(snippetName: string, callback: CardPlayedCallback): void
declare type CardPlayedCallback = (factionName: string, payload: SnippetPayload) => void

/**
 * Logic to perform when a horde card is played.
 */
declare function SNIPPET_HordeCardPlayed(snippetName: string, callback: HordeCardPlayedCallback): void
declare type HordeCardPlayedCallback = (factionName: string, payload: SnippetPayload) => void

/**
 * Logic to perform when an invasion card is played.
 */
declare function SNIPPET_InvasionCardPlayed(snippetName: string, callback: InvasionCardPlayedCallback): void
declare type InvasionCardPlayedCallback = (factionName: string, cardAction: string, cardFallbackAction: string, payload: SnippetPayload) => void

/**
 * Logic to perform when a global variable changes.
 * @see LISTENFOR_GlobalVariableChanged
 */
declare function SNIPPET_GlobalVariableChanged(snippetName: string, callback: GlobalVariableChangedCallback): void
declare type GlobalVariableChangedCallback = (oldValue: number, newValue: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village building is placed.
 * @see LISTENFOR_BuildingStart
 */
declare function SNIPPET_BuildingStart(snippetName: string, callback: BuildingStartCallback): void
declare type BuildingStartCallback = (buildingEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village building is placed.
 * @see LISTENFOR_BuildingComplete
 */
declare function SNIPPET_BuildingComplete(snippetName: string, callback: BuildingCompleteCallback): void
declare type BuildingCompleteCallback = (buildingEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village building fails to place.
 */
declare function SNIPPET_BuildingFailedToPlace(snippetName: string, callback: BuildingFailedToPlaceCallback): void
declare type BuildingFailedToPlaceCallback = (buildingId: string, villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity is spawned.
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_EntitySpawned(snippetName: string, callback: EntitySpawnedCallback): void
declare type EntitySpawnedCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity is refunded.
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_EntityRefunded(snippetName: string, callback: EntityRefundedCallback): void
declare type EntityRefundedCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity with a `"badger:buildable_spawner"` spawns an entity.
 */
declare function SNIPPET_BuildableSpawnerSpawned(snippetName: string, callback: BuildableSpawnerSpawnedCallback): void
declare type BuildableSpawnerSpawnedCallback = (buildableSpawner: number, entity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an with a `"badger:buildable_spawner"` spawns a batch of entities.
 */
declare function SNIPPET_BuildableSpawnerBatchSpawned(snippetName: string, callback: BuildableSpawnerBatchSpawnedCallback): void
declare type BuildableSpawnerBatchSpawnedCallback = (buildableSpawner: number, entities: number[], payload: SnippetPayload) => void

/**
 * Logic to perform when an entity is destroyed.
 * @see LISTENFOR_NonPopCappedEntityDestroyed
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_NonPopCappedEntityDestroyed(snippetName: string, callback: NonPopCappedEntityDestroyedCallback): void
declare type NonPopCappedEntityDestroyedCallback = (entityGroup: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a pop-cappable entity is destroyed
 * @see LISTENFOR_PopCappedEntityDestroyed
 */
declare function SNIPPET_PopCappedEntityDestroyed(snippetName: string, callback: PopCappedEntityDestroyedCallback): void
declare type PopCappedEntityDestroyedCallback = (entityGroup: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a number of entities in a group are destroyed.
 */
declare function SNIPPET_EntitiesAmountDestroyed(snippetName: string, callback: EntitiesAmountDestroyedCallback): void
declare type EntitiesAmountDestroyedCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when an EG's health changes
 * @see LISTENFOR_HealthChanged
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_HealthChanged(snippetName: string, callback: HealthChangedCallback): void
declare type HealthChangedCallback = (entity: number, currentHealth: number, previousHealth: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a culture's values increases over a threshold.
 * @see LISTENFOR_CultureValueChangedUp
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_CultureValueChangedUp(snippetName: string, callback: CultureValueChangedUpCallback): void
declare type CultureValueChangedUpCallback = (scoreA: number, scoreB: number, scoreC: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a culture's values decreases below a threshold.
 * @see LISTENFOR_CultureValueChangedDown
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_CultureValueChangedDown(snippetName: string, callback: CultureValueChangedDownCallback): void
declare type CultureValueChangedDownCallback = (scoreA: number, scoreB: number, scoreC: number, payload: SnippetPayload) => void

/**
 * Logic to perform an entity's targeting priority changed
 * @see LISTENFOR_TriggerEvent
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_TriggerEvent(snippetName: string, callback: TriggerEventCallback): void
declare type TriggerEventCallback = (senderEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a team's resources change.
 * @param snippetName The snippet name.
 */
declare function SNIPPET_ResourcesChanged(snippetName: string, callback: ResourcesChangedCallback): void
declare type ResourcesChangedCallback = (resourceName: string, teamID: string, previousAmount: number, currentAmount: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an tether between two entities has snapped.
 * @see LISTENFOR_TetherOverLimit
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_TetherOverLimit(snippetName: string, callback: TetherOverLimitCallback): void
declare type TetherOverLimitCallback = (rootEntity: number, tetherEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a sysem external to B-Sharp triggers an event
 * @see LISTENFOR_ExternalEvent
 * the optionalEG is optional, and contains whatever the caller of ExternalEvent wants. Interpret it based on the context of the call
 * that is, each ExternalEvent knows what it means by the EG it passes, but this can differ from EG to EG
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_ExternalEvent(snippetName: string, callback: ExternalEventCallback): void
declare type ExternalEventCallback = (variant: VariantData, payload: SnippetPayload) => void

/**
 * Logic to perform when all builds for a base finises.
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_BaseBuildsFinished(snippetName: string, callback: BaseBuildsFinishedCallback): void
declare type BaseBuildsFinishedCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a POI is generated.
 * @see LISTENFOR_POIGenerated
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_POIGenerated(snippetName: string, callback: POIGeneratedCallback): void
declare type POIGeneratedCallback = (pOIEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village is generated.
 * @see LISTENFOR_VillageGenerated
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_VillageGenerated(snippetName: string, callback: VillageGeneratedCallback): void
declare type VillageGeneratedCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village is upgraded.
 */
declare function SNIPPET_VillageUpgraded(snippetName: string, callback: VillageUpgradedCallback): void
declare type VillageUpgradedCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform in response to a village and all of its instant buildings having generated.
 */
declare function SNIPPET_VillageFinishedBuilding(snippetName: string, callback: VillageFinishedBuildingCallback): void
declare type VillageFinishedBuildingCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform in response to a village and all of its instant buildings being planned.
 */
declare function SNIPPET_VillageFinishedPlanning(snippetName: string, callback: VillageFinishedPlanningCallback): void
declare type VillageFinishedPlanningCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village is destroyed.
 */
declare function SNIPPET_VillageDestroyed(snippetName: string, callback: VillageDestroyedCallback): void
declare type VillageDestroyedCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a village is planned.
 */
declare function SNIPPET_VillagePlanned(snippetName: string, callback: VillagePlannedCallback): void
declare type VillagePlannedCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to build a FOB type village used for the invasion attack v2 action.
 */
declare function SNIPPET_InvasionAttackV2FobGenerated(snippetName: string, callback: InvasionAttackV2FobGeneratedCallback): void
declare type InvasionAttackV2FobGeneratedCallback = (villageId: number, invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to perform when an event is triggered during a cinematic.
 * @see LISTENFOR_CinematicEvent
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_CinematicEvent(snippetName: string, callback: CinematicEventCallback): void
declare type CinematicEventCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when a cinematic starts playing.
 * @see LISTENFOR_CinematicStarted
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_CinematicStarted(snippetName: string, callback: CinematicStartedCallback): void
declare type CinematicStartedCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when a cinematic finishes playing.
 * @see LISTENFOR_CinematicFinished
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_CinematicFinished(snippetName: string, callback: CinematicFinishedCallback): void
declare type CinematicFinishedCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when a player interacts with an entity.
 * @see LISTENFOR_PlayerInteracted
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_PlayerInteracted(snippetName: string, callback: PlayerInteractedCallback): void
declare type PlayerInteractedCallback = (playerEntity: number, interactedEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a player selects/opens a HUD element.
 */
declare function SNIPPET_HudEvent(snippetName: string, callback: HudEventCallback): void
declare type HudEventCallback = (eventName: string, payload: SnippetPayload) => void

/**
 * Logic to apply when an objective entity is destroyed..
 */
declare function SNIPPET_InvasionDestroyEntitiesObjective(snippetName: string, callback: InvasionDestroyEntitiesObjectiveCallback): void
declare type InvasionDestroyEntitiesObjectiveCallback = (villageId: number, destroyedEntity: number, remainingEntities: number, payload: SnippetPayload) => void

/**
 * Logic to apply damage to an activated invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Activated(snippetName: string, callback: InvasionAttackV2ActivatedCallback): void
declare type InvasionAttackV2ActivatedCallback = (invasionData: InvasionAttackV2Data, percentComplete: number, timePast: number, payload: SnippetPayload) => void

/**
 * Logic to apply damage to an ended invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Ended(snippetName: string, callback: InvasionAttackV2EndedCallback): void
declare type InvasionAttackV2EndedCallback = (invasionData: InvasionAttackV2Data, success: boolean, payload: SnippetPayload) => void

/**
 * Logic to execute when intentions can be drawn and next invasion turn might be undertaken.
 */
declare function SNIPPET_InvasionIntentionsDrawn(snippetName: string, callback: InvasionIntentionsDrawnCallback): void
declare type InvasionIntentionsDrawnCallback = (payload: SnippetPayload) => void

/**
 * Logic to execute when invaison actions are executed at night.
 */
declare function SNIPPET_InvasionActionsExecuted(snippetName: string, callback: InvasionActionsExecutedCallback): void
declare type InvasionActionsExecutedCallback = (payload: SnippetPayload) => void

/**
 * Logic to execute when all planned actions for the night are done resolving.
 */
declare function SNIPPET_InvasionNightActionsResolved(snippetName: string, callback: InvasionNightActionsResolvedCallback): void
declare type InvasionNightActionsResolvedCallback = (payload: SnippetPayload) => void

/**
 * Logic to apply damage/effects to an piglin base which has oops'ed itself.
 * Please note that if Invasion Simulation is enabled, the base in question is probably suspended and you won't be able to get any of its buildings/entities.
 * In Invasion Simulation is enabled, the Oops does not damage the base's buildings.
 */
declare function SNIPPET_InvasionOopsApply(snippetName: string, callback: InvasionOopsApplyCallback): void
declare type InvasionOopsApplyCallback = (villageId: number, payload: SnippetPayload) => void

/**
 * Logic to execute when a delayed invasion action is executed.
 */
declare function SNIPPET_InvasionDelayedActionExecuted(snippetName: string, callback: InvasionDelayedActionExecutedCallback): void
declare type InvasionDelayedActionExecutedCallback = (sourceVillageId: number, actionName: string, targetVillageId: number, hidden: boolean, factionName: string, strength: number, payload: SnippetPayload) => void

/**
 * Logic to execute when an entity has arrived or failed to reach its destination.
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_MoveCallback(snippetName: string, callback: MoveCallbackCallback): void
declare type MoveCallbackCallback = (moverEntityGroup: number, successfullyArrived: boolean, payload: SnippetPayload) => void

/**
 * **DO NOT USE THIS**
 * Use `SpawnedBuildableCallback(snippetName)` instead!
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_SpawnedBuildableCallback(snippetName: string, callback: SpawnedBuildableCallbackCallback): void
declare type SpawnedBuildableCallbackCallback = (completedStructure: number, payload: SnippetPayload) => void

/**
 * Callback for when a time of day occurs
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_TimeOfDay(snippetName: string, callback: TimeOfDayCallback): void
declare type TimeOfDayCallback = (payload: SnippetPayload) => void

/**
 * Callback for when a tag is added to an entity.
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_TagAdded(snippetName: string, callback: TagAddedCallback): void
declare type TagAddedCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Callback for when a tag is removed from an entity.
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_TagRemoved(snippetName: string, callback: TagRemovedCallback): void
declare type TagRemovedCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Callback for when an entity is lured or unlured.
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_InfluenceLureChanged(snippetName: string, callback: InfluenceLureChangedCallback): void
declare type InfluenceLureChangedCallback = (entity: number, started: boolean, payload: SnippetPayload) => void

/**
 * Callback for when an entity is directed or undirected.
 *
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_InfluenceDirectorChanged(snippetName: string, callback: InfluenceDirectorChangedCallback): void
declare type InfluenceDirectorChangedCallback = (entity: number, started: boolean, payload: SnippetPayload) => void

/**
 * Logic to perform for each mob directed with a specific action and filter
 */
declare function SNIPPET_PlayerDirectedMob(snippetName: string, callback: PlayerDirectedMobCallback): void
declare type PlayerDirectedMobCallback = (payload: SnippetPayload) => void

/**
 * Callback for when an structure entity has **begun** to be deconstructed.
 */
declare function SNIPPET_DeconstructionStarted(snippetName: string, callback: DeconstructionStartedCallback): void
declare type DeconstructionStartedCallback = (deconstructedEntity: number, deconstructorEntity: number, payload: SnippetPayload) => void

/**
 * Callback for when an entity has death deferred by script.
 * This snippet must destroy the entity within 60 seconds for the failsafe will auto destroy it.
 * For example with `OUTPUT_DestroyEntities` or with a cinematic.
 */
declare function SNIPPET_DeferredDeath(snippetName: string, callback: DeferredDeathCallback): void
declare type DeferredDeathCallback = (entity: number, payload: SnippetPayload) => void

/**
 * Callback for when a player re/connects to the game.
 * Note: Currently this can trigger during the loading screen.
 */
declare function SNIPPET_PlayerConnected(snippetName: string, callback: PlayerConnectedCallback): void
declare type PlayerConnectedCallback = (playerEntity: number, isReconnecting: boolean, payload: SnippetPayload) => void

/**
 * Callback for when a player disconnects from the game.
 * Note: Currently this can trigger during the loading screen.
 * Will not trigger unless the player has triggered SNIPPET_PlayerConnected first.
 */
declare function SNIPPET_PlayerDisconnected(snippetName: string, callback: PlayerDisconnectedCallback): void
declare type PlayerDisconnectedCallback = (payload: SnippetPayload) => void

/**
 * Callback for when a game rule is set or modified.
 * @param snippetName The snippet name.
 * @param callback The callback to call.
 */
declare function SNIPPET_GameRuleChanged(snippetName: string, callback: GameRuleChangedCallback): void
declare type GameRuleChangedCallback = (variant: VariantData, payload: SnippetPayload) => void

/**
 * Callback for when a test has been started so that the test logic can be executed.
 */
declare function SNIPPET_TestStarted(snippetName: string, callback: TestStartedCallback): void
declare type TestStartedCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when an entity is disabled.
 */
declare function SNIPPET_EntityDisabled(snippetName: string, callback: EntityDisabledCallback): void
declare type EntityDisabledCallback = (disabledEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity is enabled.
 */
declare function SNIPPET_EntityEnabled(snippetName: string, callback: EntityEnabledCallback): void
declare type EntityEnabledCallback = (enabledEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when a generic card has been played for a village.
 * Generic cards apply flavours or objectives to villages.
 */
declare function SNIPPET_GenericCardPlayed(snippetName: string, callback: GenericCardPlayedCallback): void
declare type GenericCardPlayedCallback = (villageId: number, cardValue: string, payload: SnippetPayload) => void

/**
 * Logic to perform when a the player toggles advanced direct on or off
 */
declare function SNIPPET_AdvancedDirectToggle(snippetName: string, callback: AdvancedDirectToggleCallback): void
declare type AdvancedDirectToggleCallback = (playerEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when the player is ready
 */
declare function SNIPPET_PlayersReady(snippetName: string, callback: PlayersReadyCallback): void
declare type PlayersReadyCallback = (payload: SnippetPayload) => void

/**
 * Logic to perform when a player fast travels
 */
declare function SNIPPET_PlayerFastTravelled(snippetName: string, callback: PlayerFastTravelledCallback): void
declare type PlayerFastTravelledCallback = (playerEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform in response to a player mounting a mount.
 */
declare function SNIPPET_PlayerMounted(snippetName: string, callback: PlayerMountedCallback): void
declare type PlayerMountedCallback = (playerEntity: number, mountName: string, payload: SnippetPayload) => void

/**
 * Logic to perform in response to the invasion simulation requesting optional player action.
 */
declare function SNIPPET_InvasionPlayerActionsExecuted(snippetName: string, callback: InvasionPlayerActionsExecutedCallback): void
declare type InvasionPlayerActionsExecutedCallback = (isDayActions: boolean, payload: SnippetPayload) => void

/**
 * Logic to perform when an obsevered entity gets close to a player.
 */
declare function SNIPPET_EntityEnteredPlayerProximity(snippetName: string, callback: EntityEnteredPlayerProximityCallback): void
declare type EntityEnteredPlayerProximityCallback = (playerEntity: number, approachingEntity: number, payload: SnippetPayload) => void

/**
 * Logic to perform when the game difficulty changes
 */
declare function SNIPPET_DifficultyChanged(snippetName: string, callback: DifficultyChangedCallback): void
declare type DifficultyChangedCallback = (prevDifficulty: string, newDifficulty: string, payload: SnippetPayload) => void

/**
 * Logic to perform when an entity has been recalled
 * @see LISTENFOR_EntityRecalled
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_EntityRecalled(snippetName: string, callback: EntityRecalledCallback): void
declare type EntityRecalledCallback = (approachingEntity: number, payload: SnippetPayload) => void

/**
 * **`WARNING! WARNING! NO REFUGE!`** Do not use this outside onboarding or flatland game modes. Any logic that depends on this cannot be reliably guarunteed over the network or savegames. If this is used in campaign or PvP, it will likely not be able to ship.
 *
 * Logic to perform when a cue from when an item in `vo_sequence_definitions.json` finishes on a client.
 *
 * An example cue looks like the following:
 * ```json
 * {
 *  "type": "cue",
 *  "name": "test_cue"
 * }
 * ```
 *
 * @param snippetName The snippet name.
 */
declare function SNIPPET_ClientVOCueFinished(snippetName: string, callback: ClientVOCueFinishedCallback): void
declare type ClientVOCueFinishedCallback = (cueName: string, payload: SnippetPayload) => void

/**
 * Logic to perform when a player performs a target action.
 */
declare function SNIPPET_PlayerPerformedTargetAction(snippetName: string, callback: PlayerPerformedTargetActionCallback): void
declare type PlayerPerformedTargetActionCallback = (playerPerformingAction: number, actionName: string, payload: SnippetPayload) => void

/**
 * Logic to apply damage to a village in the context of a village attack.
 */
declare function SNIPPET_InvasionAttackV2DamageRequest(snippetName: string, callback: InvasionAttackV2DamageRequestCallback): void
declare type InvasionAttackV2DamageRequestCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to follow up a damage request. Triggers one frame after the original damage request.
 */
declare function SNIPPET_InvasionAttackV2PostDamageRequest(snippetName: string, callback: InvasionAttackV2PostDamageRequestCallback): void
declare type InvasionAttackV2PostDamageRequestCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to apply damage to a started invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Started(snippetName: string, callback: InvasionAttackV2StartedCallback): void
declare type InvasionAttackV2StartedCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to apply damage to an abandoned invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Abandoned(snippetName: string, callback: InvasionAttackV2AbandonedCallback): void
declare type InvasionAttackV2AbandonedCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to apply damage to a reactivated invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Reactivated(snippetName: string, callback: InvasionAttackV2ReactivatedCallback): void
declare type InvasionAttackV2ReactivatedCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to apply damage to an overtime invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Overtime(snippetName: string, callback: InvasionAttackV2OvertimeCallback): void
declare type InvasionAttackV2OvertimeCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to apply damage to a resolved invasion attack v2.
 */
declare function SNIPPET_InvasionAttackV2Resolve(snippetName: string, callback: InvasionAttackV2ResolveCallback): void
declare type InvasionAttackV2ResolveCallback = (invasionData: InvasionAttackV2Data, payload: SnippetPayload) => void

/**
 * Logic to perform when a status effect started on an entity.
 */
declare function SNIPPET_StatusEffectStarted(snippetName: string, callback: StatusEffectStartedCallback): void
declare type StatusEffectStartedCallback = (affectedEntity: number, statusEffectName: string, payload: SnippetPayload) => void

/**
 * Logic to perform when a status effect ended on an entity.
 */
declare function SNIPPET_StatusEffectExpired(snippetName: string, callback: StatusEffectExpiredCallback): void
declare type StatusEffectExpiredCallback = (affectedEntity: number, statusEffectName: string, payload: SnippetPayload) => void


// FILE CONTENTS: bsharp_api_snippet_data.d.ts

/**
 * Payload values sent from any listener.
 */
declare interface SnippetPayload {
    /**
     * Optional.
     * A group of entities.
     */
    entities: number[]

    /**
     * Optional.
     * A string value.
     */
    string: string

    /**
     * Optional.
     * A integer value.
     */
    int: number

    /**
     * Optional.
     * A decimal value.
     */
    float: number

    /**
     * Optional.
     * The owner village ID of the listener.
     * Only set if the listener did not opt out of having an owner.
     */
    ownerVillageId: number
}

/**
 * Common data sent into invasion attack specific snippets
 */
declare interface InvasionAttackData {
    /**
     * The attacking piglin faction name.
     */
    factionName: string

    /**
     * The defending culture name.
     */
    cultureName: string

    /**
     * The defending culture village.
     */
    villageId: number

    /**
     * The FOB village ID.
     * **undefined if FOB has not been spawned yet.**
     */
    fobVillageId: number

    /**
     * The attacking strength.
     */
    strength: number

    /**
     * The invasion ID that represents a specific invasion.
     */
    id: number
}

/**
 * Special data parameter that holds either a string, a number, or a boolean value.
 */
declare interface VariantData {
    /**
     * The value this variant holds. Either a string, number, or boolean.
     */
    value: string | number | boolean
}


// FILE CONTENTS: bsharp_api_snippet_misc.d.ts

/* eslint-disable @typescript-eslint/camelcase */
/*
========== INFO ==========
This file is composed manually. 
These functions are managed on the code end, contact the BSharp programmer team if this file is out of date.
These functions are "special" and will not be generated by the doc generator. BSharp programmers would usually add them manually
==========================
*/

/**
 * Logic to perform when the server begins.
 * No listener required. All bootstrap snippets will fire at the beginning of a new game.
 */
declare function SNIPPET_Bootstrap(snippetName: string, callback: BootstrapCallback): void
declare type BootstrapCallback = () => void

/**
 * Current patch version is: 1
 * Logic to perform when processing a patch.
 * No listener required. All bootstrap snippets will fire at the beginning of a new game.
 * This snippet runs at the start of EVERY game, even after save-load.
 */
declare function SNIPPET_ProcessPatch(snippetName: string, minPatchVersion: number, callback: ProcessPatchBootstrapCallback): void
declare type ProcessPatchBootstrapCallback = (newVersion: number) => void

/**
 * Logic to perform when the server begins.
 * No listener required. All bootstrap snippets will fire at the beginning of a new game.
 * This snippet runs at the start of EVERY game, even after save-load.
 */
declare function SNIPPET_GameLoadBootstrap(snippetName: string, callback: GameLoadBootstrapCallback): void
declare type GameLoadBootstrapCallback = (isSaveLoaded: boolean) => void

/**
 * Similiar to Bootstrap. The name of the snippet should match the rule that is being reacted to.
 * Passes along the value of the rule as a parameter.
 * No listener required. All rule initialized snippets will fire at the beginning of a new game.
 */
declare function SNIPPET_RuleInitialized(snippetName: string, callback: RuleInitializedCallback): void
declare type RuleInitializedCallback = (ruleValue: VariantData) => void

/**
 * Similiar to Bootstrap. The name of the snippet should match the game mode this is being reacted to.
 * No listener required. All rule initialized snippets will fire at the beginning of a new game.
 */
declare function SNIPPET_InheritsFromGameMode(snippetName: string, callback: RuleInitializedCallback): void
declare type RuleInitializedCallback = () => void

// FILE CONTENTS: ext_bsharp_api_outputs.gen.d.ts


/**
 * Clear all stored event listeners.
 *
 * 
 */
declare function OUTPUT_EXT_ClearAllListeners(): void

/**
 * Clear all global variables.
 *
 * 
 */
declare function OUTPUT_EXT_ClearGlobalVariables(): void

/**
 * Clone all the blocks from one area to another. Area bounds are defined by a source min and max position, and a destination min position (as the dimensions necessarily match, the destination max is inferred).
 *
 * @param srcMinX The X value of the block position that denotes the minimum bound of the area.
 * @param srcMinY The Y value of the block position that denotes the minimum bound of the area.
 * @param srcMinZ The Z value of the block position that denotes the minimum bound of the area.
 * @param srcMaxX The X value of the block position that denotes the maximum bound of the area.
 * @param srcMaxY The Y value of the block position that denotes the maximum bound of the area.
 * @param srcMaxZ The Z value of the block position that denotes the maximum bound of the area.
 * @param dstMinX The X value of the block position that denotes the minimum bound of the target destination.
 * @param dstMinY The Y value of the block position that denotes the minimum bound of the target destination.
 * @param dstMinZ The Z value of the block position that denotes the minimum bound of the target destination.
 */
declare function OUTPUT_EXT_CloneBlockArea(srcMinX: number, srcMinY: number, srcMinZ: number, srcMaxX: number, srcMaxY: number, srcMaxZ: number, dstMinX: number, dstMinY: number, dstMinZ: number): void

/**
 * Clone only the blocks specified, from one area to another. Area bounds are defined by a source min and max position, and a destination min position (as the dimensions necessarily match, the destination max is inferred).
 *
 * @param blockNames The collection of block types to be included in the area clone.
 * @param srcMinX The X value of the block position that denotes the minimum bound of the area.
 * @param srcMinY The Y value of the block position that denotes the minimum bound of the area.
 * @param srcMinZ The Z value of the block position that denotes the minimum bound of the area.
 * @param srcMaxX The X value of the block position that denotes the maximum bound of the area.
 * @param srcMaxY The Y value of the block position that denotes the maximum bound of the area.
 * @param srcMaxZ The Z value of the block position that denotes the maximum bound of the area.
 * @param dstMinX The X value of the block position that denotes the minimum bound of the target destination.
 * @param dstMinY The Y value of the block position that denotes the minimum bound of the target destination.
 * @param dstMinZ The Z value of the block position that denotes the minimum bound of the target destination.
 */
declare function OUTPUT_EXT_CloneBlockAreaFor(blockNames: string[], srcMinX: number, srcMinY: number, srcMinZ: number, srcMaxX: number, srcMaxY: number, srcMaxZ: number, dstMinX: number, dstMinY: number, dstMinZ: number): void

/**
 * Clone all the blocks, except for those filtered by the mask, from one area to another. Area bounds are defined by a source min and max position, and a destination min position (as the dimensions necessarily match, the destination max is inferred).
 *
 * @param blockNames blockNames The collection of block types to be discluded from the area clone.
 * @param srcMinX The X value of the block position that denotes the minimum bound of the area.
 * @param srcMinY The Y value of the block position that denotes the minimum bound of the area.
 * @param srcMinZ The Z value of the block position that denotes the minimum bound of the area.
 * @param srcMaxX The X value of the block position that denotes the maximum bound of the area.
 * @param srcMaxY The Y value of the block position that denotes the maximum bound of the area.
 * @param srcMaxZ The Z value of the block position that denotes the maximum bound of the area.
 * @param dstMinX The X value of the block position that denotes the minimum bound of the target destination.
 * @param dstMinY The Y value of the block position that denotes the minimum bound of the target destination.
 * @param dstMinZ The Z value of the block position that denotes the minimum bound of the target destination.
 */
declare function OUTPUT_EXT_CloneBlockAreaMask(blockNames: string[], srcMinX: number, srcMinY: number, srcMinZ: number, srcMaxX: number, srcMaxY: number, srcMaxZ: number, dstMinX: number, dstMinY: number, dstMinZ: number): void

/**
 * Set an entity's health regeneration to zero.
 *
 * @param entities The collection of entities to modify.
 */
declare function OUTPUT_EXT_DisableHealthRegeneration(entities: number[]): void

/**
 * Displays a modal UI window with customizable properties.
 *
 * @param title The text displayed at the top of the window.
 * @param body The text displayed in the body of the window.
 * @param imageUrl The reference url to an image either in the base game or included in an add on pack.
 * @param buttonOneText The text displayed on the first button.
 * @param callbackOne The string which maps to a SNIPPET_EXT_UICallback and used to define the behavior of the first button when pressed.
 * @param buttonTwoText The text displayed on the second button.
 * @param callbackTwo The string which maps to a SNIPPET_EXT_UICallback and used to define the behavior of the second button when pressed.
 */
declare function OUTPUT_EXT_DisplayUI(title: string, body: string, imageUrl: string, buttonOneText: string, callbackOne: string, buttonTwoText: string, callbackTwo: string): void

/**
 * Fill a defined area with a specific block type. The fill area is defined by a min and max position.
 *
 * @param blockName The block types to be placed.
 * @param minX The X value of the block position that denotes the minimum bound of the area.
 * @param minY The Y value of the block position that denotes the minimum bound of the area.
 * @param minZ The Z value of the block position that denotes the minimum bound of the area.
 * @param maxX The X value of the block position that denotes the maximum bound of the area.
 * @param maxY The Y value of the block position that denotes the maximum bound of the area.
 * @param maxZ The Z value of the block position that denotes the maximum bound of the area.
 */
declare function OUTPUT_EXT_FillBlockArea(blockName: string, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): void

/**
 * Restore an entity's default health regeneration as defined by its data.
 *
 * @param entities The collection of entities to modify.
 */
declare function OUTPUT_EXT_RestoreDefaultHealthRegeneration(entities: number[]): void

/**
 * Set a single block at an objective world position.
 *
 * @param blockName The block type to be placed.
 * @param x The X value of the block's position.
 * @param y The Y value of the block's position.
 * @param z The Z value of the block's position.
 */
declare function OUTPUT_EXT_SetBlock(blockName: string, x: number, y: number, z: number): void

/**
 * Set a single block at a position relative to a specified entity, applying an offset if desired.
 *
 * @param blockName The block type to be placed.
 * @param relativeEntity The entity to which the block's position is relative
 * @param x The X value of an offset from the relative entity.
 * @param y The Y value of an offset from the relative entity.
 * @param z The Z value of an offset from the relative entity.
 */
declare function OUTPUT_EXT_SetBlockRelative(blockName: string, relativeEntity: number, x: number, y: number, z: number): void

/**
 * Set the objective world position of a specific existing entity.
 *
 * @param targetEntity The entity who's position will be set.
 * @param x The X value the entity will be moved to.
 * @param y The Y value the entity will be moved to.
 * @param z The Z value the entity will be moved to.
 */
declare function OUTPUT_EXT_SetEntityPosition(targetEntity: number, x: number, y: number, z: number): void

/**
 * Set a scalar value for how much health is replenished per tick by the Health Regeneration System for a specified collection of entities.
 *
 * @param entities The collection of entities to modify.
 * @param scalar the scalar, relative to their base value, to serve as a modifier for health regeneration.
 */
declare function OUTPUT_EXT_SetHealthRegenerationScalar(entities: number[], scalar: number): void

/**
 * Set the current weather state to clear.
 *
 * 
 */
declare function OUTPUT_EXT_SetWeatherToClear(): void

/**
 * Set the current weather state to be dynamic as defined by the world.
 *
 * 
 */
declare function OUTPUT_EXT_SetWeatherToDynamic(): void

/**
 * Set the current weather state to rain.
 *
 * @param timeOfDay The intensity of rain downfall
 */
declare function OUTPUT_EXT_SetWeatherToRain(timeOfDay: number): void

/**
 * Spawn a buildable at an objective world position.
 *
 * @param buildableName The name of the buildable to spawn (eg: `badger:poi_sword_gold`).
 * @param buildableTeam The team to spawn the buildable on (required!)
 * @param facingDirection The orientation that the structre should be facing: (eg: `north`, `south`, `east`, or `west`).
 * @param instantBuild Should we instantly build this buildable.
 * @param onGround Snap buildable to the surface.
 * @param x The X value the buildable should be at.
 * @param y The Y value the buildable should be at.
 * @param z The Z value the buildable should be at.
 * @param callback A call to `SpawnBuildableCallback` with the snippet to call on complete. This can be ignored by passing in an empty string.
 */
declare function OUTPUT_EXT_SpawnBuildable(buildableName: string, buildableTeam: string, facingDirection: string, instantBuild: boolean, onGround: boolean, x: number, y: number, z: number, callback: string): void

/**
 * Spawn a buildable at an existing entity at an offset and snap it to a the ground, while ignoring possible collisions with other buildables
 *
 * @param buildableName The name of the buildable to spawn (eg: `badger:poi_sword_gold`).
 * @param entitiesPosition The entities to spawn this buildable at.
 * @param buildableTeam The team to spawn the buildable on (required!)
 * @param facingDirection The orientation that the structre should be facing: (eg: `north`, `south`, `east`, or `west`).
 * @param instantBuild Should we instantly build this buildable.
 * @param onGround Snap buildable to the surface.
 * @param x The X offset the buildable should be at.
 * @param y The Y offset the buildable should be at.
 * @param z The Z offset the buildable should be at.
 * @param callback A call to `SpawnBuildableCallback` with the snippet to call on complete. This can be ignored by passing in an empty string.
 */
declare function OUTPUT_EXT_SpawnBuildableAtWithOffsetWithoutCollision(buildableName: string, entitiesPosition: number[], buildableTeam: string, facingDirection: string, instantBuild: boolean, onGround: boolean, x: number, y: number, z: number, callback: string): void

/**
 * Spawn a buildable at an existing entity and snap it to a the ground, while ignoring possible collisions with other buildables.
 *
 * @param buildableName The name of the buildable to spawn (eg: `badger:poi_sword_gold`).
 * @param entitiesPosition The entities to spawn this buildable at.
 * @param buildableTeam The team to spawn the buildable on (required!).
 * @param facingDirection The orientation that the structre should be facing: (eg: `north`, `south`, `east`, or `west`).
 * @param instantBuild Should we instantly build this buildable.
 * @param onGround Snap buildable to the surface.
 * @param callback A call to `SpawnBuildableCallback` with the snippet to call on complete. This can be ignored by passing in an empty string.
 */
declare function OUTPUT_EXT_SpawnBuildableAtWithoutCollision(buildableName: string, entitiesPosition: number[], buildableTeam: string, facingDirection: string, instantBuild: boolean, onGround: boolean, callback: string): void

/**
 * Spawn a buildable at an objective world position, while ignoring possible collisions with other buildables.
 *
 * @param buildableName The name of the buildable to spawn (eg: `badger:poi_sword_gold`).
 * @param buildableTeam The team to spawn the buildable on (required!).
 * @param facingDirection The orientation that the structre should be facing: (eg: `north`, `south`, `east`, or `west`).
 * @param instantBuild Should we instantly build this buildable.
 * @param onGround Snap buildable to the surface.
 * @param x The X value the buildable should be at.
 * @param y The Y value the buildable should be at.
 * @param z The Z value the buildable should be at.
 * @param callback A call to `SpawnBuildableCallback` with the snippet to call on complete. This can be ignored by passing in an empty string.
 */
declare function OUTPUT_EXT_SpawnBuildableWithoutCollision(buildableName: string, buildableTeam: string, facingDirection: string, instantBuild: boolean, onGround: boolean, x: number, y: number, z: number, callback: string): void

/**
 * Spawn a single entity at an objective world position.
 *
 * @param archetypeName The archetype of the entity to spawn.
 * @param x The X value the entity should be spawned at.
 * @param y The Y value the entity should be spawned at.
 * @param z The Z value the entity should be spawned at.
 */
declare function OUTPUT_EXT_SpawnEntity(archetypeName: string, x: number, y: number, z: number): number

/**
 * Spawn a single entity at a position relative to another entity, with an offset if desired.
 *
 * @param archetypeName The archetype of the entity to spawn.
 * @param srcEntity The reference entity to spawn the new entity relative to.
 * @param x The X value offset the entity should be spawned at.
 * @param y The Y value offset the entity should be spawned at.
 * @param z The Z value offset the entity should be spawned at.
 */
declare function OUTPUT_EXT_SpawnEntityRelative(archetypeName: string, srcEntity: number, x: number, y: number, z: number): number

/**
 * Spawn a defined feature at an objective world position.
 *
 * @param featureName The name of the feature to spawn (eg: `badger:feature_brokenlands_algae_01`).
 * @param x The X value the feature should be at.
 * @param y The Y value the feature should be at.
 * @param z The Z value the feature should be at.
 */
declare function OUTPUT_EXT_SpawnFeature(featureName: string, x: number, y: number, z: number): void

/**
 * Spawn a defined structure at an objective world position.
 *
 * @param structureName The name of the structure to spawn (eg: `badger:gate_door_piglin`).
 * @param x0 The X value the structure should be at.
 * @param y0 The Y value the structure should be at.
 * @param z0 The Z value the structure should be at.
 * @param x1 The X value of an optional offset.
 * @param y1 The Y value of an optional offset.
 * @param z1 The Z value of an optional offset.
 * @param includeEntities Whether to consider entities that may conflict with placement. Pass `false` to ignore possible conflicts.
 * @param includeBlocks Whether to consider blocks that may conflict with placement. Pass `false` to ignore possible conflicts.
 * @param rotation The rotational degree of the Structure (0, 90, 180, 270)
 * @param mirror Whether or not to mirror the Structure along a certain axis ("none", "x", "xz", "z")
 * @param animationMode The Animation Mode of the structure ("none", "layers", "blocks)
 * @param ticks Animation Ticks
 * @param integrity Tthe Structure Data's Integrity Value (may result in random missing blocks)
 */
declare function OUTPUT_EXT_SpawnStructure(structureName: string, x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, includeEntities: boolean, includeBlocks: boolean, rotation: number, mirror: string, animationMode: string, ticks: number, integrity: number): void


// FILE CONTENTS: ext_bsharp_api_queries.gen.d.ts


/**
 * Retrieve all the tags on a specified entity.
 *
 * @param entity The entity from which to retrieve tags.
 */
declare function QUERY_EXT_GetAllTags(entity: number): string[]

/**
 * Retrieve the state of a block relative to an entity by means of the state's ID.
 *
 * @param x The X value of the world position to query.
 * @param y The Y value of the world position to query.
 * @param z The Z value of the world position to query.
 * @param stateID The state ID of the block being queried.
 */
declare function QUERY_EXT_GetBlockDataByID(x: number, y: number, z: number, stateID: number): number

/**
 * Retrieve the state of a block relative to an entity by means of the state's ID.
 *
 * @param relativeEntity The entity the query is relative to.
 * @param x The X value of the relative position to query.
 * @param y The Y value of the relative position to query.
 * @param z The Z value of the relative position to query.
 * @param stateID The state ID of the block being queried.
 */
declare function QUERY_EXT_GetBlockDataByIDRelative(relativeEntity: number, x: number, y: number, z: number, stateID: number): number

/**
 * Retrieve the state of a block at an objective world position by means of the state's name.
 *
 * @param x The X value of the world position to query.
 * @param y The Y value of the world position to query.
 * @param z The Z value of the world position to query.
 * @param stateName The name of the state to be queried.
 */
declare function QUERY_EXT_GetBlockDataByName(x: number, y: number, z: number, stateName: string): number

/**
 * Retrieve the state of a block relative to an entity by means of the state's name.
 *
 * @param relativeEntity The entity to which the query is relative.
 * @param x The X value of the world position to query.
 * @param y The Y value of the world position to query.
 * @param z The Z value of the world position to query.
 * @param stateName The name of the state to be queried.
 */
declare function QUERY_EXT_GetBlockDataByNameRelative(relativeEntity: number, x: number, y: number, z: number, stateName: string): number

/**
 * Get the name of a block at a specified objective world position.
 *
 * @param x The X value of the world position to query.
 * @param y The Y value of the world position to query.
 * @param z The Z value of the world position to query.
 */
declare function QUERY_EXT_GetBlockName(x: number, y: number, z: number): string

/**
 * Get the name of a block relative to a specified entity.
 *
 * @param relativeEntity The entity the query is relative to.
 * @param x The X value of the relative position to query.
 * @param y The Y value of the relative position to query.
 * @param z The Z value of the relative position to query.
 */
declare function QUERY_EXT_GetBlockNameRelative(relativeEntity: number, x: number, y: number, z: number): string

/**
 * Get the position of a specified entity
 * Position is a number[3] array containing x,y,z coordinates
 *
 * @param targetEntity The entity whose position to fetch, this is returned as a container of numbers, of size 3, in (x,y,z) ordering
 */
declare function QUERY_EXT_GetEntityPosition(targetEntity: number): number[]

/**
 * Test a world position for the presence of a specific block type.
 *
 * @param blockName The name of the block to look for.
 * @param x The X value of the world position to query.
 * @param y The Y value of the world position to query.
 * @param z The Z value of the world position to query.
 */
declare function QUERY_EXT_TestBlock(blockName: string, x: number, y: number, z: number): boolean

/**
 * Compare a source and destination areas, of equal size, for whether or not they have identical block compositions.
 *
 * @param srcMinX The X value of the source area's origin point.
 * @param srcMinY The Y value of the source area's origin point.
 * @param srcMinZ The Z value of the source area's origin point.
 * @param dstMinX The X value of the destination area's origin point.
 * @param dstMinY The Y value of the destination area's origin point.
 * @param dstMinZ The Z value of the destination area's origin point.
 * @param areaMaxX The X value that defines the size of the areas.
 * @param areaMaxY The Y value that defines the size of the areas.
 * @param areaMaxZ The Z value that defines the size of the areas.
 */
declare function QUERY_EXT_TestBlockArea(srcMinX: number, srcMinY: number, srcMinZ: number, dstMinX: number, dstMinY: number, dstMinZ: number, areaMaxX: number, areaMaxY: number, areaMaxZ: number): boolean


// FILE CONTENTS: ext_bsharp_api_snippet.gen.d.ts


/**
 * This SNIPPET will define the behavior of button presses when calling OUTPUT_EXT_DisplayUI. 
 * 
 * @param snippetName The string ID to be referenced by OUTPUT_EXT_DisplayUI calls via the callbackOne or callbackTwo fields
 * @param EXT_UICallbackCallback A callback that defines the behavior of the snippet
 */
declare function SNIPPET_EXT_UICallback(snippetName: string, callback: EXT_UICallbackCallback): void
declare type EXT_UICallbackCallback = (payload: SnippetPayload) => void
